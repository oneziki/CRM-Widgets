{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { getRTL, classNamesFunction } from '@fluentui/utilities';\nimport { FocusZone } from '../../FocusZone';\nimport { getDateRangeArray, getDayGrid, getBoundedDateRange, isRestrictedDate, DAYS_IN_WEEK, compareDates, DateRangeType } from '@fluentui/date-time-utilities';\nimport { usePrevious, useId } from '@fluentui/react-hooks';\nimport { CalendarMonthHeaderRow } from './CalendarMonthHeaderRow';\nimport { CalendarGridRow } from './CalendarGridRow';\nvar getClassNames = classNamesFunction();\n\nfunction useDayRefs() {\n  var daysRef = React.useRef({});\n\n  var getSetRefCallback = function (dayKey) {\n    return function (element) {\n      if (element === null) {\n        delete daysRef.current[dayKey];\n      } else {\n        daysRef.current[dayKey] = element;\n      }\n    };\n  };\n\n  return [daysRef, getSetRefCallback];\n}\n\nfunction useWeeks(props, onSelectDate, getSetRefCallback) {\n  /**\n   * Initial parsing of the given props to generate IDayInfo two dimensional array, which contains a representation\n   * of every day in the grid. Convenient for helping with conversions between day refs and Date objects in callbacks.\n   */\n  var weeks = React.useMemo(function () {\n    var _a, _b, _c;\n\n    var weeksGrid = getDayGrid(props);\n    var firstVisibleDay = weeksGrid[1][0].originalDate;\n    var lastVisibleDay = weeksGrid[weeksGrid.length - 1][6].originalDate;\n    var markedDays = ((_b = (_a = props).getMarkedDays) === null || _b === void 0 ? void 0 : _b.call(_a, firstVisibleDay, lastVisibleDay)) || [];\n    /**\n     * Weeks is a 2D array. Weeks[0] contains the last week of the prior range,\n     * Weeks[weeks.length - 1] contains first week of next range. These are for transition states.\n     *\n     * Weeks[1... weeks.length - 2] contains the actual visible data\n     */\n\n    var returnValue = [];\n\n    for (var weekIndex = 0; weekIndex < weeksGrid.length; weekIndex++) {\n      var week = [];\n\n      var _loop_1 = function (dayIndex) {\n        var day = weeksGrid[weekIndex][dayIndex];\n\n        var dayInfo = __assign(__assign({\n          onSelected: function () {\n            return onSelectDate(day.originalDate);\n          },\n          setRef: getSetRefCallback(day.key)\n        }, day), {\n          isMarked: day.isMarked || ((_c = markedDays) === null || _c === void 0 ? void 0 : _c.some(function (markedDay) {\n            return compareDates(day.originalDate, markedDay);\n          }))\n        });\n\n        week.push(dayInfo);\n      };\n\n      for (var dayIndex = 0; dayIndex < DAYS_IN_WEEK; dayIndex++) {\n        _loop_1(dayIndex);\n      }\n\n      returnValue.push(week);\n    }\n\n    return returnValue; // TODO: this is missing deps on getSetRefCallback and onSelectDate (and depending on the entire\n    // props object may not be a good idea due to likely frequent mutation). It would be easy to\n    // fix getSetRefCallback to not mutate every render, but onSelectDate is passed down from\n    // Calendar and trying to fix it requires a huge cascade of changes.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [props]);\n  return weeks;\n}\n/**\n * Hook to determine whether to animate the CalendarDayGrid forwards or backwards\n * @returns true if the grid should animate backwards; false otherwise\n */\n\n\nfunction useAnimateBackwards(weeks) {\n  var previousNavigatedDate = usePrevious(weeks[0][0].originalDate);\n\n  if (!previousNavigatedDate || previousNavigatedDate.getTime() === weeks[0][0].originalDate.getTime()) {\n    return undefined;\n  } else if (previousNavigatedDate <= weeks[0][0].originalDate) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nfunction useWeekCornerStyles(props) {\n  /**\n   *\n   * Section for setting the rounded corner styles on individual day cells. Individual day cells need different\n   * corners to be rounded depending on which date range type and where the cell is located in the current grid.\n   * If we just round all of the corners, there isn't a good overlap and we get gaps between contiguous day boxes\n   * in Edge browser.\n   *\n   */\n  var getWeekCornerStyles = function (classNames, initialWeeks) {\n    var weekCornersStyled = {};\n    /* need to handle setting all of the corners on arbitrarily shaped blobs\n          __\n       __|A |\n      |B |C |__\n      |D |E |F |\n           in this case, A needs top left rounded, top right rounded\n      B needs top left rounded\n      C doesn't need any rounding\n      D needs bottom left rounded\n      E doesn't need any rounding\n      F needs top right rounding\n    */\n    // cut off the animation transition weeks\n\n    var weeks = initialWeeks.slice(1, initialWeeks.length - 1); // if there's an item above, lose both top corners. Item below, lose both bottom corners, etc.\n\n    weeks.forEach(function (week, weekIndex) {\n      week.forEach(function (day, dayIndex) {\n        var above = weeks[weekIndex - 1] && weeks[weekIndex - 1][dayIndex] && isInSameHoverRange(weeks[weekIndex - 1][dayIndex].originalDate, day.originalDate, weeks[weekIndex - 1][dayIndex].isSelected, day.isSelected);\n        var below = weeks[weekIndex + 1] && weeks[weekIndex + 1][dayIndex] && isInSameHoverRange(weeks[weekIndex + 1][dayIndex].originalDate, day.originalDate, weeks[weekIndex + 1][dayIndex].isSelected, day.isSelected);\n        var left = weeks[weekIndex][dayIndex - 1] && isInSameHoverRange(weeks[weekIndex][dayIndex - 1].originalDate, day.originalDate, weeks[weekIndex][dayIndex - 1].isSelected, day.isSelected);\n        var right = weeks[weekIndex][dayIndex + 1] && isInSameHoverRange(weeks[weekIndex][dayIndex + 1].originalDate, day.originalDate, weeks[weekIndex][dayIndex + 1].isSelected, day.isSelected);\n        var style = calculateRoundedStyles(classNames, above, below, left, right);\n        weekCornersStyled[weekIndex + '_' + dayIndex] = style;\n      });\n    });\n    return weekCornersStyled;\n  };\n\n  var calculateRoundedStyles = function (classNames, above, below, left, right) {\n    var style = '';\n    var roundedTopLeft = !above && !left;\n    var roundedTopRight = !above && !right;\n    var roundedBottomLeft = !below && !left;\n    var roundedBottomRight = !below && !right;\n\n    if (roundedTopLeft) {\n      style = getRTL() ? style.concat(classNames.topRightCornerDate + ' ') : style.concat(classNames.topLeftCornerDate + ' ');\n    }\n\n    if (roundedTopRight) {\n      style = getRTL() ? style.concat(classNames.topLeftCornerDate + ' ') : style.concat(classNames.topRightCornerDate + ' ');\n    }\n\n    if (roundedBottomLeft) {\n      style = getRTL() ? style.concat(classNames.bottomRightCornerDate + ' ') : style.concat(classNames.bottomLeftCornerDate + ' ');\n    }\n\n    if (roundedBottomRight) {\n      style = getRTL() ? style.concat(classNames.bottomLeftCornerDate + ' ') : style.concat(classNames.bottomRightCornerDate + ' ');\n    }\n\n    return style;\n  };\n\n  var isInSameHoverRange = function (date1, date2, date1Selected, date2Selected) {\n    var dateRangeType = props.dateRangeType,\n        firstDayOfWeek = props.firstDayOfWeek,\n        workWeekDays = props.workWeekDays; // The hover state looks weird with non-contiguous days in work week view. In work week, show week hover state\n\n    var dateRangeHoverType = dateRangeType === DateRangeType.WorkWeek ? DateRangeType.Week : dateRangeType; // we do not pass daysToSelectInDayView because we handle setting those styles dyanamically in onMouseOver\n\n    var dateRange = getDateRangeArray(date1, dateRangeHoverType, firstDayOfWeek, workWeekDays);\n\n    if (date1Selected !== date2Selected) {\n      // if one is selected and the other is not, they can't be in the same range\n      return false;\n    } else if (date1Selected && date2Selected) {\n      // if they're both selected at the same time they must be in the same range\n      return true;\n    } // otherwise, both must be unselected, so check the dateRange\n\n\n    return dateRange.filter(function (date) {\n      return date.getTime() === date2.getTime();\n    }).length > 0;\n  };\n\n  return [getWeekCornerStyles, calculateRoundedStyles];\n}\n\nexport var CalendarDayGridBase = function (props) {\n  var navigatedDayRef = React.useRef(null);\n  var activeDescendantId = useId();\n\n  var onSelectDate = function (selectedDate) {\n    var _a, _b, _c, _d;\n\n    var firstDayOfWeek = props.firstDayOfWeek,\n        minDate = props.minDate,\n        maxDate = props.maxDate,\n        workWeekDays = props.workWeekDays,\n        daysToSelectInDayView = props.daysToSelectInDayView,\n        restrictedDates = props.restrictedDates;\n    var restrictedDatesOptions = {\n      minDate: minDate,\n      maxDate: maxDate,\n      restrictedDates: restrictedDates\n    };\n    var dateRange = getDateRangeArray(selectedDate, dateRangeType, firstDayOfWeek, workWeekDays, daysToSelectInDayView);\n    dateRange = getBoundedDateRange(dateRange, minDate, maxDate);\n    dateRange = dateRange.filter(function (d) {\n      return !isRestrictedDate(d, restrictedDatesOptions);\n    });\n    (_b = (_a = props).onSelectDate) === null || _b === void 0 ? void 0 : _b.call(_a, selectedDate, dateRange);\n    (_d = (_c = props).onNavigateDate) === null || _d === void 0 ? void 0 : _d.call(_c, selectedDate, true);\n  };\n\n  var _a = useDayRefs(),\n      daysRef = _a[0],\n      getSetRefCallback = _a[1];\n\n  var weeks = useWeeks(props, onSelectDate, getSetRefCallback);\n  var animateBackwards = useAnimateBackwards(weeks);\n\n  var _b = useWeekCornerStyles(props),\n      getWeekCornerStyles = _b[0],\n      calculateRoundedStyles = _b[1];\n\n  React.useImperativeHandle(props.componentRef, function () {\n    return {\n      focus: function () {\n        var _a, _b, _c;\n\n        (_c = (_a = navigatedDayRef.current) === null || _a === void 0 ? void 0 : (_b = _a).focus) === null || _c === void 0 ? void 0 : _c.call(_b);\n      }\n    };\n  }, []);\n  /**\n   *\n   * Section for setting hover/pressed styles. Because we want arbitrary blobs of days to be selectable, to support\n   * highlighting every day in the month for month view, css :hover style isn't enough, so we need mouse callbacks\n   * to set classnames on all relevant child refs to apply the styling\n   *\n   */\n\n  var getDayInfosInRangeOfDay = function (dayToCompare) {\n    // The hover state looks weird with non-contiguous days in work week view. In work week, show week hover state\n    var dateRangeHoverType = getDateRangeTypeToUse(props.dateRangeType, props.workWeekDays); // gets all the dates for the given date range type that are in the same date range as the given day\n\n    var dateRange = getDateRangeArray(dayToCompare.originalDate, dateRangeHoverType, props.firstDayOfWeek, props.workWeekDays, props.daysToSelectInDayView).map(function (date) {\n      return date.getTime();\n    }); // gets all the day refs for the given dates\n\n    var dayInfosInRange = weeks.reduce(function (accumulatedValue, currentWeek) {\n      return accumulatedValue.concat(currentWeek.filter(function (weekDay) {\n        return dateRange.indexOf(weekDay.originalDate.getTime()) !== -1;\n      }));\n    }, []);\n    return dayInfosInRange;\n  };\n\n  var getRefsFromDayInfos = function (dayInfosInRange) {\n    var dayRefs = [];\n    dayRefs = dayInfosInRange.map(function (dayInfo) {\n      return daysRef.current[dayInfo.key];\n    });\n    return dayRefs;\n  };\n\n  var styles = props.styles,\n      theme = props.theme,\n      className = props.className,\n      dateRangeType = props.dateRangeType,\n      showWeekNumbers = props.showWeekNumbers,\n      labelledBy = props.labelledBy,\n      lightenDaysOutsideNavigatedMonth = props.lightenDaysOutsideNavigatedMonth,\n      animationDirection = props.animationDirection;\n  var classNames = getClassNames(styles, {\n    theme: theme,\n    className: className,\n    dateRangeType: dateRangeType,\n    showWeekNumbers: showWeekNumbers,\n    lightenDaysOutsideNavigatedMonth: lightenDaysOutsideNavigatedMonth === undefined ? true : lightenDaysOutsideNavigatedMonth,\n    animationDirection: animationDirection,\n    animateBackwards: animateBackwards\n  }); // When the month is highlighted get the corner dates so that styles can be added to them\n\n  var weekCorners = getWeekCornerStyles(classNames, weeks);\n  var partialWeekProps = {\n    weeks: weeks,\n    navigatedDayRef: navigatedDayRef,\n    calculateRoundedStyles: calculateRoundedStyles,\n    activeDescendantId: activeDescendantId,\n    classNames: classNames,\n    weekCorners: weekCorners,\n    getDayInfosInRangeOfDay: getDayInfosInRangeOfDay,\n    getRefsFromDayInfos: getRefsFromDayInfos\n  };\n  return React.createElement(FocusZone, {\n    className: classNames.wrapper\n  }, React.createElement(\"table\", {\n    className: classNames.table,\n    \"aria-readonly\": \"true\",\n    \"aria-multiselectable\": \"false\",\n    \"aria-labelledby\": labelledBy,\n    \"aria-activedescendant\": activeDescendantId,\n    role: \"grid\"\n  }, React.createElement(\"tbody\", null, React.createElement(CalendarMonthHeaderRow, __assign({}, props, {\n    classNames: classNames,\n    weeks: weeks\n  })), React.createElement(CalendarGridRow, __assign({}, props, partialWeekProps, {\n    week: weeks[0],\n    weekIndex: -1,\n    rowClassName: classNames.firstTransitionWeek,\n    ariaRole: \"presentation\",\n    ariaHidden: true\n  })), weeks.slice(1, weeks.length - 1).map(function (week, weekIndex) {\n    return React.createElement(CalendarGridRow, __assign({}, props, partialWeekProps, {\n      key: weekIndex,\n      week: week,\n      weekIndex: weekIndex,\n      rowClassName: classNames.weekRow\n    }));\n  }), React.createElement(CalendarGridRow, __assign({}, props, partialWeekProps, {\n    week: weeks[weeks.length - 1],\n    weekIndex: -2,\n    rowClassName: classNames.lastTransitionWeek,\n    ariaRole: \"presentation\",\n    ariaHidden: true\n  })))));\n};\nCalendarDayGridBase.displayName = 'CalendarDayGridBase';\n/**\n * When given work week, if the days are non-contiguous, the hover states look really weird. So for non-contiguous\n * work weeks, we'll just show week view instead.\n */\n\nfunction getDateRangeTypeToUse(dateRangeType, workWeekDays) {\n  if (workWeekDays && dateRangeType === DateRangeType.WorkWeek) {\n    var sortedWWDays = workWeekDays.slice().sort();\n    var isContiguous = true;\n\n    for (var i = 1; i < sortedWWDays.length; i++) {\n      if (sortedWWDays[i] !== sortedWWDays[i - 1] + 1) {\n        isContiguous = false;\n        break;\n      }\n    }\n\n    if (!isContiguous || workWeekDays.length === 0) {\n      return DateRangeType.Week;\n    }\n  }\n\n  return dateRangeType;\n}","map":{"version":3,"sources":["components/CalendarDayGrid/CalendarDayGrid.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { getRTL, classNamesFunction } from '@fluentui/utilities';\nimport { FocusZone } from '../../FocusZone';\nimport {\n  getDateRangeArray,\n  getDayGrid,\n  getBoundedDateRange,\n  isRestrictedDate,\n  IDay,\n  DAYS_IN_WEEK,\n  compareDates,\n  DateRangeType,\n  DayOfWeek,\n} from '@fluentui/date-time-utilities';\nimport { ICalendarDayGridProps, ICalendarDayGridStyleProps, ICalendarDayGridStyles } from './CalendarDayGrid.types';\nimport { IProcessedStyleSet } from '@fluentui/style-utilities';\nimport { usePrevious, useId } from '@fluentui/react-hooks';\nimport { CalendarMonthHeaderRow } from './CalendarMonthHeaderRow';\nimport { CalendarGridRow } from './CalendarGridRow';\n\nconst getClassNames = classNamesFunction<ICalendarDayGridStyleProps, ICalendarDayGridStyles>();\n\nexport interface IWeekCorners {\n  [key: string]: string;\n}\n\nexport interface IDayInfo extends IDay {\n  onSelected: () => void;\n  setRef(element: HTMLElement | null): void;\n}\n\nfunction useDayRefs() {\n  const daysRef = React.useRef<Record<string, HTMLElement>>({});\n\n  const getSetRefCallback = (dayKey: string) => (element: HTMLElement | null) => {\n    if (element === null) {\n      delete daysRef.current[dayKey];\n    } else {\n      daysRef.current[dayKey] = element;\n    }\n  };\n\n  return [daysRef, getSetRefCallback] as const;\n}\n\nfunction useWeeks(\n  props: ICalendarDayGridProps,\n  onSelectDate: (date: Date) => void,\n  getSetRefCallback: (dayKey: string) => (element: HTMLElement | null) => void,\n): IDayInfo[][] {\n  /**\n   * Initial parsing of the given props to generate IDayInfo two dimensional array, which contains a representation\n   * of every day in the grid. Convenient for helping with conversions between day refs and Date objects in callbacks.\n   */\n  const weeks = React.useMemo((): IDayInfo[][] => {\n    const weeksGrid = getDayGrid(props);\n\n    const firstVisibleDay = weeksGrid[1][0].originalDate;\n    const lastVisibleDay = weeksGrid[weeksGrid.length - 1][6].originalDate;\n    const markedDays = props.getMarkedDays?.(firstVisibleDay, lastVisibleDay) || [];\n\n    /**\n     * Weeks is a 2D array. Weeks[0] contains the last week of the prior range,\n     * Weeks[weeks.length - 1] contains first week of next range. These are for transition states.\n     *\n     * Weeks[1... weeks.length - 2] contains the actual visible data\n     */\n    const returnValue: IDayInfo[][] = [];\n\n    for (let weekIndex = 0; weekIndex < weeksGrid.length; weekIndex++) {\n      const week: IDayInfo[] = [];\n      for (let dayIndex = 0; dayIndex < DAYS_IN_WEEK; dayIndex++) {\n        const day = weeksGrid[weekIndex][dayIndex];\n        const dayInfo: IDayInfo = {\n          onSelected: () => onSelectDate(day.originalDate),\n          setRef: getSetRefCallback(day.key),\n          ...day,\n          isMarked: day.isMarked || markedDays?.some(markedDay => compareDates(day.originalDate, markedDay)),\n        };\n\n        week.push(dayInfo);\n      }\n      returnValue.push(week);\n    }\n\n    return returnValue;\n    // TODO: this is missing deps on getSetRefCallback and onSelectDate (and depending on the entire\n    // props object may not be a good idea due to likely frequent mutation). It would be easy to\n    // fix getSetRefCallback to not mutate every render, but onSelectDate is passed down from\n    // Calendar and trying to fix it requires a huge cascade of changes.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [props]);\n\n  return weeks;\n}\n\n/**\n * Hook to determine whether to animate the CalendarDayGrid forwards or backwards\n * @returns true if the grid should animate backwards; false otherwise\n */\nfunction useAnimateBackwards(weeks: IDayInfo[][]): boolean | undefined {\n  const previousNavigatedDate = usePrevious(weeks[0][0].originalDate);\n\n  if (!previousNavigatedDate || previousNavigatedDate.getTime() === weeks[0][0].originalDate.getTime()) {\n    return undefined;\n  } else if (previousNavigatedDate <= weeks[0][0].originalDate) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nfunction useWeekCornerStyles(props: ICalendarDayGridProps) {\n  /**\n   *\n   * Section for setting the rounded corner styles on individual day cells. Individual day cells need different\n   * corners to be rounded depending on which date range type and where the cell is located in the current grid.\n   * If we just round all of the corners, there isn't a good overlap and we get gaps between contiguous day boxes\n   * in Edge browser.\n   *\n   */\n  const getWeekCornerStyles = (\n    classNames: IProcessedStyleSet<ICalendarDayGridStyles>,\n    initialWeeks: IDayInfo[][],\n  ): IWeekCorners => {\n    const weekCornersStyled: { [key: string]: string } = {};\n    /* need to handle setting all of the corners on arbitrarily shaped blobs\n          __\n       __|A |\n      |B |C |__\n      |D |E |F |\n\n      in this case, A needs top left rounded, top right rounded\n      B needs top left rounded\n      C doesn't need any rounding\n      D needs bottom left rounded\n      E doesn't need any rounding\n      F needs top right rounding\n    */\n\n    // cut off the animation transition weeks\n    const weeks = initialWeeks.slice(1, initialWeeks.length - 1);\n\n    // if there's an item above, lose both top corners. Item below, lose both bottom corners, etc.\n    weeks.forEach((week: IDayInfo[], weekIndex: number) => {\n      week.forEach((day: IDayInfo, dayIndex: number) => {\n        const above =\n          weeks[weekIndex - 1] &&\n          weeks[weekIndex - 1][dayIndex] &&\n          isInSameHoverRange(\n            weeks[weekIndex - 1][dayIndex].originalDate,\n            day.originalDate,\n            weeks[weekIndex - 1][dayIndex].isSelected,\n            day.isSelected,\n          );\n        const below =\n          weeks[weekIndex + 1] &&\n          weeks[weekIndex + 1][dayIndex] &&\n          isInSameHoverRange(\n            weeks[weekIndex + 1][dayIndex].originalDate,\n            day.originalDate,\n            weeks[weekIndex + 1][dayIndex].isSelected,\n            day.isSelected,\n          );\n        const left =\n          weeks[weekIndex][dayIndex - 1] &&\n          isInSameHoverRange(\n            weeks[weekIndex][dayIndex - 1].originalDate,\n            day.originalDate,\n            weeks[weekIndex][dayIndex - 1].isSelected,\n            day.isSelected,\n          );\n        const right =\n          weeks[weekIndex][dayIndex + 1] &&\n          isInSameHoverRange(\n            weeks[weekIndex][dayIndex + 1].originalDate,\n            day.originalDate,\n            weeks[weekIndex][dayIndex + 1].isSelected,\n            day.isSelected,\n          );\n\n        const style = calculateRoundedStyles(classNames, above, below, left, right);\n\n        weekCornersStyled[weekIndex + '_' + dayIndex] = style;\n      });\n    });\n\n    return weekCornersStyled;\n  };\n\n  const calculateRoundedStyles = (\n    classNames: IProcessedStyleSet<ICalendarDayGridStyles>,\n    above: boolean,\n    below: boolean,\n    left: boolean,\n    right: boolean,\n  ): string => {\n    let style = '';\n    const roundedTopLeft = !above && !left;\n    const roundedTopRight = !above && !right;\n    const roundedBottomLeft = !below && !left;\n    const roundedBottomRight = !below && !right;\n\n    if (roundedTopLeft) {\n      style = getRTL()\n        ? style.concat(classNames.topRightCornerDate + ' ')\n        : style.concat(classNames.topLeftCornerDate + ' ');\n    }\n    if (roundedTopRight) {\n      style = getRTL()\n        ? style.concat(classNames.topLeftCornerDate + ' ')\n        : style.concat(classNames.topRightCornerDate + ' ');\n    }\n    if (roundedBottomLeft) {\n      style = getRTL()\n        ? style.concat(classNames.bottomRightCornerDate + ' ')\n        : style.concat(classNames.bottomLeftCornerDate + ' ');\n    }\n    if (roundedBottomRight) {\n      style = getRTL()\n        ? style.concat(classNames.bottomLeftCornerDate + ' ')\n        : style.concat(classNames.bottomRightCornerDate + ' ');\n    }\n\n    return style;\n  };\n\n  const isInSameHoverRange = (date1: Date, date2: Date, date1Selected: boolean, date2Selected: boolean): boolean => {\n    const { dateRangeType, firstDayOfWeek, workWeekDays } = props;\n\n    // The hover state looks weird with non-contiguous days in work week view. In work week, show week hover state\n    const dateRangeHoverType = dateRangeType === DateRangeType.WorkWeek ? DateRangeType.Week : dateRangeType;\n\n    // we do not pass daysToSelectInDayView because we handle setting those styles dyanamically in onMouseOver\n    const dateRange = getDateRangeArray(date1, dateRangeHoverType, firstDayOfWeek, workWeekDays);\n\n    if (date1Selected !== date2Selected) {\n      // if one is selected and the other is not, they can't be in the same range\n      return false;\n    } else if (date1Selected && date2Selected) {\n      // if they're both selected at the same time they must be in the same range\n      return true;\n    }\n\n    // otherwise, both must be unselected, so check the dateRange\n    return dateRange.filter((date: Date) => date.getTime() === date2.getTime()).length > 0;\n  };\n\n  return [getWeekCornerStyles, calculateRoundedStyles] as const;\n}\n\nexport const CalendarDayGridBase: React.FunctionComponent<ICalendarDayGridProps> = props => {\n  const navigatedDayRef = React.useRef<HTMLButtonElement>(null);\n\n  const activeDescendantId = useId();\n\n  const onSelectDate = (selectedDate: Date): void => {\n    const { firstDayOfWeek, minDate, maxDate, workWeekDays, daysToSelectInDayView, restrictedDates } = props;\n    const restrictedDatesOptions = { minDate, maxDate, restrictedDates };\n\n    let dateRange = getDateRangeArray(selectedDate, dateRangeType, firstDayOfWeek, workWeekDays, daysToSelectInDayView);\n    dateRange = getBoundedDateRange(dateRange, minDate, maxDate);\n\n    dateRange = dateRange.filter((d: Date) => {\n      return !isRestrictedDate(d, restrictedDatesOptions);\n    });\n\n    props.onSelectDate?.(selectedDate, dateRange);\n    props.onNavigateDate?.(selectedDate, true);\n  };\n\n  const [daysRef, getSetRefCallback] = useDayRefs();\n\n  const weeks = useWeeks(props, onSelectDate, getSetRefCallback);\n  const animateBackwards = useAnimateBackwards(weeks);\n  const [getWeekCornerStyles, calculateRoundedStyles] = useWeekCornerStyles(props);\n\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      focus() {\n        navigatedDayRef.current?.focus?.();\n      },\n    }),\n    [],\n  );\n\n  /**\n   *\n   * Section for setting hover/pressed styles. Because we want arbitrary blobs of days to be selectable, to support\n   * highlighting every day in the month for month view, css :hover style isn't enough, so we need mouse callbacks\n   * to set classnames on all relevant child refs to apply the styling\n   *\n   */\n  const getDayInfosInRangeOfDay = (dayToCompare: IDayInfo): IDayInfo[] => {\n    // The hover state looks weird with non-contiguous days in work week view. In work week, show week hover state\n    const dateRangeHoverType = getDateRangeTypeToUse(props.dateRangeType, props.workWeekDays);\n\n    // gets all the dates for the given date range type that are in the same date range as the given day\n    const dateRange = getDateRangeArray(\n      dayToCompare.originalDate,\n      dateRangeHoverType,\n      props.firstDayOfWeek,\n      props.workWeekDays,\n      props.daysToSelectInDayView,\n    ).map((date: Date) => date.getTime());\n\n    // gets all the day refs for the given dates\n    const dayInfosInRange = weeks.reduce((accumulatedValue: IDayInfo[], currentWeek: IDayInfo[]) => {\n      return accumulatedValue.concat(\n        currentWeek.filter((weekDay: IDayInfo) => dateRange.indexOf(weekDay.originalDate.getTime()) !== -1),\n      );\n    }, []);\n\n    return dayInfosInRange;\n  };\n\n  const getRefsFromDayInfos = (dayInfosInRange: IDayInfo[]): (HTMLElement | null)[] => {\n    let dayRefs: (HTMLElement | null)[] = [];\n    dayRefs = dayInfosInRange.map((dayInfo: IDayInfo) => daysRef.current[dayInfo.key]);\n\n    return dayRefs;\n  };\n\n  const {\n    styles,\n    theme,\n    className,\n    dateRangeType,\n    showWeekNumbers,\n    labelledBy,\n    lightenDaysOutsideNavigatedMonth,\n    animationDirection,\n  } = props;\n\n  const classNames = getClassNames(styles, {\n    theme: theme!,\n    className: className,\n    dateRangeType: dateRangeType,\n    showWeekNumbers: showWeekNumbers,\n    lightenDaysOutsideNavigatedMonth:\n      lightenDaysOutsideNavigatedMonth === undefined ? true : lightenDaysOutsideNavigatedMonth,\n    animationDirection: animationDirection,\n    animateBackwards: animateBackwards,\n  });\n\n  // When the month is highlighted get the corner dates so that styles can be added to them\n  const weekCorners: IWeekCorners = getWeekCornerStyles(classNames, weeks!);\n  const partialWeekProps = {\n    weeks,\n    navigatedDayRef,\n    calculateRoundedStyles,\n    activeDescendantId,\n    classNames,\n    weekCorners,\n    getDayInfosInRangeOfDay,\n    getRefsFromDayInfos,\n  } as const;\n\n  return (\n    <FocusZone className={classNames.wrapper}>\n      <table\n        className={classNames.table}\n        aria-readonly=\"true\"\n        aria-multiselectable=\"false\"\n        aria-labelledby={labelledBy}\n        aria-activedescendant={activeDescendantId}\n        role=\"grid\"\n      >\n        <tbody>\n          <CalendarMonthHeaderRow {...props} classNames={classNames} weeks={weeks} />\n          <CalendarGridRow\n            {...props}\n            {...partialWeekProps}\n            week={weeks[0]}\n            weekIndex={-1}\n            rowClassName={classNames.firstTransitionWeek}\n            ariaRole=\"presentation\"\n            ariaHidden={true}\n          />\n          {weeks!.slice(1, weeks!.length - 1).map((week: IDayInfo[], weekIndex: number) => (\n            <CalendarGridRow\n              {...props}\n              {...partialWeekProps}\n              key={weekIndex}\n              week={week}\n              weekIndex={weekIndex}\n              rowClassName={classNames.weekRow}\n            />\n          ))}\n          <CalendarGridRow\n            {...props}\n            {...partialWeekProps}\n            week={weeks![weeks!.length - 1]}\n            weekIndex={-2}\n            rowClassName={classNames.lastTransitionWeek}\n            ariaRole=\"presentation\"\n            ariaHidden={true}\n          />\n        </tbody>\n      </table>\n    </FocusZone>\n  );\n};\nCalendarDayGridBase.displayName = 'CalendarDayGridBase';\n\n/**\n * When given work week, if the days are non-contiguous, the hover states look really weird. So for non-contiguous\n * work weeks, we'll just show week view instead.\n */\nfunction getDateRangeTypeToUse(dateRangeType: DateRangeType, workWeekDays: DayOfWeek[] | undefined): DateRangeType {\n  if (workWeekDays && dateRangeType === DateRangeType.WorkWeek) {\n    const sortedWWDays = workWeekDays.slice().sort();\n    let isContiguous = true;\n    for (let i = 1; i < sortedWWDays.length; i++) {\n      if (sortedWWDays[i] !== sortedWWDays[i - 1] + 1) {\n        isContiguous = false;\n        break;\n      }\n    }\n\n    if (!isContiguous || workWeekDays.length === 0) {\n      return DateRangeType.Week;\n    }\n  }\n\n  return dateRangeType;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}