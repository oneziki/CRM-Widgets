{"ast":null,"code":"import { __assign, __decorate, __extends, __rest, __spreadArrays } from \"tslib\";\nimport * as React from 'react';\nimport { Autofill } from '../../Autofill';\nimport { initializeComponentRef, css, customizable, divProperties, findElementRecursive, findIndex, focusAsync, getId, getNativeProps, isIOS, isMac, KeyCodes, shallowCompare, mergeAriaAttributeValues, warnMutuallyExclusive, Async, EventGroup, getPropsWithDefaults } from '../../Utilities';\nimport { Callout, DirectionalHint } from '../../Callout';\nimport { Checkbox } from '../../Checkbox';\nimport { getCaretDownButtonStyles, getOptionStyles, getStyles } from './ComboBox.styles';\nimport { getClassNames, getComboBoxOptionClassNames } from './ComboBox.classNames';\nimport { Label } from '../../Label';\nimport { SelectableOptionMenuItemType, getAllSelectedOptions } from '../../SelectableOption';\nimport { CommandButton, IconButton } from '../../Button';\nimport { useMergedRefs } from '@fluentui/react-hooks';\nvar SearchDirection;\n\n(function (SearchDirection) {\n  SearchDirection[SearchDirection[\"backward\"] = -1] = \"backward\";\n  SearchDirection[SearchDirection[\"none\"] = 0] = \"none\";\n  SearchDirection[SearchDirection[\"forward\"] = 1] = \"forward\";\n})(SearchDirection || (SearchDirection = {}));\n\nvar HoverStatus;\n\n(function (HoverStatus) {\n  /** Used when the user was hovering and has since moused out of the menu items */\n  HoverStatus[HoverStatus[\"clearAll\"] = -2] = \"clearAll\";\n  /** Default \"normal\" state, when no hover has happened or a hover is in progress */\n\n  HoverStatus[HoverStatus[\"default\"] = -1] = \"default\";\n})(HoverStatus || (HoverStatus = {}));\n\nvar ScrollIdleDelay = 250;\n/* ms */\n\nvar TouchIdleDelay = 500;\n/* ms */\n\n/**\n * This is used to clear any pending autocomplete text (used when autocomplete is true and\n * allowFreeform is false)\n */\n\nvar ReadOnlyPendingAutoCompleteTimeout = 1000;\n/* ms */\n\n/**\n * Internal component that is used to wrap all ComboBox options.\n * This is used to customize when we want to re-render components,\n * so we don't re-render every option every time render is executed.\n */\n\nvar ComboBoxOptionWrapper = React.memo(function (_a) {\n  var render = _a.render;\n  return render();\n}, function (_a, _b) {\n  var oldRender = _a.render,\n      oldProps = __rest(_a, [\"render\"]);\n\n  var newRender = _b.render,\n      newProps = __rest(_b, [\"render\"]); // The render function will always be different, so we ignore that prop\n\n\n  return shallowCompare(oldProps, newProps);\n});\nvar COMPONENT_NAME = 'ComboBox';\nvar DEFAULT_PROPS = {\n  options: [],\n  allowFreeform: false,\n  autoComplete: 'on',\n  buttonIconProps: {\n    iconName: 'ChevronDown'\n  }\n};\n\nfunction useOptionsState(_a) {\n  var options = _a.options,\n      defaultSelectedKey = _a.defaultSelectedKey,\n      selectedKey = _a.selectedKey;\n  /** The currently selected indices */\n\n  var _b = React.useState(function () {\n    return getSelectedIndices(options, buildDefaultSelectedKeys(defaultSelectedKey, selectedKey));\n  }),\n      selectedIndices = _b[0],\n      setSelectedIndices = _b[1];\n  /** The options currently available for the callout */\n\n\n  var _c = React.useState(options),\n      currentOptions = _c[0],\n      setCurrentOptions = _c[1];\n  /** This value is used for the autocomplete hint value */\n\n\n  var _d = React.useState(),\n      suggestedDisplayValue = _d[0],\n      setSuggestedDisplayValue = _d[1];\n\n  React.useEffect(function () {\n    if (selectedKey !== undefined) {\n      var selectedKeys = buildSelectedKeys(selectedKey);\n      var indices = getSelectedIndices(options, selectedKeys);\n      setSelectedIndices(indices);\n    }\n\n    setCurrentOptions(options);\n  }, [options, selectedKey]);\n  React.useEffect(function () {\n    if (selectedKey === null) {\n      setSuggestedDisplayValue(undefined);\n    }\n  }, [selectedKey]);\n  return [selectedIndices, setSelectedIndices, currentOptions, setCurrentOptions, suggestedDisplayValue, setSuggestedDisplayValue];\n}\n\nexport var ComboBox = React.forwardRef(function (propsWithoutDefaults, forwardedRef) {\n  var _a = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults),\n      ref = _a.ref,\n      props = __rest(_a, [\"ref\"]);\n\n  var rootRef = React.useRef(null);\n  var mergedRootRef = useMergedRefs(rootRef, forwardedRef);\n\n  var _b = useOptionsState(props),\n      selectedIndices = _b[0],\n      setSelectedIndices = _b[1],\n      currentOptions = _b[2],\n      setCurrentOptions = _b[3],\n      suggestedDisplayValue = _b[4],\n      setSuggestedDisplayValue = _b[5];\n\n  return React.createElement(ComboBoxInternal, __assign({}, props, {\n    hoisted: {\n      mergedRootRef: mergedRootRef,\n      rootRef: rootRef,\n      selectedIndices: selectedIndices,\n      setSelectedIndices: setSelectedIndices,\n      currentOptions: currentOptions,\n      setCurrentOptions: setCurrentOptions,\n      suggestedDisplayValue: suggestedDisplayValue,\n      setSuggestedDisplayValue: setSuggestedDisplayValue\n    }\n  }));\n});\nComboBox.displayName = COMPONENT_NAME;\n\nvar ComboBoxInternal =\n/** @class */\nfunction (_super) {\n  __extends(ComboBoxInternal, _super);\n\n  function ComboBoxInternal(props) {\n    var _this = _super.call(this, props) || this;\n    /** The input aspect of the combo box */\n\n\n    _this._autofill = React.createRef();\n    /** The wrapping div of the input and button */\n\n    _this._comboBoxWrapper = React.createRef();\n    /** The callout element */\n\n    _this._comboBoxMenu = React.createRef();\n    /** The menu item element that is currently selected */\n\n    _this._selectedElement = React.createRef();\n    /**\n     * {@inheritdoc}\n     */\n\n    _this.focus = function (shouldOpenOnFocus, useFocusAsync) {\n      if (_this._autofill.current) {\n        if (useFocusAsync) {\n          focusAsync(_this._autofill.current);\n        } else {\n          _this._autofill.current.focus();\n        }\n\n        if (shouldOpenOnFocus) {\n          _this.setState({\n            isOpen: true\n          });\n        }\n      } // Programmatically setting focus means that there is nothing else that needs to be done\n      // Focus is now contained\n\n\n      if (!_this._hasFocus()) {\n        _this.setState({\n          focusState: 'focused'\n        });\n      }\n    };\n    /**\n     * Close menu callout if it is open\n     */\n\n\n    _this.dismissMenu = function () {\n      var isOpen = _this.state.isOpen;\n      isOpen && _this.setState({\n        isOpen: false\n      });\n    };\n    /**\n     * componentWillReceiveProps handler for the auto fill component\n     * Checks/updates the input value to set, if needed\n     * @param defaultVisibleValue - the defaultVisibleValue that got passed\n     *  in to the auto fill's componentWillReceiveProps\n     * @returns - the updated value to set, if needed\n     */\n\n\n    _this._onUpdateValueInAutofillWillReceiveProps = function () {\n      var comboBox = _this._autofill.current;\n\n      if (!comboBox) {\n        return null;\n      }\n\n      if (comboBox.value === null || comboBox.value === undefined) {\n        return null;\n      }\n\n      var visibleValue = normalizeToString(_this._currentVisibleValue);\n\n      if (comboBox.value !== visibleValue) {\n        return visibleValue;\n      }\n\n      return comboBox.value;\n    };\n\n    _this._renderComboBoxWrapper = function (multiselectAccessibleText, errorMessageId) {\n      var _a = _this.props,\n          label = _a.label,\n          disabled = _a.disabled,\n          ariaLabel = _a.ariaLabel,\n          ariaDescribedBy = _a.ariaDescribedBy,\n          required = _a.required,\n          errorMessage = _a.errorMessage,\n          buttonIconProps = _a.buttonIconProps,\n          _b = _a.isButtonAriaHidden,\n          isButtonAriaHidden = _b === void 0 ? true : _b,\n          title = _a.title,\n          placeholderProp = _a.placeholder,\n          tabIndex = _a.tabIndex,\n          autofill = _a.autofill,\n          iconButtonProps = _a.iconButtonProps,\n          suggestedDisplayValue = _a.hoisted.suggestedDisplayValue;\n      var isOpen = _this.state.isOpen; // If the combo box has focus, is multiselect, and has a display string, then use that placeholder\n      // so that the selected items don't appear to vanish. This is not ideal but it's the only reasonable way\n      // to correct the behavior where the input is cleared so the user can type. If a full refactor is done, then this\n      // should be removed and the multiselect combo box should behave like a picker.\n\n      var placeholder = _this._hasFocus() && _this.props.multiSelect && multiselectAccessibleText ? multiselectAccessibleText : placeholderProp;\n      return React.createElement(\"div\", {\n        \"data-ktp-target\": true,\n        ref: _this._comboBoxWrapper,\n        id: _this._id + 'wrapper',\n        className: _this._classNames.root\n      }, React.createElement(Autofill, __assign({\n        \"data-ktp-execute-target\": true,\n        \"data-is-interactable\": !disabled,\n        componentRef: _this._autofill,\n        id: _this._id + '-input',\n        className: _this._classNames.input,\n        type: \"text\",\n        onFocus: _this._onFocus,\n        onBlur: _this._onBlur,\n        onKeyDown: _this._onInputKeyDown,\n        onKeyUp: _this._onInputKeyUp,\n        onClick: _this._onAutofillClick,\n        onTouchStart: _this._onTouchStart,\n        onInputValueChange: _this._onInputChange,\n        \"aria-expanded\": isOpen,\n        \"aria-autocomplete\": _this._getAriaAutoCompleteValue(),\n        role: \"combobox\",\n        readOnly: disabled,\n        \"aria-labelledby\": label && _this._id + '-label',\n        \"aria-label\": ariaLabel && !label ? ariaLabel : undefined,\n        \"aria-describedby\": errorMessage !== undefined ? mergeAriaAttributeValues(ariaDescribedBy, errorMessageId) : ariaDescribedBy,\n        \"aria-activedescendant\": _this._getAriaActiveDescendantValue(),\n        \"aria-required\": required,\n        \"aria-disabled\": disabled,\n        \"aria-owns\": isOpen ? _this._id + '-list' : undefined,\n        spellCheck: false,\n        defaultVisibleValue: _this._currentVisibleValue,\n        suggestedDisplayValue: suggestedDisplayValue,\n        updateValueInWillReceiveProps: _this._onUpdateValueInAutofillWillReceiveProps,\n        shouldSelectFullInputValueInComponentDidUpdate: _this._onShouldSelectFullInputValueInAutofillComponentDidUpdate,\n        title: title,\n        preventValueSelection: !_this._hasFocus(),\n        placeholder: placeholder,\n        tabIndex: tabIndex\n      }, autofill)), React.createElement(IconButton, __assign({\n        className: 'ms-ComboBox-CaretDown-button',\n        styles: _this._getCaretButtonStyles(),\n        role: \"presentation\",\n        \"aria-hidden\": isButtonAriaHidden,\n        \"data-is-focusable\": false,\n        tabIndex: -1,\n        onClick: _this._onComboBoxClick,\n        onBlur: _this._onBlur,\n        iconProps: buttonIconProps,\n        disabled: disabled,\n        checked: isOpen\n      }, iconButtonProps)));\n    };\n    /**\n     * componentDidUpdate handler for the auto fill component\n     *\n     * @param defaultVisibleValue - the current defaultVisibleValue in the auto fill's componentDidUpdate\n     * @param suggestedDisplayValue - the current suggestedDisplayValue in the auto fill's componentDidUpdate\n     * @returns - should the full value of the input be selected?\n     * True if the defaultVisibleValue equals the suggestedDisplayValue, false otherwise\n     */\n\n\n    _this._onShouldSelectFullInputValueInAutofillComponentDidUpdate = function () {\n      return _this._currentVisibleValue === _this.props.hoisted.suggestedDisplayValue;\n    };\n    /**\n     * Get the correct value to pass to the input\n     * to show to the user based off of the current props and state\n     * @returns the value to pass to the input\n     */\n\n\n    _this._getVisibleValue = function () {\n      var _a = _this.props,\n          text = _a.text,\n          allowFreeform = _a.allowFreeform,\n          autoComplete = _a.autoComplete,\n          _b = _a.hoisted,\n          suggestedDisplayValue = _b.suggestedDisplayValue,\n          selectedIndices = _b.selectedIndices,\n          currentOptions = _b.currentOptions;\n      var _c = _this.state,\n          currentPendingValueValidIndex = _c.currentPendingValueValidIndex,\n          currentPendingValue = _c.currentPendingValue,\n          isOpen = _c.isOpen;\n      var currentPendingIndexValid = indexWithinBounds(currentOptions, currentPendingValueValidIndex); // If the user passed is a value prop, use that\n      // unless we are open and have a valid current pending index\n\n      if (!(isOpen && currentPendingIndexValid) && text && (currentPendingValue === null || currentPendingValue === undefined)) {\n        return text;\n      }\n\n      if (_this.props.multiSelect) {\n        // Multi-select\n        if (_this._hasFocus()) {\n          var index = -1;\n\n          if (autoComplete === 'on' && currentPendingIndexValid) {\n            index = currentPendingValueValidIndex;\n          }\n\n          return _this._getPendingString(currentPendingValue, currentOptions, index);\n        } else {\n          return _this._getMultiselectDisplayString(selectedIndices, currentOptions, suggestedDisplayValue);\n        }\n      } else {\n        // Single-select\n        var index = _this._getFirstSelectedIndex();\n\n        if (allowFreeform) {\n          // If we are allowing freeform and autocomplete is also true\n          // and we've got a pending value that matches an option, remember\n          // the matched option's index\n          if (autoComplete === 'on' && currentPendingIndexValid) {\n            index = currentPendingValueValidIndex;\n          } // Since we are allowing freeform, if there is currently a pending value, use that\n          // otherwise use the index determined above (falling back to '' if we did not get a valid index)\n\n\n          return _this._getPendingString(currentPendingValue, currentOptions, index);\n        } else {\n          // If we are not allowing freeform and have a valid index that matches the pending value,\n          // we know we will need some version of the pending value\n          if (currentPendingIndexValid && autoComplete === 'on') {\n            // If autoComplete is on, return the raw pending value, otherwise remember\n            // the matched option's index\n            index = currentPendingValueValidIndex;\n            return normalizeToString(currentPendingValue);\n          } else if (!_this.state.isOpen && currentPendingValue) {\n            return indexWithinBounds(currentOptions, index) ? currentPendingValue : normalizeToString(suggestedDisplayValue);\n          } else {\n            return indexWithinBounds(currentOptions, index) ? getPreviewText(currentOptions[index]) : normalizeToString(suggestedDisplayValue);\n          }\n        }\n      }\n    };\n    /**\n     * Handler for typing changes on the input\n     * @param updatedValue - the newly changed value\n     */\n\n\n    _this._onInputChange = function (updatedValue) {\n      if (_this.props.disabled) {\n        _this._handleInputWhenDisabled(null\n        /* event */\n        );\n\n        return;\n      }\n\n      _this.props.allowFreeform ? _this._processInputChangeWithFreeform(updatedValue) : _this._processInputChangeWithoutFreeform(updatedValue);\n    };\n    /**\n     * Focus (and select) the content of the input\n     * and set the focused state\n     */\n\n\n    _this._onFocus = function () {\n      var _a, _b;\n\n      (_b = (_a = _this._autofill.current) === null || _a === void 0 ? void 0 : _a.inputElement) === null || _b === void 0 ? void 0 : _b.select();\n\n      if (!_this._hasFocus()) {\n        _this.setState({\n          focusState: 'focusing'\n        });\n      }\n    };\n    /**\n     * Callback issued when the options should be resolved, if they have been updated or\n     * if they need to be passed in the first time. This only does work if an onResolveOptions\n     * callback was passed in\n     */\n\n\n    _this._onResolveOptions = function () {\n      if (_this.props.onResolveOptions) {\n        // get the options\n        var newOptions = _this.props.onResolveOptions(__spreadArrays(_this.props.hoisted.currentOptions)); // Check to see if the returned value is an array, if it is update the state\n        // If the returned value is not an array then check to see if it's a promise or PromiseLike.\n        // If it is then resolve it asynchronously.\n\n\n        if (Array.isArray(newOptions)) {\n          _this.props.hoisted.setCurrentOptions(newOptions);\n        } else if (newOptions && newOptions.then) {\n          // Ensure that the promise will only use the callback if it was the most recent one\n          // and update the state when the promise returns\n          var promise_1 = _this._currentPromise = newOptions;\n          promise_1.then(function (newOptionsFromPromise) {\n            if (promise_1 === _this._currentPromise) {\n              _this.props.hoisted.setCurrentOptions(newOptionsFromPromise);\n            }\n          });\n        }\n      }\n    };\n    /**\n     * OnBlur handler. Set the focused state to false\n     * and submit any pending value\n     */\n    // eslint-disable-next-line deprecation/deprecation\n\n\n    _this._onBlur = function (event) {\n      var _a, _b; // Do nothing if the blur is coming from something\n      // inside the comboBox root or the comboBox menu since\n      // it we are not really blurring from the whole comboBox\n\n\n      var relatedTarget = event.relatedTarget;\n\n      if (event.relatedTarget === null) {\n        // In IE11, due to lack of support, event.relatedTarget is always\n        // null making every onBlur call to be \"outside\" of the ComboBox\n        // even when it's not. Using document.activeElement is another way\n        // for us to be able to get what the relatedTarget without relying\n        // on the event\n        relatedTarget = document.activeElement;\n      }\n\n      if (relatedTarget) {\n        var isBlurFromComboBoxTitle = (_a = _this.props.hoisted.rootRef.current) === null || _a === void 0 ? void 0 : _a.contains(relatedTarget);\n        var isBlurFromComboBoxMenu = (_b = _this._comboBoxMenu.current) === null || _b === void 0 ? void 0 : _b.contains(relatedTarget);\n        var isBlurFromComboBoxMenuAncestor = _this._comboBoxMenu.current && findElementRecursive(_this._comboBoxMenu.current, function (element) {\n          return element === relatedTarget;\n        });\n\n        if (isBlurFromComboBoxTitle || isBlurFromComboBoxMenu || isBlurFromComboBoxMenuAncestor) {\n          if (isBlurFromComboBoxMenuAncestor && _this._hasFocus() && (!_this.props.multiSelect || _this.props.allowFreeform)) {\n            _this._submitPendingValue(event);\n          }\n\n          event.preventDefault();\n          event.stopPropagation();\n          return;\n        }\n      }\n\n      if (_this._hasFocus()) {\n        _this.setState({\n          focusState: 'none'\n        });\n\n        if (!_this.props.multiSelect || _this.props.allowFreeform) {\n          _this._submitPendingValue(event);\n        }\n      }\n    }; // Render Callout container and pass in list\n\n\n    _this._onRenderContainer = function (props) {\n      var _a, _b;\n\n      var onRenderList = props.onRenderList,\n          calloutProps = props.calloutProps,\n          dropdownWidth = props.dropdownWidth,\n          dropdownMaxWidth = props.dropdownMaxWidth,\n          _c = props.onRenderUpperContent,\n          onRenderUpperContent = _c === void 0 ? _this._onRenderUpperContent : _c,\n          _d = props.onRenderLowerContent,\n          onRenderLowerContent = _d === void 0 ? _this._onRenderLowerContent : _d,\n          useComboBoxAsMenuWidth = props.useComboBoxAsMenuWidth,\n          persistMenu = props.persistMenu,\n          _e = props.shouldRestoreFocus,\n          shouldRestoreFocus = _e === void 0 ? true : _e;\n      var isOpen = _this.state.isOpen;\n      var id = _this._id;\n      var comboBoxMenuWidth = useComboBoxAsMenuWidth && _this._comboBoxWrapper.current ? _this._comboBoxWrapper.current.clientWidth + 2 : undefined;\n      return React.createElement(Callout, __assign({\n        isBeakVisible: false,\n        gapSpace: 0,\n        doNotLayer: false,\n        directionalHint: DirectionalHint.bottomLeftEdge,\n        directionalHintFixed: false\n      }, calloutProps, {\n        onLayerMounted: _this._onLayerMounted,\n        className: css(_this._classNames.callout, (_a = calloutProps) === null || _a === void 0 ? void 0 : _a.className),\n        target: _this._comboBoxWrapper.current,\n        onDismiss: _this._onDismiss,\n        onMouseDown: _this._onCalloutMouseDown,\n        onScroll: _this._onScroll,\n        setInitialFocus: false,\n        calloutWidth: useComboBoxAsMenuWidth && _this._comboBoxWrapper.current ? comboBoxMenuWidth && comboBoxMenuWidth : dropdownWidth,\n        calloutMaxWidth: dropdownMaxWidth ? dropdownMaxWidth : comboBoxMenuWidth,\n        hidden: persistMenu ? !isOpen : undefined,\n        shouldRestoreFocus: shouldRestoreFocus\n      }), onRenderUpperContent(_this.props, _this._onRenderUpperContent), React.createElement(\"div\", {\n        className: _this._classNames.optionsContainerWrapper,\n        ref: _this._comboBoxMenu\n      }, (_b = onRenderList) === null || _b === void 0 ? void 0 : _b(__assign(__assign({}, props), {\n        id: id\n      }), _this._onRenderList)), onRenderLowerContent(_this.props, _this._onRenderLowerContent));\n    };\n\n    _this._onLayerMounted = function () {\n      _this._onCalloutLayerMounted();\n\n      if (_this.props.calloutProps && _this.props.calloutProps.onLayerMounted) {\n        _this.props.calloutProps.onLayerMounted();\n      }\n    };\n\n    _this._onRenderLabel = function (onRenderLabelProps) {\n      var _a = onRenderLabelProps.props,\n          label = _a.label,\n          disabled = _a.disabled,\n          required = _a.required;\n\n      if (label) {\n        return React.createElement(Label, {\n          id: _this._id + '-label',\n          disabled: disabled,\n          required: required,\n          className: _this._classNames.label\n        }, label, onRenderLabelProps.multiselectAccessibleText && React.createElement(\"span\", {\n          className: _this._classNames.screenReaderText\n        }, onRenderLabelProps.multiselectAccessibleText));\n      }\n\n      return null;\n    }; // Render List of items\n\n\n    _this._onRenderList = function (props) {\n      var onRenderItem = props.onRenderItem,\n          options = props.options;\n      var id = _this._id;\n      return React.createElement(\"div\", {\n        id: id + '-list',\n        className: _this._classNames.optionsContainer,\n        \"aria-labelledby\": id + '-label',\n        role: \"listbox\"\n      }, options.map(function (item) {\n        var _a;\n\n        return (_a = onRenderItem) === null || _a === void 0 ? void 0 : _a(item, _this._onRenderItem);\n      }));\n    }; // Render items\n\n\n    _this._onRenderItem = function (item) {\n      switch (item.itemType) {\n        case SelectableOptionMenuItemType.Divider:\n          return _this._renderSeparator(item);\n\n        case SelectableOptionMenuItemType.Header:\n          return _this._renderHeader(item);\n\n        default:\n          return _this._renderOption(item);\n      }\n    }; // Default _onRenderLowerContent function returns nothing\n\n\n    _this._onRenderLowerContent = function () {\n      return null;\n    }; // Default _onRenderUpperContent function returns nothing\n\n\n    _this._onRenderUpperContent = function () {\n      return null;\n    };\n\n    _this._renderOption = function (item) {\n      var _a = _this.props.onRenderOption,\n          onRenderOption = _a === void 0 ? _this._onRenderOptionContent : _a;\n      var id = _this._id;\n\n      var isSelected = _this._isOptionSelected(item.index);\n\n      var isChecked = _this._isOptionChecked(item.index);\n\n      var optionStyles = _this._getCurrentOptionStyles(item);\n\n      var optionClassNames = getComboBoxOptionClassNames(_this._getCurrentOptionStyles(item));\n      var title = getPreviewText(item);\n\n      var onRenderCheckboxLabel = function () {\n        return onRenderOption(item, _this._onRenderOptionContent);\n      };\n\n      var getOptionComponent = function () {\n        return !_this.props.multiSelect ? React.createElement(CommandButton, {\n          id: id + '-list' + item.index,\n          key: item.key,\n          \"data-index\": item.index,\n          styles: optionStyles,\n          checked: isSelected,\n          className: 'ms-ComboBox-option',\n          onClick: _this._onItemClick(item),\n          // eslint-disable-next-line react/jsx-no-bind\n          onMouseEnter: _this._onOptionMouseEnter.bind(_this, item.index),\n          // eslint-disable-next-line react/jsx-no-bind\n          onMouseMove: _this._onOptionMouseMove.bind(_this, item.index),\n          onMouseLeave: _this._onOptionMouseLeave,\n          role: \"option\",\n          \"aria-selected\": isChecked ? 'true' : 'false',\n          ariaLabel: getPreviewText(item),\n          disabled: item.disabled,\n          title: title\n        }, React.createElement(\"span\", {\n          className: optionClassNames.optionTextWrapper,\n          ref: isSelected ? _this._selectedElement : undefined\n        }, onRenderOption(item, _this._onRenderOptionContent))) : React.createElement(Checkbox, {\n          id: id + '-list' + item.index,\n          ariaLabel: getPreviewText(item),\n          key: item.key,\n          styles: optionStyles,\n          className: 'ms-ComboBox-option',\n          onChange: _this._onItemClick(item),\n          label: item.text,\n          checked: isChecked,\n          title: title,\n          disabled: item.disabled,\n          // eslint-disable-next-line react/jsx-no-bind\n          onRenderLabel: onRenderCheckboxLabel,\n          inputProps: __assign({\n            // aria-selected should only be applied to checked items, not hovered items\n            'aria-selected': isChecked ? 'true' : 'false',\n            role: 'option'\n          }, {\n            'data-index': item.index,\n            'data-is-focusable': true\n          })\n        });\n      };\n\n      return React.createElement(ComboBoxOptionWrapper, {\n        key: item.key,\n        index: item.index,\n        disabled: item.disabled,\n        isSelected: isSelected,\n        isChecked: isChecked,\n        text: item.text,\n        // eslint-disable-next-line react/jsx-no-bind\n        render: getOptionComponent,\n        data: item.data\n      });\n    };\n    /**\n     * Mouse clicks to headers, dividers and scrollbar should not make input lose focus\n     */\n\n\n    _this._onCalloutMouseDown = function (ev) {\n      ev.preventDefault();\n    };\n    /**\n     * Scroll handler for the callout to make sure the mouse events\n     * for updating focus are not interacting during scroll\n     */\n\n\n    _this._onScroll = function () {\n      if (!_this._isScrollIdle && _this._scrollIdleTimeoutId !== undefined) {\n        _this._async.clearTimeout(_this._scrollIdleTimeoutId);\n\n        _this._scrollIdleTimeoutId = undefined;\n      } else {\n        _this._isScrollIdle = false;\n      }\n\n      _this._scrollIdleTimeoutId = _this._async.setTimeout(function () {\n        _this._isScrollIdle = true;\n      }, ScrollIdleDelay);\n    };\n\n    _this._onRenderOptionContent = function (item) {\n      var optionClassNames = getComboBoxOptionClassNames(_this._getCurrentOptionStyles(item));\n      return React.createElement(\"span\", {\n        className: optionClassNames.optionText\n      }, item.text);\n    };\n    /**\n     * Handles dismissing (cancelling) the menu\n     */\n\n\n    _this._onDismiss = function () {\n      var onMenuDismiss = _this.props.onMenuDismiss;\n\n      if (onMenuDismiss) {\n        onMenuDismiss();\n      } // In persistMode we need to simulate callout layer mount\n      // since that only happens once. We do it on dismiss since\n      // it works either way.\n\n\n      if (_this.props.persistMenu) {\n        _this._onCalloutLayerMounted();\n      } // close the menu\n\n\n      _this._setOpenStateAndFocusOnClose(false\n      /* isOpen */\n      , false\n      /* focusInputAfterClose */\n      ); // reset the selected index\n      // to the last value state\n\n\n      _this._resetSelectedIndex();\n    };\n\n    _this._onAfterClearPendingInfo = function () {\n      _this._processingClearPendingInfo = false;\n    };\n    /**\n     * Handle keydown on the input\n     * @param ev - The keyboard event that was fired\n     */\n\n\n    _this._onInputKeyDown = function (ev) {\n      var _a = _this.props,\n          disabled = _a.disabled,\n          allowFreeform = _a.allowFreeform,\n          autoComplete = _a.autoComplete,\n          currentOptions = _a.hoisted.currentOptions;\n      var _b = _this.state,\n          isOpen = _b.isOpen,\n          currentPendingValueValidIndexOnHover = _b.currentPendingValueValidIndexOnHover; // Take note if we are processing an alt (option) or meta (command) keydown.\n      // See comment in _onInputKeyUp for reasoning.\n\n      _this._lastKeyDownWasAltOrMeta = isAltOrMeta(ev);\n\n      if (disabled) {\n        _this._handleInputWhenDisabled(ev);\n\n        return;\n      }\n\n      var index = _this._getPendingSelectedIndex(false\n      /* includeCurrentPendingValue */\n      ); // eslint-disable-next-line deprecation/deprecation\n\n\n      switch (ev.which) {\n        case KeyCodes.enter:\n          if (_this._autofill.current && _this._autofill.current.inputElement) {\n            _this._autofill.current.inputElement.select();\n          }\n\n          _this._submitPendingValue(ev);\n\n          if (_this.props.multiSelect && isOpen) {\n            _this.setState({\n              currentPendingValueValidIndex: index\n            });\n          } else {\n            // On enter submit the pending value\n            if (isOpen || (!allowFreeform || _this.state.currentPendingValue === undefined || _this.state.currentPendingValue === null || _this.state.currentPendingValue.length <= 0) && _this.state.currentPendingValueValidIndex < 0) {\n              // if we are open or\n              // if we are not allowing freeform or\n              // our we have no pending value\n              // and no valid pending index\n              // flip the open state\n              _this.setState({\n                isOpen: !isOpen\n              });\n            }\n          }\n\n          break;\n\n        case KeyCodes.tab:\n          // On enter submit the pending value\n          if (!_this.props.multiSelect) {\n            _this._submitPendingValue(ev);\n          } // If we are not allowing freeform\n          // or the combo box is open, flip the open state\n\n\n          if (isOpen) {\n            _this._setOpenStateAndFocusOnClose(!isOpen, false\n            /* focusInputAfterClose */\n            );\n          } // Allow TAB to propagate\n\n\n          return;\n\n        case KeyCodes.escape:\n          // reset the selected index\n          _this._resetSelectedIndex(); // Close the menu if opened\n\n\n          if (isOpen) {\n            _this.setState({\n              isOpen: false\n            });\n          } else {\n            return;\n          }\n\n          break;\n\n        case KeyCodes.up:\n          // if we are in clearAll state (e.g. the user as hovering\n          // and has since mousedOut of the menu items),\n          // go to the last index\n          if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n            index = _this.props.hoisted.currentOptions.length;\n          }\n\n          if (ev.altKey || ev.metaKey) {\n            // Close the menu if it is open and break so\n            // that the event get stopPropagation and prevent default.\n            // Otherwise, we need to let the event continue to propagate\n            if (isOpen) {\n              _this._setOpenStateAndFocusOnClose(!isOpen, true\n              /* focusInputAfterClose */\n              );\n\n              break;\n            }\n\n            return;\n          } // Go to the previous option\n\n\n          _this._setPendingInfoFromIndexAndDirection(index, SearchDirection.backward);\n\n          break;\n\n        case KeyCodes.down:\n          // Expand the combo box on ALT + DownArrow\n          if (ev.altKey || ev.metaKey) {\n            _this._setOpenStateAndFocusOnClose(true\n            /* isOpen */\n            , true\n            /* focusInputAfterClose */\n            );\n          } else {\n            // if we are in clearAll state (e.g. the user as hovering\n            // and has since mousedOut of the menu items),\n            // go to the first index\n            if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n              index = -1;\n            } // Got to the next option\n\n\n            _this._setPendingInfoFromIndexAndDirection(index, SearchDirection.forward);\n          }\n\n          break;\n\n        case KeyCodes.home:\n        case KeyCodes.end:\n          if (allowFreeform) {\n            return;\n          } // Set the initial values to respond to HOME\n          // which goes to the first selectable option\n\n\n          index = -1;\n          var directionToSearch = SearchDirection.forward; // If end, update the values to respond to END\n          // which goes to the last selectable option\n          // eslint-disable-next-line deprecation/deprecation\n\n          if (ev.which === KeyCodes.end) {\n            index = currentOptions.length;\n            directionToSearch = SearchDirection.backward;\n          }\n\n          _this._setPendingInfoFromIndexAndDirection(index, directionToSearch);\n\n          break;\n\n        /* eslint-disable no-fallthrough */\n\n        case KeyCodes.space:\n          // event handled in _onComboBoxKeyUp\n          if (!allowFreeform && autoComplete === 'off') {\n            break;\n          }\n\n        default:\n          /* eslint-enable no-fallthrough */\n          // are we processing a function key? if so bail out\n          // eslint-disable-next-line deprecation/deprecation\n          if (ev.which >= 112\n          /* F1 */\n          && ev.which <= 123\n          /* F12 */\n          ) {\n              return;\n            } // If we get here and we got either and ALT key\n          // or meta key, let the event propagate\n\n\n          if (ev.keyCode === KeyCodes.alt || ev.key === 'Meta'\n          /* && isOpen */\n          ) {\n              return;\n            } // If we are not allowing freeform and\n          // allowing autoComplete, handle the input here\n          // since we have marked the input as readonly\n\n\n          if (!allowFreeform && autoComplete === 'on') {\n            _this._onInputChange(ev.key);\n\n            break;\n          } // allow the key to propagate by default\n\n\n          return;\n      }\n\n      ev.stopPropagation();\n      ev.preventDefault();\n    };\n    /**\n     * Handle keyup on the input\n     * @param ev - the keyboard event that was fired\n     */\n\n\n    _this._onInputKeyUp = function (ev) {\n      var _a = _this.props,\n          disabled = _a.disabled,\n          allowFreeform = _a.allowFreeform,\n          autoComplete = _a.autoComplete;\n      var isOpen = _this.state.isOpen; // We close the menu on key up only if ALL of the following are true:\n      // - Most recent key down was alt or meta (command)\n      // - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n      //   expand/collapse the menu)\n      // - We're not on a Mac (or iOS)\n      // This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n      // closing any open context menus. There is not a similar behavior on Macs.\n\n      var keyPressIsAltOrMetaAlone = _this._lastKeyDownWasAltOrMeta && isAltOrMeta(ev);\n      _this._lastKeyDownWasAltOrMeta = false;\n      var shouldHandleKey = keyPressIsAltOrMetaAlone && !(isMac() || isIOS());\n\n      if (disabled) {\n        _this._handleInputWhenDisabled(ev);\n\n        return;\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      switch (ev.which) {\n        case KeyCodes.space:\n          // If we are not allowing freeform and are not autoComplete\n          // make space expand/collapse the combo box\n          // and allow the event to propagate\n          if (!allowFreeform && autoComplete === 'off') {\n            _this._setOpenStateAndFocusOnClose(!isOpen, !!isOpen);\n          }\n\n          return;\n\n        default:\n          if (shouldHandleKey && isOpen) {\n            _this._setOpenStateAndFocusOnClose(!isOpen, true\n            /* focusInputAfterClose */\n            );\n          } else {\n            if (_this.state.focusState === 'focusing' && _this.props.openOnKeyboardFocus) {\n              _this.setState({\n                isOpen: true\n              });\n            }\n\n            if (_this.state.focusState !== 'focused') {\n              _this.setState({\n                focusState: 'focused'\n              });\n            }\n          }\n\n          return;\n      }\n    };\n\n    _this._onOptionMouseLeave = function () {\n      if (_this._shouldIgnoreMouseEvent()) {\n        return;\n      } // Ignore the event in persistMenu mode if the callout has\n      // closed. This is to avoid clearing the visuals on item click.\n\n\n      if (_this.props.persistMenu && !_this.state.isOpen) {\n        return;\n      }\n\n      _this.setState({\n        currentPendingValueValidIndexOnHover: HoverStatus.clearAll\n      });\n    };\n    /**\n     * Click handler for the button of the combo box and the input when not allowing freeform.\n     * This toggles the expand/collapse state of the combo box (if enabled).\n     */\n\n\n    _this._onComboBoxClick = function () {\n      var disabled = _this.props.disabled;\n      var isOpen = _this.state.isOpen;\n\n      if (!disabled) {\n        _this._setOpenStateAndFocusOnClose(!isOpen, false\n        /* focusInputAfterClose */\n        );\n\n        _this.setState({\n          focusState: 'focused'\n        });\n      }\n    };\n    /**\n     * Click handler for the autofill.\n     */\n\n\n    _this._onAutofillClick = function () {\n      var _a = _this.props,\n          disabled = _a.disabled,\n          allowFreeform = _a.allowFreeform;\n\n      if (allowFreeform && !disabled) {\n        _this.focus(_this.state.isOpen || _this._processingTouch);\n      } else {\n        _this._onComboBoxClick();\n      }\n    };\n\n    _this._onTouchStart = function () {\n      if (_this._comboBoxWrapper.current && !('onpointerdown' in _this._comboBoxWrapper)) {\n        _this._handleTouchAndPointerEvent();\n      }\n    };\n\n    _this._onPointerDown = function (ev) {\n      if (ev.pointerType === 'touch') {\n        _this._handleTouchAndPointerEvent();\n\n        ev.preventDefault();\n        ev.stopImmediatePropagation();\n      }\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    warnMutuallyExclusive(COMPONENT_NAME, props, {\n      defaultSelectedKey: 'selectedKey',\n      text: 'defaultSelectedKey',\n      selectedKey: 'value',\n      dropdownWidth: 'useComboBoxAsMenuWidth'\n    });\n    _this._id = props.id || getId('ComboBox');\n    _this._isScrollIdle = true;\n    _this._processingTouch = false;\n    _this._gotMouseMove = false;\n    _this._processingClearPendingInfo = false;\n    _this.state = {\n      isOpen: false,\n      focusState: 'none',\n      currentPendingValueValidIndex: -1,\n      currentPendingValue: undefined,\n      currentPendingValueValidIndexOnHover: HoverStatus.default\n    };\n    return _this;\n  }\n\n  Object.defineProperty(ComboBoxInternal.prototype, \"selectedOptions\", {\n    /**\n     * All selected options\n     */\n    get: function () {\n      var _a = this.props.hoisted,\n          currentOptions = _a.currentOptions,\n          selectedIndices = _a.selectedIndices;\n      return getAllSelectedOptions(currentOptions, selectedIndices);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ComboBoxInternal.prototype.componentDidMount = function () {\n    if (this._comboBoxWrapper.current && !this.props.disabled) {\n      // hook up resolving the options if needed on focus\n      this._events.on(this._comboBoxWrapper.current, 'focus', this._onResolveOptions, true);\n\n      if ('onpointerdown' in this._comboBoxWrapper.current) {\n        // For ComboBoxes, touching anywhere in the combo box should drop the dropdown, including the input element.\n        // This gives more hit target space for touch environments. We're setting the onpointerdown here, because React\n        // does not support Pointer events yet.\n        this._events.on(this._comboBoxWrapper.current, 'pointerdown', this._onPointerDown, true);\n      }\n    }\n  };\n\n  ComboBoxInternal.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _this = this;\n\n    var _a = this.props,\n        allowFreeform = _a.allowFreeform,\n        text = _a.text,\n        onMenuOpen = _a.onMenuOpen,\n        onMenuDismissed = _a.onMenuDismissed,\n        selectedIndices = _a.hoisted.selectedIndices;\n    var _b = this.state,\n        isOpen = _b.isOpen,\n        currentPendingValueValidIndex = _b.currentPendingValueValidIndex; // If we are newly open or are open and the pending valid index changed,\n    // make sure the currently selected/pending option is scrolled into view\n\n    if (isOpen && (!prevState.isOpen || prevState.currentPendingValueValidIndex !== currentPendingValueValidIndex)) {\n      // Need this timeout so that the selectedElement ref is correctly updated\n      this._async.setTimeout(function () {\n        return _this._scrollIntoView();\n      }, 0);\n    } // if an action is taken that put focus in the ComboBox\n    // and If we are open or we are just closed, shouldFocusAfterClose is set,\n    // but we are not the activeElement set focus on the input\n\n\n    if (this._hasFocus() && (isOpen || prevState.isOpen && !isOpen && this._focusInputAfterClose && this._autofill.current && document.activeElement !== this._autofill.current.inputElement)) {\n      this.focus(undefined\n      /*shouldOpenOnFocus*/\n      , true\n      /*useFocusAsync*/\n      );\n    } // If we should focusAfterClose AND\n    //   just opened/closed the menu OR\n    //   are focused AND\n    //     updated the selectedIndex with the menu closed OR\n    //     are not allowing freeform OR\n    //     the value changed\n    // we need to set selection\n\n\n    if (this._focusInputAfterClose && (prevState.isOpen && !isOpen || this._hasFocus() && (!isOpen && !this.props.multiSelect && prevProps.hoisted.selectedIndices && selectedIndices && prevProps.hoisted.selectedIndices[0] !== selectedIndices[0] || !allowFreeform || text !== prevProps.text))) {\n      this._onFocus();\n    }\n\n    this._notifyPendingValueChanged(prevState);\n\n    if (isOpen && !prevState.isOpen && onMenuOpen) {\n      onMenuOpen();\n    }\n\n    if (!isOpen && prevState.isOpen && onMenuDismissed) {\n      onMenuDismissed();\n    }\n  };\n\n  ComboBoxInternal.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n\n    this._events.dispose();\n  }; // Primary Render\n\n\n  ComboBoxInternal.prototype.render = function () {\n    var id = this._id;\n    var errorMessageId = id + '-error';\n    var _a = this.props,\n        className = _a.className,\n        disabled = _a.disabled,\n        required = _a.required,\n        errorMessage = _a.errorMessage,\n        _b = _a.onRenderContainer,\n        onRenderContainer = _b === void 0 ? this._onRenderContainer : _b,\n        _c = _a.onRenderLabel,\n        onRenderLabel = _c === void 0 ? this._onRenderLabel : _c,\n        _d = _a.onRenderList,\n        onRenderList = _d === void 0 ? this._onRenderList : _d,\n        _e = _a.onRenderItem,\n        onRenderItem = _e === void 0 ? this._onRenderItem : _e,\n        _f = _a.onRenderOption,\n        onRenderOption = _f === void 0 ? this._onRenderOptionContent : _f,\n        allowFreeform = _a.allowFreeform,\n        customStyles = _a.styles,\n        theme = _a.theme,\n        persistMenu = _a.persistMenu,\n        multiSelect = _a.multiSelect,\n        _g = _a.hoisted,\n        suggestedDisplayValue = _g.suggestedDisplayValue,\n        selectedIndices = _g.selectedIndices,\n        currentOptions = _g.currentOptions;\n    var isOpen = this.state.isOpen;\n    this._currentVisibleValue = this._getVisibleValue(); // Single select is already accessible since the whole text is selected\n    // when focus enters the input. Since multiselect appears to clear the input\n    // it needs special accessible text\n\n    var multiselectAccessibleText = multiSelect ? this._getMultiselectDisplayString(selectedIndices, currentOptions, suggestedDisplayValue) : undefined;\n    var divProps = getNativeProps(this.props, divProperties, ['onChange', 'value']);\n    var hasErrorMessage = errorMessage && errorMessage.length > 0 ? true : false;\n    this._classNames = this.props.getClassNames ? this.props.getClassNames(theme, !!isOpen, !!disabled, !!required, !!this._hasFocus(), !!allowFreeform, !!hasErrorMessage, className) : getClassNames(getStyles(theme, customStyles), className, !!isOpen, !!disabled, !!required, !!this._hasFocus(), !!allowFreeform, !!hasErrorMessage);\n\n    var comboBoxWrapper = this._renderComboBoxWrapper(multiselectAccessibleText, errorMessageId);\n\n    return React.createElement(\"div\", __assign({}, divProps, {\n      ref: this.props.hoisted.mergedRootRef,\n      className: this._classNames.container\n    }), onRenderLabel({\n      props: this.props,\n      multiselectAccessibleText: multiselectAccessibleText\n    }, this._onRenderLabel), comboBoxWrapper, (persistMenu || isOpen) && onRenderContainer(__assign(__assign({}, this.props), {\n      onRenderList: onRenderList,\n      onRenderItem: onRenderItem,\n      onRenderOption: onRenderOption,\n      options: currentOptions.map(function (item, index) {\n        return __assign(__assign({}, item), {\n          index: index\n        });\n      }),\n      onDismiss: this._onDismiss\n    }), this._onRenderContainer), React.createElement(\"div\", __assign({\n      role: \"region\",\n      \"aria-live\": \"polite\",\n      \"aria-atomic\": \"true\",\n      id: errorMessageId\n    }, hasErrorMessage ? {\n      className: this._classNames.errorMessage\n    } : {\n      'aria-hidden': true\n    }), errorMessage !== undefined ? errorMessage : ''));\n  };\n\n  ComboBoxInternal.prototype._getPendingString = function (currentPendingValue, currentOptions, index) {\n    return currentPendingValue !== null && currentPendingValue !== undefined ? currentPendingValue : indexWithinBounds(currentOptions, index) ? currentOptions[index].text : '';\n  };\n  /**\n   * Returns a string that concatenates all of the selected values\n   * for multiselect combo box.\n   */\n\n\n  ComboBoxInternal.prototype._getMultiselectDisplayString = function (selectedIndices, currentOptions, suggestedDisplayValue) {\n    var displayValues = [];\n\n    for (var idx = 0; selectedIndices && idx < selectedIndices.length; idx++) {\n      var index = selectedIndices[idx];\n      displayValues.push(indexWithinBounds(currentOptions, index) ? currentOptions[index].text : normalizeToString(suggestedDisplayValue));\n    }\n\n    var _a = this.props.multiSelectDelimiter,\n        multiSelectDelimiter = _a === void 0 ? ', ' : _a;\n    return displayValues.join(multiSelectDelimiter);\n  };\n  /**\n   * Process the new input's new value when the combo box allows freeform entry\n   * @param updatedValue - the input's newly changed value\n   */\n\n\n  ComboBoxInternal.prototype._processInputChangeWithFreeform = function (updatedValue) {\n    var currentOptions = this.props.hoisted.currentOptions;\n    var newCurrentPendingValueValidIndex = -1; // if the new value is empty, see if we have an exact match and then set the pending info\n\n    if (updatedValue === '') {\n      var items = currentOptions.map(function (item, index) {\n        return __assign(__assign({}, item), {\n          index: index\n        });\n      }).filter(function (option) {\n        return isNormalOption(option) && getPreviewText(option) === updatedValue;\n      }); // if we found a match remember the index\n\n      if (items.length === 1) {\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n\n      this._setPendingInfo(updatedValue, newCurrentPendingValueValidIndex, updatedValue);\n\n      return;\n    } // Remember the original value and then make the value lowercase for comparison\n\n\n    var originalUpdatedValue = updatedValue;\n    updatedValue = updatedValue.toLocaleLowerCase();\n    var newSuggestedDisplayValue = ''; // If autoComplete is on, attempt to find a match from the available options\n\n    if (this.props.autoComplete === 'on') {\n      // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\n      var items = currentOptions.map(function (item, index) {\n        return __assign(__assign({}, item), {\n          index: index\n        });\n      }).filter(function (option) {\n        return isNormalOption(option) && getPreviewText(option).toLocaleLowerCase().indexOf(updatedValue) === 0;\n      });\n\n      if (items.length > 0) {\n        // use ariaLabel as the value when the option is set\n        var text = getPreviewText(items[0]); // If the user typed out the complete option text, we don't need any suggested display text anymore\n\n        newSuggestedDisplayValue = text.toLocaleLowerCase() !== updatedValue ? text : ''; // remember the index of the match we found\n\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n    } else {\n      // If autoComplete is off, attempt to find a match only when the value is exactly equal to the text of an option\n      var items = currentOptions.map(function (item, index) {\n        return __assign(__assign({}, item), {\n          index: index\n        });\n      }).filter(function (option) {\n        return isNormalOption(option) && getPreviewText(option).toLocaleLowerCase() === updatedValue;\n      }); // if we found a match remember the index\n\n      if (items.length === 1) {\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n    } // Set the updated state\n\n\n    this._setPendingInfo(originalUpdatedValue, newCurrentPendingValueValidIndex, newSuggestedDisplayValue);\n  };\n  /**\n   * Process the new input's new value when the combo box does not allow freeform entry\n   * @param updatedValue - the input's newly changed value\n   */\n\n\n  ComboBoxInternal.prototype._processInputChangeWithoutFreeform = function (updatedValue) {\n    var _this = this;\n\n    var currentOptions = this.props.hoisted.currentOptions;\n    var _a = this.state,\n        currentPendingValue = _a.currentPendingValue,\n        currentPendingValueValidIndex = _a.currentPendingValueValidIndex;\n\n    if (this.props.autoComplete === 'on') {\n      // If autoComplete is on while allow freeform is off,\n      // we will remember the key press and build up a string to attempt to match\n      // as long as characters are typed within a the timeout span of each other,\n      // otherwise we will clear the string and start building a new one on the next keypress.\n      // Also, only do this processing if we have a non-empty value\n      if (updatedValue !== '') {\n        // If we have a pending autocomplete clearing task,\n        // we know that the user is typing with key press happening\n        // within the timeout of each other so remove the clearing task\n        // and continue building the pending value with the updated value\n        if (this._autoCompleteTimeout) {\n          this._async.clearTimeout(this._autoCompleteTimeout);\n\n          this._autoCompleteTimeout = undefined;\n          updatedValue = normalizeToString(currentPendingValue) + updatedValue;\n        }\n\n        var originalUpdatedValue = updatedValue;\n        updatedValue = updatedValue.toLocaleLowerCase(); // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\n\n        var items = currentOptions.map(function (item, i) {\n          return __assign(__assign({}, item), {\n            index: i\n          });\n        }).filter(function (option) {\n          return isNormalOption(option) && option.text.toLocaleLowerCase().indexOf(updatedValue) === 0;\n        }); // If we found a match, update the state\n\n        if (items.length > 0) {\n          this._setPendingInfo(originalUpdatedValue, items[0].index, getPreviewText(items[0]));\n        } // Schedule a timeout to clear the pending value after the timeout span\n\n\n        this._autoCompleteTimeout = this._async.setTimeout(function () {\n          _this._autoCompleteTimeout = undefined;\n        }, ReadOnlyPendingAutoCompleteTimeout);\n        return;\n      }\n    } // If we get here, either autoComplete is on or we did not find a match with autoComplete on.\n    // Remember we are not allowing freeform, so at this point, if we have a pending valid value index\n    // use that; otherwise use the selectedIndex\n\n\n    var index = currentPendingValueValidIndex >= 0 ? currentPendingValueValidIndex : this._getFirstSelectedIndex(); // Since we are not allowing freeform, we need to\n    // set both the pending and suggested values/index\n    // to allow us to select all content in the input to\n    // give the illusion that we are readonly (e.g. freeform off)\n\n    this._setPendingInfoFromIndex(index);\n  };\n\n  ComboBoxInternal.prototype._getFirstSelectedIndex = function () {\n    var _a;\n\n    var selectedIndices = this.props.hoisted.selectedIndices;\n    return ((_a = selectedIndices) === null || _a === void 0 ? void 0 : _a.length) ? selectedIndices[0] : -1;\n  };\n  /**\n   * Walk along the options starting at the index, stepping by the delta (positive or negative)\n   * looking for the next valid selectable index (e.g. skipping headings and dividers)\n   * @param index - the index to get the next selectable index from\n   * @param delta - optional delta to step by when finding the next index, defaults to 0\n   * @returns - the next valid selectable index. If the new index is outside of the bounds,\n   * it will snap to the edge of the options array. If delta == 0 and the given index is not selectable\n   */\n\n\n  ComboBoxInternal.prototype._getNextSelectableIndex = function (index, searchDirection) {\n    var currentOptions = this.props.hoisted.currentOptions;\n    var newIndex = index + searchDirection;\n    newIndex = Math.max(0, Math.min(currentOptions.length - 1, newIndex));\n\n    if (!indexWithinBounds(currentOptions, newIndex)) {\n      return -1;\n    }\n\n    var option = currentOptions[newIndex];\n\n    if (!isNormalOption(option) || option.hidden === true) {\n      // Should we continue looking for an index to select?\n      if (searchDirection !== SearchDirection.none && (newIndex > 0 && searchDirection < SearchDirection.none || newIndex >= 0 && newIndex < currentOptions.length && searchDirection > SearchDirection.none)) {\n        newIndex = this._getNextSelectableIndex(newIndex, searchDirection);\n      } else {\n        // If we cannot perform a useful search just return the index we were given\n        return index;\n      }\n    } // We have the next valid selectable index, return it\n\n\n    return newIndex;\n  };\n  /**\n   * Set the selected index. Note, this is\n   * the \"real\" selected index, not the pending selected index\n   * @param index - the index to set (or the index to set from if a search direction is provided)\n   * @param searchDirection - the direction to search along the options from the given index\n   */\n\n\n  ComboBoxInternal.prototype._setSelectedIndex = function (index, submitPendingValueEvent, searchDirection) {\n    if (searchDirection === void 0) {\n      searchDirection = SearchDirection.none;\n    }\n\n    var _a = this.props,\n        onChange = _a.onChange,\n        onPendingValueChanged = _a.onPendingValueChanged,\n        _b = _a.hoisted,\n        initialIndices = _b.selectedIndices,\n        currentOptions = _b.currentOptions; // Clone selectedIndices so we don't mutate state\n\n    var selectedIndices = initialIndices ? initialIndices.slice() : []; // Find the next selectable index, if searchDirection is none\n    // we will get our starting index back\n\n    index = this._getNextSelectableIndex(index, searchDirection);\n\n    if (!indexWithinBounds(currentOptions, index)) {\n      return;\n    } // Are we at a new index? If so, update the state, otherwise\n    // there is nothing to do\n\n\n    if (this.props.multiSelect || selectedIndices.length < 1 || selectedIndices.length === 1 && selectedIndices[0] !== index) {\n      var option = __assign({}, currentOptions[index]); // if option doesn't existing, or option is disabled, we noop\n\n\n      if (!option || option.disabled) {\n        return;\n      }\n\n      if (this.props.multiSelect) {\n        // Setting the initial state of option.selected in Multi-select combo box by checking the\n        // selectedIndices array and overriding the undefined issue\n        option.selected = option.selected !== undefined ? !option.selected : selectedIndices.indexOf(index) < 0;\n\n        if (option.selected && selectedIndices.indexOf(index) < 0) {\n          selectedIndices.push(index);\n        } else if (!option.selected && selectedIndices.indexOf(index) >= 0) {\n          selectedIndices = selectedIndices.filter(function (value) {\n            return value !== index;\n          });\n        }\n      } else {\n        selectedIndices[0] = index;\n      }\n\n      submitPendingValueEvent.persist(); // Only setState if combo box is uncontrolled.\n\n      if (this.props.selectedKey || this.props.selectedKey === null) {\n        // If combo box value is changed, revert preview first\n        if (this._hasPendingValue && onPendingValueChanged) {\n          onPendingValueChanged();\n          this._hasPendingValue = false;\n        }\n\n        if (onChange) {\n          onChange(submitPendingValueEvent, option, index, undefined);\n        }\n      } else {\n        // Update current options\n        var changedOptions = currentOptions.slice();\n        changedOptions[index] = option; // Call onChange after state is updated\n\n        this.props.hoisted.setSelectedIndices(selectedIndices);\n        this.props.hoisted.setCurrentOptions(changedOptions); // If ComboBox value is changed, revert preview first\n\n        if (this._hasPendingValue && onPendingValueChanged) {\n          onPendingValueChanged();\n          this._hasPendingValue = false;\n        }\n\n        if (onChange) {\n          onChange(submitPendingValueEvent, option, index, undefined);\n        }\n      }\n    }\n\n    if (this.props.multiSelect && this.state.isOpen) {\n      return;\n    } // clear all of the pending info\n\n\n    this._clearPendingInfo();\n  };\n  /**\n   * Submit a pending value if there is one\n   */\n\n\n  ComboBoxInternal.prototype._submitPendingValue = function (submitPendingValueEvent) {\n    var _a, _b, _c;\n\n    var _d = this.props,\n        onChange = _d.onChange,\n        allowFreeform = _d.allowFreeform,\n        autoComplete = _d.autoComplete,\n        multiSelect = _d.multiSelect,\n        hoisted = _d.hoisted;\n    var currentOptions = hoisted.currentOptions;\n    var _e = this.state,\n        currentPendingValue = _e.currentPendingValue,\n        currentPendingValueValidIndex = _e.currentPendingValueValidIndex,\n        currentPendingValueValidIndexOnHover = _e.currentPendingValueValidIndexOnHover;\n    var selectedIndices = this.props.hoisted.selectedIndices; // Do not submit any pending value if we\n    // have already initiated clearing the pending info\n\n    if (this._processingClearPendingInfo) {\n      return;\n    } // If we allow freeform we need to handle that\n\n\n    if (allowFreeform) {\n      // if currentPendingValue is null or undefined the user did not submit anything\n      // (not even empty because we would have stored that as the pending value)\n      if (currentPendingValue === null || currentPendingValue === undefined) {\n        // if a user did not type anything they may just hovered over an item\n        if (currentPendingValueValidIndexOnHover >= 0) {\n          this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\n\n          this._clearPendingInfo();\n        }\n\n        return;\n      } // Check to see if the user typed an exact match\n\n\n      if (indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {\n        var pendingOptionText = getPreviewText(currentOptions[currentPendingValueValidIndex]).toLocaleLowerCase();\n        var autofill = this._autofill.current; // By exact match, that means: our pending value is the same as the pending option text OR\n        // the pending option starts with the pending value and we have an \"autoComplete\" selection\n        // where the total length is equal to pending option length OR\n        // the live value in the underlying input matches the pending option; update the state\n\n        if (currentPendingValue.toLocaleLowerCase() === pendingOptionText || autoComplete && pendingOptionText.indexOf(currentPendingValue.toLocaleLowerCase()) === 0 && ((_a = autofill) === null || _a === void 0 ? void 0 : _a.isValueSelected) && currentPendingValue.length + (autofill.selectionEnd - autofill.selectionStart) === pendingOptionText.length || ((_c = (_b = autofill) === null || _b === void 0 ? void 0 : _b.inputElement) === null || _c === void 0 ? void 0 : _c.value.toLocaleLowerCase()) === pendingOptionText) {\n          this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\n\n          if (multiSelect && this.state.isOpen) {\n            return;\n          }\n\n          this._clearPendingInfo();\n\n          return;\n        }\n      }\n\n      if (onChange) {\n        if (onChange) {\n          // trigger onChange to clear value\n          onChange(submitPendingValueEvent, undefined, undefined, currentPendingValue);\n        }\n      } else {\n        // If we are not controlled, create a new selected option\n        var newOption = {\n          key: currentPendingValue || getId(),\n          text: normalizeToString(currentPendingValue)\n        }; // If it's multiselect, set selected state to true\n\n        if (multiSelect) {\n          newOption.selected = true;\n        }\n\n        var newOptions = currentOptions.concat([newOption]);\n\n        if (selectedIndices) {\n          if (!multiSelect) {\n            selectedIndices = [];\n          }\n\n          selectedIndices.push(newOptions.length - 1);\n        }\n\n        hoisted.setCurrentOptions(newOptions);\n        hoisted.setSelectedIndices(selectedIndices);\n      }\n    } else if (currentPendingValueValidIndex >= 0) {\n      // Since we are not allowing freeform, we must have a matching\n      // to be able to update state\n      this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\n    } else if (currentPendingValueValidIndexOnHover >= 0) {\n      // If all else failed and we were hovering over an item, select it\n      this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\n    } // Finally, clear the pending info\n\n\n    this._clearPendingInfo();\n  };\n\n  ComboBoxInternal.prototype._onCalloutLayerMounted = function () {\n    // In persistMenu mode _onLayerMounted is only called once for the lifetime\n    // of the component. Any functionality required for callout \"on mount\" can\n    // go here so that we can also call it again during callout dismissal to reset\n    // object state.\n    this._gotMouseMove = false;\n  }; // Render separator\n\n\n  ComboBoxInternal.prototype._renderSeparator = function (item) {\n    var index = item.index,\n        key = item.key;\n\n    if (index && index > 0) {\n      return React.createElement(\"div\", {\n        role: \"separator\",\n        key: key,\n        className: this._classNames.divider\n      });\n    }\n\n    return null;\n  };\n\n  ComboBoxInternal.prototype._renderHeader = function (item) {\n    var _a = this.props.onRenderOption,\n        onRenderOption = _a === void 0 ? this._onRenderOptionContent : _a;\n    return React.createElement(\"div\", {\n      key: item.key,\n      className: this._classNames.header\n    }, onRenderOption(item, this._onRenderOptionContent));\n  };\n  /**\n   * If we are coming from a mouseOut:\n   * there is no visible selected option.\n   *\n   * Else if We are hovering over an item:\n   * that gets the selected look.\n   *\n   * Else:\n   * Use the current valid pending index if it exists OR\n   * we do not have a valid index and we currently have a pending input value,\n   * otherwise use the selected index\n   * */\n\n\n  ComboBoxInternal.prototype._isOptionSelected = function (index) {\n    var currentPendingValueValidIndexOnHover = this.state.currentPendingValueValidIndexOnHover; // If the hover state is set to clearAll, don't show a selected index.\n    // Note, this happens when the user moused out of the menu items\n\n    if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n      return false;\n    }\n\n    return this._getPendingSelectedIndex(true\n    /* includePendingValue */\n    ) === index ? true : false;\n  };\n\n  ComboBoxInternal.prototype._isOptionChecked = function (index) {\n    if (this.props.multiSelect && index !== undefined && this.props.hoisted.selectedIndices) {\n      var idxOfSelectedIndex = -1;\n      idxOfSelectedIndex = this.props.hoisted.selectedIndices.indexOf(index);\n      return idxOfSelectedIndex >= 0;\n    }\n\n    return false;\n  };\n  /**\n   * Gets the pending selected index taking into account hover, valueValidIndex, and selectedIndex\n   * @param includeCurrentPendingValue - Should we include the currentPendingValue when\n   * finding the index\n   */\n\n\n  ComboBoxInternal.prototype._getPendingSelectedIndex = function (includeCurrentPendingValue) {\n    var _a = this.state,\n        currentPendingValueValidIndexOnHover = _a.currentPendingValueValidIndexOnHover,\n        currentPendingValueValidIndex = _a.currentPendingValueValidIndex,\n        currentPendingValue = _a.currentPendingValue;\n    return currentPendingValueValidIndexOnHover >= 0 ? currentPendingValueValidIndexOnHover : currentPendingValueValidIndex >= 0 || includeCurrentPendingValue && currentPendingValue !== null && currentPendingValue !== undefined ? currentPendingValueValidIndex : this.props.multiSelect ? 0 : this._getFirstSelectedIndex();\n  };\n  /**\n   * Scroll the selected element into view\n   */\n\n\n  ComboBoxInternal.prototype._scrollIntoView = function () {\n    var _a = this.props,\n        onScrollToItem = _a.onScrollToItem,\n        scrollSelectedToTop = _a.scrollSelectedToTop;\n    var _b = this.state,\n        currentPendingValueValidIndex = _b.currentPendingValueValidIndex,\n        currentPendingValue = _b.currentPendingValue;\n\n    if (onScrollToItem) {\n      // Use the custom scroll handler\n      onScrollToItem(currentPendingValueValidIndex >= 0 || currentPendingValue !== '' ? currentPendingValueValidIndex : this._getFirstSelectedIndex());\n    } else if (this._selectedElement.current && this._selectedElement.current.offsetParent) {\n      // We are using refs, scroll the ref into view\n      if (scrollSelectedToTop) {\n        this._selectedElement.current.offsetParent.scrollIntoView(true);\n      } else {\n        var alignToTop = true;\n\n        if (this._comboBoxMenu.current && this._comboBoxMenu.current.offsetParent) {\n          var scrollableParentRect = this._comboBoxMenu.current.offsetParent.getBoundingClientRect();\n\n          var selectedElementRect = this._selectedElement.current.offsetParent.getBoundingClientRect(); // If we are completely in view then we do not need to scroll\n\n\n          if (scrollableParentRect.top <= selectedElementRect.top && scrollableParentRect.top + scrollableParentRect.height >= selectedElementRect.top + selectedElementRect.height) {\n            return;\n          } // If we are lower than the scrollable parent viewport then we should align to the bottom\n\n\n          if (scrollableParentRect.top + scrollableParentRect.height <= selectedElementRect.top + selectedElementRect.height) {\n            alignToTop = false;\n          }\n        }\n\n        this._selectedElement.current.offsetParent.scrollIntoView(alignToTop);\n      }\n    }\n  };\n  /**\n   * Click handler for the menu items\n   * to select the item and also close the menu\n   * @param index - the index of the item that was clicked\n   */\n\n\n  ComboBoxInternal.prototype._onItemClick = function (item) {\n    var _this = this;\n\n    var onItemClick = this.props.onItemClick;\n    var index = item.index;\n    return function (ev) {\n      // only close the callout when it's in single-select mode\n      if (!_this.props.multiSelect) {\n        // ensure that focus returns to the input, not the button\n        _this._autofill.current && _this._autofill.current.focus();\n\n        _this.setState({\n          isOpen: false\n        });\n      } // Continue processing the click only after\n      // performing menu close / control focus(inner working)\n\n\n      onItemClick && onItemClick(ev, item, index);\n\n      _this._setSelectedIndex(index, ev);\n    };\n  };\n  /**\n   * Reset the selected index by clearing the\n   * input (of any pending text), clearing the pending state,\n   * and setting the suggested display value to the last\n   * selected state text\n   */\n\n\n  ComboBoxInternal.prototype._resetSelectedIndex = function () {\n    var currentOptions = this.props.hoisted.currentOptions;\n\n    this._clearPendingInfo();\n\n    var selectedIndex = this._getFirstSelectedIndex();\n\n    if (selectedIndex > 0 && selectedIndex < currentOptions.length) {\n      this.props.hoisted.setSuggestedDisplayValue(currentOptions[selectedIndex].text);\n    } else if (this.props.text) {\n      // If we had a value initially, restore it\n      this.props.hoisted.setSuggestedDisplayValue(this.props.text);\n    }\n  };\n  /**\n   * Clears the pending info state\n   */\n\n\n  ComboBoxInternal.prototype._clearPendingInfo = function () {\n    this._processingClearPendingInfo = true;\n    this.props.hoisted.setSuggestedDisplayValue(undefined);\n    this.setState({\n      currentPendingValue: undefined,\n      currentPendingValueValidIndex: -1,\n      currentPendingValueValidIndexOnHover: HoverStatus.default\n    }, this._onAfterClearPendingInfo);\n  };\n  /**\n   * Set the pending info\n   * @param currentPendingValue - new pending value to set\n   * @param currentPendingValueValidIndex - new pending value index to set\n   * @param suggestedDisplayValue - new suggest display value to set\n   */\n\n\n  ComboBoxInternal.prototype._setPendingInfo = function (currentPendingValue, currentPendingValueValidIndex, suggestedDisplayValue) {\n    if (currentPendingValueValidIndex === void 0) {\n      currentPendingValueValidIndex = -1;\n    }\n\n    if (this._processingClearPendingInfo) {\n      return;\n    }\n\n    this.props.hoisted.setSuggestedDisplayValue(suggestedDisplayValue);\n    this.setState({\n      currentPendingValue: normalizeToString(currentPendingValue),\n      currentPendingValueValidIndex: currentPendingValueValidIndex,\n      currentPendingValueValidIndexOnHover: HoverStatus.default\n    });\n  };\n  /**\n   * Set the pending info from the given index\n   * @param index - the index to set the pending info from\n   */\n\n\n  ComboBoxInternal.prototype._setPendingInfoFromIndex = function (index) {\n    var currentOptions = this.props.hoisted.currentOptions;\n\n    if (index >= 0 && index < currentOptions.length) {\n      var option = currentOptions[index];\n\n      this._setPendingInfo(getPreviewText(option), index, getPreviewText(option));\n    } else {\n      this._clearPendingInfo();\n    }\n  };\n  /**\n   * Sets the pending info for the combo box\n   * @param index - the index to search from\n   * @param searchDirection - the direction to search\n   */\n\n\n  ComboBoxInternal.prototype._setPendingInfoFromIndexAndDirection = function (index, searchDirection) {\n    var currentOptions = this.props.hoisted.currentOptions; // update index to allow content to wrap\n\n    if (searchDirection === SearchDirection.forward && index >= currentOptions.length - 1) {\n      index = -1;\n    } else if (searchDirection === SearchDirection.backward && index <= 0) {\n      index = currentOptions.length;\n    } // get the next \"valid\" index\n\n\n    var indexUpdate = this._getNextSelectableIndex(index, searchDirection); // if the two indices are equal we didn't move and\n    // we should attempt to get  get the first/last \"valid\" index to use\n    // (Note, this takes care of the potential cases where the first/last\n    // item is not focusable), otherwise use the updated index\n\n\n    if (index === indexUpdate) {\n      if (searchDirection === SearchDirection.forward) {\n        index = this._getNextSelectableIndex(-1, searchDirection);\n      } else if (searchDirection === SearchDirection.backward) {\n        index = this._getNextSelectableIndex(currentOptions.length, searchDirection);\n      }\n    } else {\n      index = indexUpdate;\n    }\n\n    if (indexWithinBounds(currentOptions, index)) {\n      this._setPendingInfoFromIndex(index);\n    }\n  };\n\n  ComboBoxInternal.prototype._notifyPendingValueChanged = function (prevState) {\n    var onPendingValueChanged = this.props.onPendingValueChanged;\n\n    if (!onPendingValueChanged) {\n      return;\n    }\n\n    var currentOptions = this.props.hoisted.currentOptions;\n    var _a = this.state,\n        currentPendingValue = _a.currentPendingValue,\n        currentPendingValueValidIndex = _a.currentPendingValueValidIndex,\n        currentPendingValueValidIndexOnHover = _a.currentPendingValueValidIndexOnHover;\n    var newPendingIndex = undefined;\n    var newPendingValue = undefined;\n\n    if (currentPendingValueValidIndexOnHover !== prevState.currentPendingValueValidIndexOnHover && indexWithinBounds(currentOptions, currentPendingValueValidIndexOnHover)) {\n      // Set new pending index if hover index was changed\n      newPendingIndex = currentPendingValueValidIndexOnHover;\n    } else if (currentPendingValueValidIndex !== prevState.currentPendingValueValidIndex && indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {\n      // Set new pending index if currentPendingValueValidIndex was changed\n      newPendingIndex = currentPendingValueValidIndex;\n    } else if (currentPendingValue !== prevState.currentPendingValue) {\n      // Set pendingValue in the case it was changed and no index was changed\n      newPendingValue = currentPendingValue;\n    } // Notify when there is a new pending index/value. Also, if there is a pending value, it needs to send undefined.\n\n\n    if (newPendingIndex !== undefined || newPendingValue !== undefined || this._hasPendingValue) {\n      onPendingValueChanged(newPendingIndex !== undefined ? currentOptions[newPendingIndex] : undefined, newPendingIndex, newPendingValue);\n      this._hasPendingValue = newPendingIndex !== undefined || newPendingValue !== undefined;\n    }\n  };\n  /**\n   * Sets the isOpen state and updates focusInputAfterClose\n   */\n\n\n  ComboBoxInternal.prototype._setOpenStateAndFocusOnClose = function (isOpen, focusInputAfterClose) {\n    this._focusInputAfterClose = focusInputAfterClose;\n    this.setState({\n      isOpen: isOpen\n    });\n  };\n\n  ComboBoxInternal.prototype._onOptionMouseEnter = function (index) {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValueValidIndexOnHover: index\n    });\n  };\n\n  ComboBoxInternal.prototype._onOptionMouseMove = function (index) {\n    this._gotMouseMove = true;\n\n    if (!this._isScrollIdle || this.state.currentPendingValueValidIndexOnHover === index) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValueValidIndexOnHover: index\n    });\n  };\n\n  ComboBoxInternal.prototype._shouldIgnoreMouseEvent = function () {\n    return !this._isScrollIdle || !this._gotMouseMove;\n  };\n  /**\n   * Handle dismissing the menu and eating the required key event when disabled\n   * @param ev - the keyboard event that was fired\n   */\n\n\n  ComboBoxInternal.prototype._handleInputWhenDisabled = function (ev) {\n    // If we are disabled, close the menu (if needed)\n    // and eat all keystrokes other than TAB or ESC\n    if (this.props.disabled) {\n      if (this.state.isOpen) {\n        this.setState({\n          isOpen: false\n        });\n      } // When disabled stop propagation and prevent default\n      // of the event unless we have a tab, escape, or function key\n\n\n      if (ev !== null && // eslint-disable-next-line deprecation/deprecation\n      ev.which !== KeyCodes.tab && // eslint-disable-next-line deprecation/deprecation\n      ev.which !== KeyCodes.escape && ( // eslint-disable-next-line deprecation/deprecation\n      ev.which < 112\n      /* F1 */\n      || ev.which > 123)\n      /* F12 */\n      ) {\n          ev.stopPropagation();\n          ev.preventDefault();\n        }\n    }\n  };\n\n  ComboBoxInternal.prototype._handleTouchAndPointerEvent = function () {\n    var _this = this; // If we already have an existing timeout from a previous touch and pointer event\n    // cancel that timeout so we can set a nwe one.\n\n\n    if (this._lastTouchTimeoutId !== undefined) {\n      this._async.clearTimeout(this._lastTouchTimeoutId);\n\n      this._lastTouchTimeoutId = undefined;\n    }\n\n    this._processingTouch = true;\n    this._lastTouchTimeoutId = this._async.setTimeout(function () {\n      _this._processingTouch = false;\n      _this._lastTouchTimeoutId = undefined;\n    }, TouchIdleDelay);\n  };\n  /**\n   * Get the styles for the current option.\n   * @param item - Item props for the current option\n   */\n\n\n  ComboBoxInternal.prototype._getCaretButtonStyles = function () {\n    var customCaretDownButtonStyles = this.props.caretDownButtonStyles;\n    return getCaretDownButtonStyles(this.props.theme, customCaretDownButtonStyles);\n  };\n  /**\n   * Get the styles for the current option.\n   * @param item - Item props for the current option\n   */\n\n\n  ComboBoxInternal.prototype._getCurrentOptionStyles = function (item) {\n    var customStylesForAllOptions = this.props.comboBoxOptionStyles;\n    var customStylesForCurrentOption = item.styles;\n    return getOptionStyles(this.props.theme, customStylesForAllOptions, customStylesForCurrentOption, this._isPendingOption(item), item.hidden);\n  };\n  /**\n   * Get the aria-activedescendant value for the combo box.\n   * @returns the id of the current focused combo item, otherwise the id of the currently selected element,\n   * null otherwise\n   */\n\n\n  ComboBoxInternal.prototype._getAriaActiveDescendantValue = function () {\n    var _a;\n\n    var selectedIndices = this.props.hoisted.selectedIndices;\n    var _b = this.state,\n        isOpen = _b.isOpen,\n        currentPendingValueValidIndex = _b.currentPendingValueValidIndex;\n    var descendantText = isOpen && ((_a = selectedIndices) === null || _a === void 0 ? void 0 : _a.length) ? this._id + '-list' + selectedIndices[0] : undefined;\n\n    if (isOpen && this._hasFocus() && currentPendingValueValidIndex !== -1) {\n      descendantText = this._id + '-list' + currentPendingValueValidIndex;\n    }\n\n    return descendantText;\n  };\n  /**\n   * Get the aria autocomplete value for the combo box\n   * @returns 'inline' if auto-complete automatically dynamic, 'both' if we have a list of possible values to pick from\n   * and can dynamically populate input, and 'none' if auto-complete is not enabled as we can't give user inputs.\n   */\n\n\n  ComboBoxInternal.prototype._getAriaAutoCompleteValue = function () {\n    var autoComplete = !this.props.disabled && this.props.autoComplete === 'on';\n    return autoComplete ? this.props.allowFreeform ? 'inline' : 'both' : 'none';\n  };\n\n  ComboBoxInternal.prototype._isPendingOption = function (item) {\n    return item && item.index === this.state.currentPendingValueValidIndex;\n  };\n  /**\n   * Returns true if the component has some kind of focus. If it's either focusing or if it's focused\n   */\n\n\n  ComboBoxInternal.prototype._hasFocus = function () {\n    return this.state.focusState !== 'none';\n  };\n\n  ComboBoxInternal = __decorate([customizable('ComboBox', ['theme', 'styles'], true)], ComboBoxInternal);\n  return ComboBoxInternal;\n}(React.Component);\n/**\n * Get the indices of the options that are marked as selected\n * @param options - the combo box options\n * @param selectedKeys - the known selected keys to find\n * @returns - an array of the indices of the selected options, empty array if nothing is selected\n */\n\n\nfunction getSelectedIndices(options, selectedKeys) {\n  if (!options || !selectedKeys) {\n    return [];\n  }\n\n  var selectedIndices = {};\n  options.forEach(function (option, index) {\n    if (option.selected) {\n      selectedIndices[index] = true;\n    }\n  });\n\n  var _loop_1 = function (selectedKey) {\n    var index = findIndex(options, function (option) {\n      return option.key === selectedKey;\n    });\n\n    if (index > -1) {\n      selectedIndices[index] = true;\n    }\n  };\n\n  for (var _i = 0, selectedKeys_1 = selectedKeys; _i < selectedKeys_1.length; _i++) {\n    var selectedKey = selectedKeys_1[_i];\n\n    _loop_1(selectedKey);\n  }\n\n  return Object.keys(selectedIndices).map(Number).sort();\n}\n/**\n * Given default selected key(s) and selected key(s), return the selected keys(s).\n * When default selected key(s) are available, they take precedence and return them instead of selected key(s).\n *\n * @returns No matter what specific types the input parameters are, always return an array of\n *  either strings or numbers instead of primitive type.  This normalization makes caller's logic easier.\n */\n\n\nfunction buildDefaultSelectedKeys(defaultSelectedKey, selectedKey) {\n  var selectedKeys = buildSelectedKeys(defaultSelectedKey);\n\n  if (selectedKeys.length) {\n    return selectedKeys;\n  }\n\n  return buildSelectedKeys(selectedKey);\n}\n\nfunction buildSelectedKeys(selectedKey) {\n  if (selectedKey === undefined) {\n    return [];\n  } // need to cast here so typescript does not complain\n\n\n  return selectedKey instanceof Array ? selectedKey : [selectedKey];\n}\n\nfunction normalizeToString(value) {\n  return value || '';\n}\n/**\n * Is the index within the bounds of the array?\n * @param options - options to check if the index is valid for\n * @param index - the index to check\n * @returns - true if the index is valid for the given options, false otherwise\n */\n\n\nfunction indexWithinBounds(options, index) {\n  return !!options && index >= 0 && index < options.length;\n}\n/** Whether this is a normal option, not a header or divider. */\n\n\nfunction isNormalOption(option) {\n  return option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider;\n}\n/**\n * For scenarios where the option's `text` prop contains embedded styles, we use the option's\n * `ariaLabel` value as the text in the input and for autocomplete matching. We know to use this\n * when the `useAriaLabelAsText` prop is set to true.\n */\n\n\nfunction getPreviewText(item) {\n  return item.useAriaLabelAsText && item.ariaLabel ? item.ariaLabel : item.text;\n}\n/**\n * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n */\n\n\nfunction isAltOrMeta(ev) {\n  // eslint-disable-next-line deprecation/deprecation\n  return ev.which === KeyCodes.alt || ev.key === 'Meta';\n}","map":{"version":3,"sources":["components/ComboBox/ComboBox.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AACA,SAAS,QAAT,QAAoC,gBAApC;AACA,SACE,sBADF,EAEE,GAFF,EAGE,YAHF,EAIE,aAJF,EAKE,oBALF,EAME,SANF,EAOE,UAPF,EAQE,KARF,EASE,cATF,EAUE,KAVF,EAWE,KAXF,EAYE,QAZF,EAaE,cAbF,EAcE,wBAdF,EAeE,qBAfF,EAgBE,KAhBF,EAiBE,UAjBF,EAkBE,oBAlBF,QAmBO,iBAnBP;AAoBA,SAAS,OAAT,EAAkB,eAAlB,QAAyC,eAAzC;AACA,SAAS,QAAT,QAAyB,gBAAzB;AACA,SAAS,wBAAT,EAAmC,eAAnC,EAAoD,SAApD,QAAqE,mBAArE;AACA,SAAS,aAAT,EAAwB,2BAAxB,QAAgF,uBAAhF;AAQA,SAAS,KAAT,QAAsB,aAAtB;AACA,SAAS,4BAAT,EAAuC,qBAAvC,QAAoE,wBAApE;AACA,SAA6B,aAA7B,EAA2D,UAA3D,QAA6E,cAA7E;AAEA,SAAS,aAAT,QAA8B,uBAA9B;AAyBA,IAAK,eAAL;;AAAA,CAAA,UAAK,eAAL,EAAoB;AAClB,EAAA,eAAA,CAAA,eAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,CAAA,GAAA,UAAA;AACA,EAAA,eAAA,CAAA,eAAA,CAAA,MAAA,CAAA,GAAA,CAAA,CAAA,GAAA,MAAA;AACA,EAAA,eAAA,CAAA,eAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACD,CAJD,EAAK,eAAe,KAAf,eAAe,GAAA,EAAA,CAApB;;AAMA,IAAK,WAAL;;AAAA,CAAA,UAAK,WAAL,EAAgB;AACd;AACA,EAAA,WAAA,CAAA,WAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,CAAA,GAAA,UAAA;AACA;;AACA,EAAA,WAAA,CAAA,WAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,CAAA,GAAA,SAAA;AACD,CALD,EAAK,WAAW,KAAX,WAAW,GAAA,EAAA,CAAhB;;AAOA,IAAM,eAAe,GAAG,GAAxB;AAA6B;;AAC7B,IAAM,cAAc,GAAG,GAAvB;AAA4B;;AAE5B;;;AAGG;;AACH,IAAM,kCAAkC,GAAG,IAA3C;AAAiD;;AAiBjD;;;;AAIG;;AACH,IAAM,qBAAqB,GAAG,KAAK,CAAC,IAAN,CAC5B,UAAC,EAAD,EAAwC;MAArC,MAAA,GAAA,EAAA,CAAA,M;AAA0C,SAAA,MAAM,EAAN;AAAQ,CADzB,EAE5B,UACE,EADF,EAEE,EAFF,EAEiE;AAD7D,MAAA,SAAA,GAAA,EAAA,CAAA,MAAA;AAAA,MAAmB,QAAA,GAAA,MAAA,CAAA,EAAA,EAAA,CAAA,QAAA,CAAA,CAAnB;;AACA,MAAA,SAAA,GAAA,EAAA,CAAA,MAAA;AAAA,MAAmB,QAAA,GAAA,MAAA,CAAA,EAAA,EAAA,CAAA,QAAA,CAAA,CAAnB,CAA6D,CAE/D;;;AACA,SAAA,cAAc,CAAC,QAAD,EAAW,QAAX,CAAd;AAAkC,CAPR,CAA9B;AAUA,IAAM,cAAc,GAAG,UAAvB;AACA,IAAM,aAAa,GAA4B;AAC7C,EAAA,OAAO,EAAE,EADoC;AAE7C,EAAA,aAAa,EAAE,KAF8B;AAG7C,EAAA,YAAY,EAAE,IAH+B;AAI7C,EAAA,eAAe,EAAE;AAAE,IAAA,QAAQ,EAAE;AAAZ;AAJ4B,CAA/C;;AAOA,SAAS,eAAT,CAAyB,EAAzB,EAAqF;MAA1D,OAAA,GAAA,EAAA,CAAA,O;MAAS,kBAAA,GAAA,EAAA,CAAA,kB;MAAoB,WAAA,GAAA,EAAA,CAAA,W;AACtD;;AACM,MAAA,EAAA,GAAA,KAAA,CAAA,QAAA,CAAA,YAAA;;AAEL,GAFK,CAAA;AAAA,MAAC,eAAA,GAAA,EAAA,CAAA,CAAA,CAAD;AAAA,MAAkB,kBAAA,GAAA,EAAA,CAAA,CAAA,CAAlB;AAGN;;;AACM,MAAA,EAAA,GAAA,KAAA,CAAA,QAAA,CAAA,OAAA,CAAA;AAAA,MAAC,cAAA,GAAA,EAAA,CAAA,CAAA,CAAD;AAAA,MAAiB,iBAAA,GAAA,EAAA,CAAA,CAAA,CAAjB;AACN;;;AACM,MAAA,EAAA,GAAA,KAAA,CAAA,QAAA,EAAA;AAAA,MAAC,qBAAA,GAAA,EAAA,CAAA,CAAA,CAAD;AAAA,MAAwB,wBAAA,GAAA,EAAA,CAAA,CAAA,CAAxB;;AAEN,EAAA,KAAK,CAAC,SAAN,CAAgB,YAAA;AACd,QAAI,WAAW,KAAK,SAApB,EAA+B;AAC7B,UAAM,YAAY,GAAwB,iBAAiB,CAAC,WAAD,CAA3D;AACA,UAAM,OAAO,GAAa,kBAAkB,CAAC,OAAD,EAAU,YAAV,CAA5C;AAEA,MAAA,kBAAkB,CAAC,OAAD,CAAlB;AACD;;AACD,IAAA,iBAAiB,CAAC,OAAD,CAAjB;AACD,GARD,EAQG,CAAC,OAAD,EAAU,WAAV,CARH;AAUA,EAAA,KAAK,CAAC,SAAN,CAAgB,YAAA;AACd,QAAI,WAAW,KAAK,IAApB,EAA0B;AACxB,MAAA,wBAAwB,CAAC,SAAD,CAAxB;AACD;AACF,GAJD,EAIG,CAAC,WAAD,CAJH;AAMA,SAAO,CACL,eADK,EAEL,kBAFK,EAGL,cAHK,EAIL,iBAJK,EAKL,qBALK,EAML,wBANK,CAAP;AAQD;;AAED,OAAO,IAAM,QAAQ,GAA4C,KAAK,CAAC,UAAN,CAC/D,UAAC,oBAAD,EAAuC,YAAvC,EAA8E;AAC5E,MAAM,EAAA,GAAA,oBAAA,CAAA,aAAA,EAAA,oBAAA,CAAN;AAAA,MAAQ,GAAA,GAAA,EAAA,CAAA,GAAR;AAAA,MAAa,KAAA,GAAA,MAAA,CAAA,EAAA,EAAA,CAAA,KAAA,CAAA,CAAb;;AACA,MAAM,OAAO,GAAG,KAAK,CAAC,MAAN,CAA6B,IAA7B,CAAhB;AAEA,MAAM,aAAa,GAAG,aAAa,CAAC,OAAD,EAAU,YAAV,CAAnC;;AAEM,MAAA,EAAA,GAAA,eAAA,CAAA,KAAA,CAAA;AAAA,MACJ,eAAA,GAAA,EAAA,CAAA,CAAA,CADI;AAAA,MAEJ,kBAAA,GAAA,EAAA,CAAA,CAAA,CAFI;AAAA,MAGJ,cAAA,GAAA,EAAA,CAAA,CAAA,CAHI;AAAA,MAIJ,iBAAA,GAAA,EAAA,CAAA,CAAA,CAJI;AAAA,MAKJ,qBAAA,GAAA,EAAA,CAAA,CAAA,CALI;AAAA,MAMJ,wBAAA,GAAA,EAAA,CAAA,CAAA,CANI;;AASN,SACE,KAAA,CAAA,aAAA,CAAC,gBAAD,EAAiB,QAAA,CAAA,EAAA,EACX,KADW,EACN;AACT,IAAA,OAAO,EAAE;AACP,MAAA,aAAa,EAAA,aADN;AAEP,MAAA,OAAO,EAAA,OAFA;AAGP,MAAA,eAAe,EAAA,eAHR;AAIP,MAAA,kBAAkB,EAAA,kBAJX;AAKP,MAAA,cAAc,EAAA,cALP;AAMP,MAAA,iBAAiB,EAAA,iBANV;AAOP,MAAA,qBAAqB,EAAA,qBAPd;AAQP,MAAA,wBAAwB,EAAA;AARjB;AADA,GADM,CAAjB,CADF;AAeD,CA/B8D,CAA1D;AAiCP,QAAQ,CAAC,WAAT,GAAuB,cAAvB;;AAgBA,IAAA,gBAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA+B,EAAA,SAAA,CAAA,gBAAA,EAAA,MAAA,CAAA;;AAmD7B,WAAA,gBAAA,CAAY,KAAZ,EAAyC;AAAzC,QAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,KAAN,KAAY,IADd;AAlDA;;;AACQ,IAAA,KAAA,CAAA,SAAA,GAAY,KAAK,CAAC,SAAN,EAAZ;AAER;;AACQ,IAAA,KAAA,CAAA,gBAAA,GAAmB,KAAK,CAAC,SAAN,EAAnB;AAER;;AACQ,IAAA,KAAA,CAAA,aAAA,GAAgB,KAAK,CAAC,SAAN,EAAhB;AAER;;AACQ,IAAA,KAAA,CAAA,gBAAA,GAAmB,KAAK,CAAC,SAAN,EAAnB;AA6PR;;AAEG;;AACI,IAAA,KAAA,CAAA,KAAA,GAAQ,UAAC,iBAAD,EAA8B,aAA9B,EAAqD;AAClE,UAAI,KAAI,CAAC,SAAL,CAAe,OAAnB,EAA4B;AAC1B,YAAI,aAAJ,EAAmB;AACjB,UAAA,UAAU,CAAC,KAAI,CAAC,SAAL,CAAe,OAAhB,CAAV;AACD,SAFD,MAEO;AACL,UAAA,KAAI,CAAC,SAAL,CAAe,OAAf,CAAuB,KAAvB;AACD;;AAED,YAAI,iBAAJ,EAAuB;AACrB,UAAA,KAAI,CAAC,QAAL,CAAc;AACZ,YAAA,MAAM,EAAE;AADI,WAAd;AAGD;AACF,OAbiE,CAelE;AACA;;;AACA,UAAI,CAAC,KAAI,CAAC,SAAL,EAAL,EAAuB;AACrB,QAAA,KAAI,CAAC,QAAL,CAAc;AAAE,UAAA,UAAU,EAAE;AAAd,SAAd;AACD;AACF,KApBM;AAsBP;;AAEG;;;AACI,IAAA,KAAA,CAAA,WAAA,GAAc,YAAA;AACX,UAAA,MAAA,GAAA,KAAA,CAAA,KAAA,CAAA,MAAA;AACR,MAAA,MAAM,IAAI,KAAI,CAAC,QAAL,CAAc;AAAE,QAAA,MAAM,EAAE;AAAV,OAAd,CAAV;AACD,KAHM;AAKP;;;;;;AAMG;;;AACK,IAAA,KAAA,CAAA,wCAAA,GAA2C,YAAA;AACjD,UAAM,QAAQ,GAAG,KAAI,CAAC,SAAL,CAAe,OAAhC;;AAEA,UAAI,CAAC,QAAL,EAAe;AACb,eAAO,IAAP;AACD;;AAED,UAAI,QAAQ,CAAC,KAAT,KAAmB,IAAnB,IAA2B,QAAQ,CAAC,KAAT,KAAmB,SAAlD,EAA6D;AAC3D,eAAO,IAAP;AACD;;AAED,UAAM,YAAY,GAAG,iBAAiB,CAAC,KAAI,CAAC,oBAAN,CAAtC;;AACA,UAAI,QAAQ,CAAC,KAAT,KAAmB,YAAvB,EAAqC;AACnC,eAAO,YAAP;AACD;;AAED,aAAO,QAAQ,CAAC,KAAhB;AACD,KAjBO;;AAmBA,IAAA,KAAA,CAAA,sBAAA,GAAyB,UAC/B,yBAD+B,EAE/B,cAF+B,EAET;AAEhB,UAAA,EAAA,GAAA,KAAA,CAAA,KAAA;AAAA,UACJ,KAAA,GAAA,EAAA,CAAA,KADI;AAAA,UAEJ,QAAA,GAAA,EAAA,CAAA,QAFI;AAAA,UAGJ,SAAA,GAAA,EAAA,CAAA,SAHI;AAAA,UAIJ,eAAA,GAAA,EAAA,CAAA,eAJI;AAAA,UAKJ,QAAA,GAAA,EAAA,CAAA,QALI;AAAA,UAMJ,YAAA,GAAA,EAAA,CAAA,YANI;AAAA,UAOJ,eAAA,GAAA,EAAA,CAAA,eAPI;AAAA,UAQJ,EAAA,GAAA,EAAA,CAAA,kBARI;AAAA,UAQJ,kBAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,IAAA,GAAA,EARI;AAAA,UASJ,KAAA,GAAA,EAAA,CAAA,KATI;AAAA,UAUJ,eAAA,GAAA,EAAA,CAAA,WAVI;AAAA,UAWJ,QAAA,GAAA,EAAA,CAAA,QAXI;AAAA,UAYJ,QAAA,GAAA,EAAA,CAAA,QAZI;AAAA,UAaJ,eAAA,GAAA,EAAA,CAAA,eAbI;AAAA,UAcO,qBAAA,GAAA,EAAA,CAAA,OAAA,CAAA,qBAdP;AAiBE,UAAA,MAAA,GAAA,KAAA,CAAA,KAAA,CAAA,MAAA,CAnBc,CAqBtB;AACA;AACA;AACA;;AACA,UAAM,WAAW,GACf,KAAI,CAAC,SAAL,MAAoB,KAAI,CAAC,KAAL,CAAW,WAA/B,IAA8C,yBAA9C,GACI,yBADJ,GAEI,eAHN;AAKA,aACE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AAAA,2BACmB,IADnB;AAEE,QAAA,GAAG,EAAE,KAAI,CAAC,gBAFZ;AAGE,QAAA,EAAE,EAAE,KAAI,CAAC,GAAL,GAAW,SAHjB;AAIE,QAAA,SAAS,EAAE,KAAI,CAAC,WAAL,CAAiB;AAJ9B,OAAA,EAME,KAAA,CAAA,aAAA,CAAC,QAAD,EAAS,QAAA,CAAA;AAAA,mCACkB,IADlB;AACsB,gCACP,CAAC,QAFhB;AAGP,QAAA,YAAY,EAAE,KAAI,CAAC,SAHZ;AAIP,QAAA,EAAE,EAAE,KAAI,CAAC,GAAL,GAAW,QAJR;AAKP,QAAA,SAAS,EAAE,KAAI,CAAC,WAAL,CAAiB,KALrB;AAMP,QAAA,IAAI,EAAC,MANE;AAOP,QAAA,OAAO,EAAE,KAAI,CAAC,QAPP;AAQP,QAAA,MAAM,EAAE,KAAI,CAAC,OARN;AASP,QAAA,SAAS,EAAE,KAAI,CAAC,eATT;AAUP,QAAA,OAAO,EAAE,KAAI,CAAC,aAVP;AAWP,QAAA,OAAO,EAAE,KAAI,CAAC,gBAXP;AAYP,QAAA,YAAY,EAAE,KAAI,CAAC,aAZZ;AAaP,QAAA,kBAAkB,EAAE,KAAI,CAAC,cAblB;AAagC,yBACxB,MAdR;AAcc,6BACF,KAAI,CAAC,yBAAL,EAfZ;AAgBP,QAAA,IAAI,EAAC,UAhBE;AAiBP,QAAA,QAAQ,EAAE,QAjBH;AAiBW,2BACD,KAAK,IAAI,KAAI,CAAC,GAAL,GAAW,QAlB9B;AAkBsC,sBACjC,SAAS,IAAI,CAAC,KAAd,GAAsB,SAAtB,GAAkC,SAnBvC;AAmBgD,4BAErD,YAAY,KAAK,SAAjB,GAA6B,wBAAwB,CAAC,eAAD,EAAkB,cAAlB,CAArD,GAAyF,eArBpF;AAqBmG,iCAEnF,KAAI,CAAC,6BAAL,EAvBhB;AAuBoD,yBAC5C,QAxBR;AAwBgB,yBACR,QAzBR;AAyBgB,qBACZ,MAAM,GAAG,KAAI,CAAC,GAAL,GAAW,OAAd,GAAwB,SA1BlC;AA2BP,QAAA,UAAU,EAAE,KA3BL;AA4BP,QAAA,mBAAmB,EAAE,KAAI,CAAC,oBA5BnB;AA6BP,QAAA,qBAAqB,EAAE,qBA7BhB;AA8BP,QAAA,6BAA6B,EAAE,KAAI,CAAC,wCA9B7B;AA+BP,QAAA,8CAA8C,EAC5C,KAAI,CAAC,yDAhCA;AAkCP,QAAA,KAAK,EAAE,KAlCA;AAmCP,QAAA,qBAAqB,EAAE,CAAC,KAAI,CAAC,SAAL,EAnCjB;AAoCP,QAAA,WAAW,EAAE,WApCN;AAqCP,QAAA,QAAQ,EAAE;AArCH,OAAA,EAsCH,QAtCG,CAAT,CANF,EA8CE,KAAA,CAAA,aAAA,CAAC,UAAD,EAAW,QAAA,CAAA;AACT,QAAA,SAAS,EAAE,8BADF;AAET,QAAA,MAAM,EAAE,KAAI,CAAC,qBAAL,EAFC;AAGT,QAAA,IAAI,EAAC,cAHI;AAGU,uBACN,kBAJJ;AAIsB,6BACZ,KALV;AAMT,QAAA,QAAQ,EAAE,CAAC,CANF;AAOT,QAAA,OAAO,EAAE,KAAI,CAAC,gBAPL;AAQT,QAAA,MAAM,EAAE,KAAI,CAAC,OARJ;AAST,QAAA,SAAS,EAAE,eATF;AAUT,QAAA,QAAQ,EAAE,QAVD;AAWT,QAAA,OAAO,EAAE;AAXA,OAAA,EAYL,eAZK,CAAX,CA9CF,CADF;AA+DD,KA/FO;AAiGR;;;;;;;AAOG;;;AACK,IAAA,KAAA,CAAA,yDAAA,GAA4D,YAAA;AAClE,aAAO,KAAI,CAAC,oBAAL,KAA8B,KAAI,CAAC,KAAL,CAAW,OAAX,CAAmB,qBAAxD;AACD,KAFO;AAIR;;;;AAIG;;;AACK,IAAA,KAAA,CAAA,gBAAA,GAAmB,YAAA;AACnB,UAAA,EAAA,GAAA,KAAA,CAAA,KAAA;AAAA,UACJ,IAAA,GAAA,EAAA,CAAA,IADI;AAAA,UAEJ,aAAA,GAAA,EAAA,CAAA,aAFI;AAAA,UAGJ,YAAA,GAAA,EAAA,CAAA,YAHI;AAAA,UAIJ,EAAA,GAAA,EAAA,CAAA,OAJI;AAAA,UAIO,qBAAA,GAAA,EAAA,CAAA,qBAJP;AAAA,UAI8B,eAAA,GAAA,EAAA,CAAA,eAJ9B;AAAA,UAI+C,cAAA,GAAA,EAAA,CAAA,cAJ/C;AAMA,UAAA,EAAA,GAAA,KAAA,CAAA,KAAA;AAAA,UAAE,6BAAA,GAAA,EAAA,CAAA,6BAAF;AAAA,UAAiC,mBAAA,GAAA,EAAA,CAAA,mBAAjC;AAAA,UAAsD,MAAA,GAAA,EAAA,CAAA,MAAtD;AAEN,UAAM,wBAAwB,GAAG,iBAAiB,CAAC,cAAD,EAAiB,6BAAjB,CAAlD,CATyB,CAWzB;AACA;;AACA,UACE,EAAE,MAAM,IAAI,wBAAZ,KACA,IADA,KAEC,mBAAmB,KAAK,IAAxB,IAAgC,mBAAmB,KAAK,SAFzD,CADF,EAIE;AACA,eAAO,IAAP;AACD;;AAED,UAAI,KAAI,CAAC,KAAL,CAAW,WAAf,EAA4B;AAC1B;AACA,YAAI,KAAI,CAAC,SAAL,EAAJ,EAAsB;AACpB,cAAI,KAAK,GAAG,CAAC,CAAb;;AACA,cAAI,YAAY,KAAK,IAAjB,IAAyB,wBAA7B,EAAuD;AACrD,YAAA,KAAK,GAAG,6BAAR;AACD;;AACD,iBAAO,KAAI,CAAC,iBAAL,CAAuB,mBAAvB,EAA4C,cAA5C,EAA4D,KAA5D,CAAP;AACD,SAND,MAMO;AACL,iBAAO,KAAI,CAAC,4BAAL,CAAkC,eAAlC,EAAmD,cAAnD,EAAmE,qBAAnE,CAAP;AACD;AACF,OAXD,MAWO;AACL;AACA,YAAI,KAAK,GAAW,KAAI,CAAC,sBAAL,EAApB;;AACA,YAAI,aAAJ,EAAmB;AACjB;AACA;AACA;AACA,cAAI,YAAY,KAAK,IAAjB,IAAyB,wBAA7B,EAAuD;AACrD,YAAA,KAAK,GAAG,6BAAR;AACD,WANgB,CAQjB;AACA;;;AACA,iBAAO,KAAI,CAAC,iBAAL,CAAuB,mBAAvB,EAA4C,cAA5C,EAA4D,KAA5D,CAAP;AACD,SAXD,MAWO;AACL;AACA;AACA,cAAI,wBAAwB,IAAI,YAAY,KAAK,IAAjD,EAAuD;AACrD;AACA;AACA,YAAA,KAAK,GAAG,6BAAR;AACA,mBAAO,iBAAiB,CAAC,mBAAD,CAAxB;AACD,WALD,MAKO,IAAI,CAAC,KAAI,CAAC,KAAL,CAAW,MAAZ,IAAsB,mBAA1B,EAA+C;AACpD,mBAAO,iBAAiB,CAAC,cAAD,EAAiB,KAAjB,CAAjB,GACH,mBADG,GAEH,iBAAiB,CAAC,qBAAD,CAFrB;AAGD,WAJM,MAIA;AACL,mBAAO,iBAAiB,CAAC,cAAD,EAAiB,KAAjB,CAAjB,GACH,cAAc,CAAC,cAAc,CAAC,KAAD,CAAf,CADX,GAEH,iBAAiB,CAAC,qBAAD,CAFrB;AAGD;AACF;AACF;AACF,KAjEO;AAqGR;;;AAGG;;;AACK,IAAA,KAAA,CAAA,cAAA,GAAiB,UAAC,YAAD,EAAqB;AAC5C,UAAI,KAAI,CAAC,KAAL,CAAW,QAAf,EAAyB;AACvB,QAAA,KAAI,CAAC,wBAAL,CAA8B;AAAK;AAAnC;;AACA;AACD;;AAED,MAAA,KAAI,CAAC,KAAL,CAAW,aAAX,GACI,KAAI,CAAC,+BAAL,CAAqC,YAArC,CADJ,GAEI,KAAI,CAAC,kCAAL,CAAwC,YAAxC,CAFJ;AAGD,KATO;AAiRR;;;AAGG;;;AACK,IAAA,KAAA,CAAA,QAAA,GAAW,YAAA;;;AACjB,OAAA,EAAA,GAAA,CAAA,EAAA,GAAA,KAAI,CAAC,SAAL,CAAe,OAAf,MAAsB,IAAtB,IAAsB,EAAA,KAAA,KAAA,CAAtB,GAAsB,KAAA,CAAtB,GAAsB,EAAA,CAAE,YAAxB,MAAoC,IAApC,IAAoC,EAAA,KAAA,KAAA,CAApC,GAAoC,KAAA,CAApC,GAAoC,EAAA,CAAE,MAAF,EAApC;;AAEA,UAAI,CAAC,KAAI,CAAC,SAAL,EAAL,EAAuB;AACrB,QAAA,KAAI,CAAC,QAAL,CAAc;AAAE,UAAA,UAAU,EAAE;AAAd,SAAd;AACD;AACF,KANO;AAQR;;;;AAIG;;;AACK,IAAA,KAAA,CAAA,iBAAA,GAAoB,YAAA;AAC1B,UAAI,KAAI,CAAC,KAAL,CAAW,gBAAf,EAAiC;AAC/B;AACA,YAAM,UAAU,GAAG,KAAI,CAAC,KAAL,CAAW,gBAAX,CAA2B,cAAA,CAAK,KAAI,CAAC,KAAL,CAAW,OAAX,CAAmB,cAAxB,CAA3B,CAAnB,CAF+B,CAI/B;AACA;AACA;;;AACA,YAAI,KAAK,CAAC,OAAN,CAAc,UAAd,CAAJ,EAA+B;AAC7B,UAAA,KAAI,CAAC,KAAL,CAAW,OAAX,CAAmB,iBAAnB,CAAqC,UAArC;AACD,SAFD,MAEO,IAAI,UAAU,IAAI,UAAU,CAAC,IAA7B,EAAmC;AACxC;AACA;AACA,cAAM,SAAO,GAAoC,KAAI,CAAC,eAAL,GAAuB,UAAxE;AACA,UAAA,SAAO,CAAC,IAAR,CAAa,UAAC,qBAAD,EAAyC;AACpD,gBAAI,SAAO,KAAK,KAAI,CAAC,eAArB,EAAsC;AACpC,cAAA,KAAI,CAAC,KAAL,CAAW,OAAX,CAAmB,iBAAnB,CAAqC,qBAArC;AACD;AACF,WAJD;AAKD;AACF;AACF,KArBO;AAuBR;;;AAGG;AACH;;;AACQ,IAAA,KAAA,CAAA,OAAA,GAAU,UAAC,KAAD,EAAsE;iBAAA,CACtF;AACA;AACA;;;AACA,UAAI,aAAa,GAAG,KAAK,CAAC,aAA1B;;AACA,UAAI,KAAK,CAAC,aAAN,KAAwB,IAA5B,EAAkC;AAChC;AACA;AACA;AACA;AACA;AACA,QAAA,aAAa,GAAG,QAAQ,CAAC,aAAzB;AACD;;AAED,UAAI,aAAJ,EAAmB;AACjB,YAAM,uBAAuB,GAAA,CAAA,EAAA,GAAG,KAAI,CAAC,KAAL,CAAW,OAAX,CAAmB,OAAnB,CAA2B,OAA9B,MAAqC,IAArC,IAAqC,EAAA,KAAA,KAAA,CAArC,GAAqC,KAAA,CAArC,GAAqC,EAAA,CAAE,QAAF,CAAW,aAAX,CAAlE;AACA,YAAM,sBAAsB,GAAA,CAAA,EAAA,GAAG,KAAI,CAAC,aAAL,CAAmB,OAAtB,MAA6B,IAA7B,IAA6B,EAAA,KAAA,KAAA,CAA7B,GAA6B,KAAA,CAA7B,GAA6B,EAAA,CAAE,QAAF,CAAW,aAAX,CAAzD;AACA,YAAM,8BAA8B,GAClC,KAAI,CAAC,aAAL,CAAmB,OAAnB,IACA,oBAAoB,CAAC,KAAI,CAAC,aAAL,CAAmB,OAApB,EAA6B,UAAC,OAAD,EAAqB;AAAK,iBAAA,OAAO,KAAP,aAAA;AAAyB,SAAhF,CAFtB;;AAIA,YAAI,uBAAuB,IAAI,sBAA3B,IAAqD,8BAAzD,EAAyF;AACvF,cACE,8BAA8B,IAC9B,KAAI,CAAC,SAAL,EADA,KAEC,CAAC,KAAI,CAAC,KAAL,CAAW,WAAZ,IAA2B,KAAI,CAAC,KAAL,CAAW,aAFvC,CADF,EAIE;AACA,YAAA,KAAI,CAAC,mBAAL,CAAyB,KAAzB;AACD;;AACD,UAAA,KAAK,CAAC,cAAN;AACA,UAAA,KAAK,CAAC,eAAN;AACA;AACD;AACF;;AAED,UAAI,KAAI,CAAC,SAAL,EAAJ,EAAsB;AACpB,QAAA,KAAI,CAAC,QAAL,CAAc;AAAE,UAAA,UAAU,EAAE;AAAd,SAAd;;AACA,YAAI,CAAC,KAAI,CAAC,KAAL,CAAW,WAAZ,IAA2B,KAAI,CAAC,KAAL,CAAW,aAA1C,EAAyD;AACvD,UAAA,KAAI,CAAC,mBAAL,CAAyB,KAAzB;AACD;AACF;AACF,KAzCO,CAzyBiC,CAk7BzC;;;AACQ,IAAA,KAAA,CAAA,kBAAA,GAAqB,UAAC,KAAD,EAAsB;;;AAE/C,UAAA,YAAA,GAAA,KAAA,CAAA,YAAA;AAAA,UACA,YAAA,GAAA,KAAA,CAAA,YADA;AAAA,UAEA,aAAA,GAAA,KAAA,CAAA,aAFA;AAAA,UAGA,gBAAA,GAAA,KAAA,CAAA,gBAHA;AAAA,UAIA,EAAA,GAAA,KAAA,CAAA,oBAJA;AAAA,UAIA,oBAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,qBAAA,GAAA,EAJA;AAAA,UAKA,EAAA,GAAA,KAAA,CAAA,oBALA;AAAA,UAKA,oBAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,qBAAA,GAAA,EALA;AAAA,UAMA,sBAAA,GAAA,KAAA,CAAA,sBANA;AAAA,UAOA,WAAA,GAAA,KAAA,CAAA,WAPA;AAAA,UAQA,EAAA,GAAA,KAAA,CAAA,kBARA;AAAA,UAQA,kBAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,IAAA,GAAA,EARA;AAWM,UAAA,MAAA,GAAA,KAAA,CAAA,KAAA,CAAA,MAAA;AACR,UAAM,EAAE,GAAG,KAAI,CAAC,GAAhB;AAEA,UAAM,iBAAiB,GACrB,sBAAsB,IAAI,KAAI,CAAC,gBAAL,CAAsB,OAAhD,GACI,KAAI,CAAC,gBAAL,CAAsB,OAAtB,CAA8B,WAA9B,GAA4C,CADhD,GAEI,SAHN;AAKA,aACE,KAAA,CAAA,aAAA,CAAC,OAAD,EAAQ,QAAA,CAAA;AACN,QAAA,aAAa,EAAE,KADT;AAEN,QAAA,QAAQ,EAAE,CAFJ;AAGN,QAAA,UAAU,EAAE,KAHN;AAIN,QAAA,eAAe,EAAE,eAAe,CAAC,cAJ3B;AAKN,QAAA,oBAAoB,EAAE;AALhB,OAAA,EAMF,YANE,EAMU;AAChB,QAAA,cAAc,EAAE,KAAI,CAAC,eADL;AAEhB,QAAA,SAAS,EAAE,GAAG,CAAC,KAAI,CAAC,WAAL,CAAiB,OAAlB,EAAyB,CAAA,EAAA,GAAE,YAAF,MAAc,IAAd,IAAc,EAAA,KAAA,KAAA,CAAd,GAAc,KAAA,CAAd,GAAc,EAAA,CAAE,SAAzC,CAFE;AAGhB,QAAA,MAAM,EAAE,KAAI,CAAC,gBAAL,CAAsB,OAHd;AAIhB,QAAA,SAAS,EAAE,KAAI,CAAC,UAJA;AAKhB,QAAA,WAAW,EAAE,KAAI,CAAC,mBALF;AAMhB,QAAA,QAAQ,EAAE,KAAI,CAAC,SANC;AAOhB,QAAA,eAAe,EAAE,KAPD;AAQhB,QAAA,YAAY,EACV,sBAAsB,IAAI,KAAI,CAAC,gBAAL,CAAsB,OAAhD,GACI,iBAAiB,IAAI,iBADzB,GAEI,aAXU;AAahB,QAAA,eAAe,EAAE,gBAAgB,GAAG,gBAAH,GAAsB,iBAbvC;AAchB,QAAA,MAAM,EAAE,WAAW,GAAG,CAAC,MAAJ,GAAa,SAdhB;AAehB,QAAA,kBAAkB,EAAE;AAfJ,OANV,CAAR,EAuBG,oBAAoB,CAAC,KAAI,CAAC,KAAN,EAAa,KAAI,CAAC,qBAAlB,CAvBvB,EAwBE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AAAK,QAAA,SAAS,EAAE,KAAI,CAAC,WAAL,CAAiB,uBAAjC;AAA0D,QAAA,GAAG,EAAE,KAAI,CAAC;AAApE,OAAA,EAAiF,CAAA,EAAA,GAC9E,YAD8E,MAClE,IADkE,IAClE,EAAA,KAAA,KAAA,CADkE,GAClE,KAAA,CADkE,GAClE,EAAA,CAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAAQ,KAAR,CAAA,EAAa;AAAE,QAAA,EAAE,EAAA;AAAJ,OAAb,CAAA,EAAqB,KAAI,CAAC,aAA1B,CADf,CAxBF,EA2BG,oBAAoB,CAAC,KAAI,CAAC,KAAN,EAAa,KAAI,CAAC,qBAAlB,CA3BvB,CADF;AA+BD,KApDO;;AA8DA,IAAA,KAAA,CAAA,eAAA,GAAkB,YAAA;AACxB,MAAA,KAAI,CAAC,sBAAL;;AAEA,UAAI,KAAI,CAAC,KAAL,CAAW,YAAX,IAA2B,KAAI,CAAC,KAAL,CAAW,YAAX,CAAwB,cAAvD,EAAuE;AACrE,QAAA,KAAI,CAAC,KAAL,CAAW,YAAX,CAAwB,cAAxB;AACD;AACF,KANO;;AAQA,IAAA,KAAA,CAAA,cAAA,GAAiB,UAAC,kBAAD,EAAgD;AACjE,UAAA,EAAA,GAAA,kBAAA,CAAA,KAAA;AAAA,UAAE,KAAA,GAAA,EAAA,CAAA,KAAF;AAAA,UAAS,QAAA,GAAA,EAAA,CAAA,QAAT;AAAA,UAAmB,QAAA,GAAA,EAAA,CAAA,QAAnB;;AAEN,UAAI,KAAJ,EAAW;AACT,eACE,KAAA,CAAA,aAAA,CAAC,KAAD,EAAM;AAAC,UAAA,EAAE,EAAE,KAAI,CAAC,GAAL,GAAW,QAAhB;AAA0B,UAAA,QAAQ,EAAE,QAApC;AAA8C,UAAA,QAAQ,EAAE,QAAxD;AAAkE,UAAA,SAAS,EAAE,KAAI,CAAC,WAAL,CAAiB;AAA9F,SAAN,EACG,KADH,EAEG,kBAAkB,CAAC,yBAAnB,IACC,KAAA,CAAA,aAAA,CAAA,MAAA,EAAA;AAAM,UAAA,SAAS,EAAE,KAAI,CAAC,WAAL,CAAiB;AAAlC,SAAA,EAAqD,kBAAkB,CAAC,yBAAxE,CAHJ,CADF;AAQD;;AAED,aAAO,IAAP;AACD,KAfO,CAz/BiC,CA0gCzC;;;AACQ,IAAA,KAAA,CAAA,aAAA,GAAgB,UAAC,KAAD,EAAsB;AACpC,UAAA,YAAA,GAAA,KAAA,CAAA,YAAA;AAAA,UAAc,OAAA,GAAA,KAAA,CAAA,OAAd;AAER,UAAM,EAAE,GAAG,KAAI,CAAC,GAAhB;AACA,aACE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AACE,QAAA,EAAE,EAAE,EAAE,GAAG,OADX;AAEE,QAAA,SAAS,EAAE,KAAI,CAAC,WAAL,CAAiB,gBAF9B;AAE8C,2BAC3B,EAAE,GAAG,QAHxB;AAIE,QAAA,IAAI,EAAC;AAJP,OAAA,EAMG,OAAO,CAAC,GAAR,CAAY,UAAA,IAAA,EAAI;AAAA,YAAA,EAAA;;AAAA,eAAA,CAAA,EAAA,GAAI,YAAJ,MAAgB,IAAhB,IAAgB,EAAA,KAAA,KAAA,CAAhB,GAAgB,KAAA,CAAhB,GAAgB,EAAA,CAAG,IAAH,EAAS,KAAI,CAAC,aAAd,CAAhB;AAA4C,OAA5D,CANH,CADF;AAUD,KAdO,CA3gCiC,CA2hCzC;;;AACQ,IAAA,KAAA,CAAA,aAAA,GAAgB,UAAC,IAAD,EAAsB;AAC5C,cAAQ,IAAI,CAAC,QAAb;AACE,aAAK,4BAA4B,CAAC,OAAlC;AACE,iBAAO,KAAI,CAAC,gBAAL,CAAsB,IAAtB,CAAP;;AACF,aAAK,4BAA4B,CAAC,MAAlC;AACE,iBAAO,KAAI,CAAC,aAAL,CAAmB,IAAnB,CAAP;;AACF;AACE,iBAAO,KAAI,CAAC,aAAL,CAAmB,IAAnB,CAAP;AANJ;AAQD,KATO,CA5hCiC,CAuiCzC;;;AACQ,IAAA,KAAA,CAAA,qBAAA,GAAwB,YAAA;AAC9B,aAAO,IAAP;AACD,KAFO,CAxiCiC,CA4iCzC;;;AACQ,IAAA,KAAA,CAAA,qBAAA,GAAwB,YAAA;AAC9B,aAAO,IAAP;AACD,KAFO;;AAwBA,IAAA,KAAA,CAAA,aAAA,GAAgB,UAAC,IAAD,EAAsB;AACpC,UAAA,EAAA,GAAA,KAAA,CAAA,KAAA,CAAA,cAAA;AAAA,UAAA,cAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,sBAAA,GAAA,EAAA;AACR,UAAM,EAAE,GAAG,KAAI,CAAC,GAAhB;;AACA,UAAM,UAAU,GAAY,KAAI,CAAC,iBAAL,CAAuB,IAAI,CAAC,KAA5B,CAA5B;;AACA,UAAM,SAAS,GAAY,KAAI,CAAC,gBAAL,CAAsB,IAAI,CAAC,KAA3B,CAA3B;;AACA,UAAM,YAAY,GAAG,KAAI,CAAC,uBAAL,CAA6B,IAA7B,CAArB;;AACA,UAAM,gBAAgB,GAAG,2BAA2B,CAAC,KAAI,CAAC,uBAAL,CAA6B,IAA7B,CAAD,CAApD;AACA,UAAM,KAAK,GAAG,cAAc,CAAC,IAAD,CAA5B;;AAEA,UAAM,qBAAqB,GAAG,YAAA;AAAM,eAAA,cAAc,CAAC,IAAD,EAAO,KAAI,CAAzB,sBAAc,CAAd;AAAiD,OAArF;;AAEA,UAAM,kBAAkB,GAAG,YAAA;AACzB,eAAO,CAAC,KAAI,CAAC,KAAL,CAAW,WAAZ,GACL,KAAA,CAAA,aAAA,CAAC,aAAD,EAAc;AACZ,UAAA,EAAE,EAAE,EAAE,GAAG,OAAL,GAAe,IAAI,CAAC,KADZ;AAEZ,UAAA,GAAG,EAAE,IAAI,CAAC,GAFE;AAEC,wBACD,IAAI,CAAC,KAHL;AAIZ,UAAA,MAAM,EAAE,YAJI;AAKZ,UAAA,OAAO,EAAE,UALG;AAMZ,UAAA,SAAS,EAAE,oBANC;AAOZ,UAAA,OAAO,EAAE,KAAI,CAAC,YAAL,CAAkB,IAAlB,CAPG;AAQZ;AACA,UAAA,YAAY,EAAE,KAAI,CAAC,mBAAL,CAAyB,IAAzB,CAA8B,KAA9B,EAAoC,IAAI,CAAC,KAAzC,CATF;AAUZ;AACA,UAAA,WAAW,EAAE,KAAI,CAAC,kBAAL,CAAwB,IAAxB,CAA6B,KAA7B,EAAmC,IAAI,CAAC,KAAxC,CAXD;AAYZ,UAAA,YAAY,EAAE,KAAI,CAAC,mBAZP;AAaZ,UAAA,IAAI,EAAC,QAbO;AAaC,2BAEE,SAAS,GAAG,MAAH,GAAY,OAfxB;AAgBZ,UAAA,SAAS,EAAE,cAAc,CAAC,IAAD,CAhBb;AAiBZ,UAAA,QAAQ,EAAE,IAAI,CAAC,QAjBH;AAkBZ,UAAA,KAAK,EAAE;AAlBK,SAAd,EAqBI,KAAA,CAAA,aAAA,CAAA,MAAA,EAAA;AAAM,UAAA,SAAS,EAAE,gBAAgB,CAAC,iBAAlC;AAAqD,UAAA,GAAG,EAAE,UAAU,GAAG,KAAI,CAAC,gBAAR,GAA2B;AAA/F,SAAA,EACG,cAAc,CAAC,IAAD,EAAO,KAAI,CAAC,sBAAZ,CADjB,CArBJ,CADK,GA4BL,KAAA,CAAA,aAAA,CAAC,QAAD,EAAS;AACP,UAAA,EAAE,EAAE,EAAE,GAAG,OAAL,GAAe,IAAI,CAAC,KADjB;AAEP,UAAA,SAAS,EAAE,cAAc,CAAC,IAAD,CAFlB;AAGP,UAAA,GAAG,EAAE,IAAI,CAAC,GAHH;AAIP,UAAA,MAAM,EAAE,YAJD;AAKP,UAAA,SAAS,EAAE,oBALJ;AAMP,UAAA,QAAQ,EAAE,KAAI,CAAC,YAAL,CAAkB,IAAlB,CANH;AAOP,UAAA,KAAK,EAAE,IAAI,CAAC,IAPL;AAQP,UAAA,OAAO,EAAE,SARF;AASP,UAAA,KAAK,EAAE,KATA;AAUP,UAAA,QAAQ,EAAE,IAAI,CAAC,QAVR;AAWP;AACA,UAAA,aAAa,EAAE,qBAZR;AAaP,UAAA,UAAU,EAAA,QAAA,CAAA;AACR;AACA,6BAAiB,SAAS,GAAG,MAAH,GAAY,OAF9B;AAGR,YAAA,IAAI,EAAE;AAHE,WAAA,EAIJ;AACF,0BAAc,IAAI,CAAC,KADjB;AAEF,iCAAqB;AAFnB,WAJI;AAbH,SAAT,CA5BF;AAoDD,OArDD;;AAuDA,aACE,KAAA,CAAA,aAAA,CAAC,qBAAD,EAAsB;AACpB,QAAA,GAAG,EAAE,IAAI,CAAC,GADU;AAEpB,QAAA,KAAK,EAAE,IAAI,CAAC,KAFQ;AAGpB,QAAA,QAAQ,EAAE,IAAI,CAAC,QAHK;AAIpB,QAAA,UAAU,EAAE,UAJQ;AAKpB,QAAA,SAAS,EAAE,SALS;AAMpB,QAAA,IAAI,EAAE,IAAI,CAAC,IANS;AAOpB;AACA,QAAA,MAAM,EAAE,kBARY;AASpB,QAAA,IAAI,EAAE,IAAI,CAAC;AATS,OAAtB,CADF;AAaD,KA/EO;AAqIR;;AAEG;;;AACK,IAAA,KAAA,CAAA,mBAAA,GAAoD,UAAA,EAAA,EAAE;AAC5D,MAAA,EAAE,CAAC,cAAH;AACD,KAFO;AAIR;;;AAGG;;;AACK,IAAA,KAAA,CAAA,SAAA,GAAY,YAAA;AAClB,UAAI,CAAC,KAAI,CAAC,aAAN,IAAuB,KAAI,CAAC,oBAAL,KAA8B,SAAzD,EAAoE;AAClE,QAAA,KAAI,CAAC,MAAL,CAAY,YAAZ,CAAyB,KAAI,CAAC,oBAA9B;;AACA,QAAA,KAAI,CAAC,oBAAL,GAA4B,SAA5B;AACD,OAHD,MAGO;AACL,QAAA,KAAI,CAAC,aAAL,GAAqB,KAArB;AACD;;AAED,MAAA,KAAI,CAAC,oBAAL,GAA4B,KAAI,CAAC,MAAL,CAAY,UAAZ,CAAuB,YAAA;AACjD,QAAA,KAAI,CAAC,aAAL,GAAqB,IAArB;AACD,OAF2B,EAEzB,eAFyB,CAA5B;AAGD,KAXO;;AA8DA,IAAA,KAAA,CAAA,sBAAA,GAAyB,UAAC,IAAD,EAAsB;AACrD,UAAM,gBAAgB,GAAG,2BAA2B,CAAC,KAAI,CAAC,uBAAL,CAA6B,IAA7B,CAAD,CAApD;AACA,aAAO,KAAA,CAAA,aAAA,CAAA,MAAA,EAAA;AAAM,QAAA,SAAS,EAAE,gBAAgB,CAAC;AAAlC,OAAA,EAA+C,IAAI,CAAC,IAApD,CAAP;AACD,KAHO;AA8BR;;AAEG;;;AACK,IAAA,KAAA,CAAA,UAAA,GAAa,YAAA;AACX,UAAA,aAAA,GAAA,KAAA,CAAA,KAAA,CAAA,aAAA;;AACR,UAAI,aAAJ,EAAmB;AACjB,QAAA,aAAa;AACd,OAJkB,CAMnB;AACA;AACA;;;AACA,UAAI,KAAI,CAAC,KAAL,CAAW,WAAf,EAA4B;AAC1B,QAAA,KAAI,CAAC,sBAAL;AACD,OAXkB,CAanB;;;AACA,MAAA,KAAI,CAAC,4BAAL,CAAkC;AAAM;AAAxC,QAAsD;AAAM;AAA5D,QAdmB,CAgBnB;AACA;;;AACA,MAAA,KAAI,CAAC,mBAAL;AACD,KAnBO;;AAyDA,IAAA,KAAA,CAAA,wBAAA,GAA2B,YAAA;AACjC,MAAA,KAAI,CAAC,2BAAL,GAAmC,KAAnC;AACD,KAFO;AAkIR;;;AAGG;;;AACK,IAAA,KAAA,CAAA,eAAA,GAAkB,UAAC,EAAD,EAAgD;AAClE,UAAA,EAAA,GAAA,KAAA,CAAA,KAAA;AAAA,UACJ,QAAA,GAAA,EAAA,CAAA,QADI;AAAA,UAEJ,aAAA,GAAA,EAAA,CAAA,aAFI;AAAA,UAGJ,YAAA,GAAA,EAAA,CAAA,YAHI;AAAA,UAIO,cAAA,GAAA,EAAA,CAAA,OAAA,CAAA,cAJP;AAMA,UAAA,EAAA,GAAA,KAAA,CAAA,KAAA;AAAA,UAAE,MAAA,GAAA,EAAA,CAAA,MAAF;AAAA,UAAU,oCAAA,GAAA,EAAA,CAAA,oCAAV,CAPkE,CASxE;AACA;;AACA,MAAA,KAAI,CAAC,wBAAL,GAAgC,WAAW,CAAC,EAAD,CAA3C;;AAEA,UAAI,QAAJ,EAAc;AACZ,QAAA,KAAI,CAAC,wBAAL,CAA8B,EAA9B;;AACA;AACD;;AAED,UAAI,KAAK,GAAG,KAAI,CAAC,wBAAL,CAA8B;AAAM;AAApC,OAAZ,CAlBwE,CAoBxE;;;AACA,cAAQ,EAAE,CAAC,KAAX;AACE,aAAK,QAAQ,CAAC,KAAd;AACE,cAAI,KAAI,CAAC,SAAL,CAAe,OAAf,IAA0B,KAAI,CAAC,SAAL,CAAe,OAAf,CAAuB,YAArD,EAAmE;AACjE,YAAA,KAAI,CAAC,SAAL,CAAe,OAAf,CAAuB,YAAvB,CAAoC,MAApC;AACD;;AAED,UAAA,KAAI,CAAC,mBAAL,CAAyB,EAAzB;;AACA,cAAI,KAAI,CAAC,KAAL,CAAW,WAAX,IAA0B,MAA9B,EAAsC;AACpC,YAAA,KAAI,CAAC,QAAL,CAAc;AACZ,cAAA,6BAA6B,EAAE;AADnB,aAAd;AAGD,WAJD,MAIO;AACL;AACA,gBACE,MAAM,IACL,CAAC,CAAC,aAAD,IACA,KAAI,CAAC,KAAL,CAAW,mBAAX,KAAmC,SADnC,IAEA,KAAI,CAAC,KAAL,CAAW,mBAAX,KAAmC,IAFnC,IAGA,KAAI,CAAC,KAAL,CAAW,mBAAX,CAA+B,MAA/B,IAAyC,CAH1C,KAIC,KAAI,CAAC,KAAL,CAAW,6BAAX,GAA2C,CAN/C,EAOE;AACA;AACA;AACA;AACA;AACA;AACA,cAAA,KAAI,CAAC,QAAL,CAAc;AACZ,gBAAA,MAAM,EAAE,CAAC;AADG,eAAd;AAGD;AACF;;AACD;;AAEF,aAAK,QAAQ,CAAC,GAAd;AACE;AACA,cAAI,CAAC,KAAI,CAAC,KAAL,CAAW,WAAhB,EAA6B;AAC3B,YAAA,KAAI,CAAC,mBAAL,CAAyB,EAAzB;AACD,WAJH,CAME;AACA;;;AACA,cAAI,MAAJ,EAAY;AACV,YAAA,KAAI,CAAC,4BAAL,CAAkC,CAAC,MAAnC,EAA2C;AAAM;AAAjD;AACD,WAVH,CAYE;;;AACA;;AAEF,aAAK,QAAQ,CAAC,MAAd;AACE;AACA,UAAA,KAAI,CAAC,mBAAL,GAFF,CAIE;;;AACA,cAAI,MAAJ,EAAY;AACV,YAAA,KAAI,CAAC,QAAL,CAAc;AACZ,cAAA,MAAM,EAAE;AADI,aAAd;AAGD,WAJD,MAIO;AACL;AACD;;AACD;;AAEF,aAAK,QAAQ,CAAC,EAAd;AACE;AACA;AACA;AACA,cAAI,oCAAoC,KAAK,WAAW,CAAC,QAAzD,EAAmE;AACjE,YAAA,KAAK,GAAG,KAAI,CAAC,KAAL,CAAW,OAAX,CAAmB,cAAnB,CAAkC,MAA1C;AACD;;AAED,cAAI,EAAE,CAAC,MAAH,IAAa,EAAE,CAAC,OAApB,EAA6B;AAC3B;AACA;AACA;AACA,gBAAI,MAAJ,EAAY;AACV,cAAA,KAAI,CAAC,4BAAL,CAAkC,CAAC,MAAnC,EAA2C;AAAK;AAAhD;;AACA;AACD;;AAED;AACD,WAlBH,CAoBE;;;AACA,UAAA,KAAI,CAAC,oCAAL,CAA0C,KAA1C,EAAiD,eAAe,CAAC,QAAjE;;AACA;;AAEF,aAAK,QAAQ,CAAC,IAAd;AACE;AACA,cAAI,EAAE,CAAC,MAAH,IAAa,EAAE,CAAC,OAApB,EAA6B;AAC3B,YAAA,KAAI,CAAC,4BAAL,CAAkC;AAAK;AAAvC,cAAqD;AAAK;AAA1D;AACD,WAFD,MAEO;AACL;AACA;AACA;AACA,gBAAI,oCAAoC,KAAK,WAAW,CAAC,QAAzD,EAAmE;AACjE,cAAA,KAAK,GAAG,CAAC,CAAT;AACD,aANI,CAQL;;;AACA,YAAA,KAAI,CAAC,oCAAL,CAA0C,KAA1C,EAAiD,eAAe,CAAC,OAAjE;AACD;;AACD;;AAEF,aAAK,QAAQ,CAAC,IAAd;AACA,aAAK,QAAQ,CAAC,GAAd;AACE,cAAI,aAAJ,EAAmB;AACjB;AACD,WAHH,CAKE;AACA;;;AACA,UAAA,KAAK,GAAG,CAAC,CAAT;AACA,cAAI,iBAAiB,GAAG,eAAe,CAAC,OAAxC,CARF,CAUE;AACA;AACA;;AACA,cAAI,EAAE,CAAC,KAAH,KAAa,QAAQ,CAAC,GAA1B,EAA+B;AAC7B,YAAA,KAAK,GAAG,cAAc,CAAC,MAAvB;AACA,YAAA,iBAAiB,GAAG,eAAe,CAAC,QAApC;AACD;;AAED,UAAA,KAAI,CAAC,oCAAL,CAA0C,KAA1C,EAAiD,iBAAjD;;AACA;;AAEF;;AACA,aAAK,QAAQ,CAAC,KAAd;AACE;AACA,cAAI,CAAC,aAAD,IAAkB,YAAY,KAAK,KAAvC,EAA8C;AAC5C;AACD;;AAEH;AACE;AACA;AACA;AACA,cAAI,EAAE,CAAC,KAAH,IAAY;AAAI;AAAhB,aAA4B,EAAE,CAAC,KAAH,IAAY;AAAI;AAAhD,YAA2D;AACzD;AACD,aANH,CAQE;AACA;;;AACA,cAAI,EAAE,CAAC,OAAH,KAAe,QAAQ,CAAC,GAAxB,IAA+B,EAAE,CAAC,GAAH,KAAW;AAAO;AAArD,YAAsE;AACpE;AACD,aAZH,CAcE;AACA;AACA;;;AACA,cAAI,CAAC,aAAD,IAAkB,YAAY,KAAK,IAAvC,EAA6C;AAC3C,YAAA,KAAI,CAAC,cAAL,CAAoB,EAAE,CAAC,GAAvB;;AACA;AACD,WApBH,CAsBE;;;AACA;AA3JJ;;AA8JA,MAAA,EAAE,CAAC,eAAH;AACA,MAAA,EAAE,CAAC,cAAH;AACD,KArLO;AAuLR;;;AAGG;;;AACK,IAAA,KAAA,CAAA,aAAA,GAAgB,UAAC,EAAD,EAAgD;AAChE,UAAA,EAAA,GAAA,KAAA,CAAA,KAAA;AAAA,UAAE,QAAA,GAAA,EAAA,CAAA,QAAF;AAAA,UAAY,aAAA,GAAA,EAAA,CAAA,aAAZ;AAAA,UAA2B,YAAA,GAAA,EAAA,CAAA,YAA3B;AACN,UAAM,MAAM,GAAG,KAAI,CAAC,KAAL,CAAW,MAA1B,CAFsE,CAItE;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAM,wBAAwB,GAAG,KAAI,CAAC,wBAAL,IAAiC,WAAW,CAAC,EAAD,CAA7E;AACA,MAAA,KAAI,CAAC,wBAAL,GAAgC,KAAhC;AACA,UAAM,eAAe,GAAG,wBAAwB,IAAI,EAAE,KAAK,MAAM,KAAK,EAAlB,CAApD;;AAEA,UAAI,QAAJ,EAAc;AACZ,QAAA,KAAI,CAAC,wBAAL,CAA8B,EAA9B;;AACA;AACD,OAlBqE,CAoBtE;;;AACA,cAAQ,EAAE,CAAC,KAAX;AACE,aAAK,QAAQ,CAAC,KAAd;AACE;AACA;AACA;AACA,cAAI,CAAC,aAAD,IAAkB,YAAY,KAAK,KAAvC,EAA8C;AAC5C,YAAA,KAAI,CAAC,4BAAL,CAAkC,CAAC,MAAnC,EAA2C,CAAC,CAAC,MAA7C;AACD;;AACD;;AACF;AACE,cAAI,eAAe,IAAI,MAAvB,EAA+B;AAC7B,YAAA,KAAI,CAAC,4BAAL,CAAkC,CAAC,MAAnC,EAA2C;AAAK;AAAhD;AACD,WAFD,MAEO;AACL,gBAAI,KAAI,CAAC,KAAL,CAAW,UAAX,KAA0B,UAA1B,IAAwC,KAAI,CAAC,KAAL,CAAW,mBAAvD,EAA4E;AAC1E,cAAA,KAAI,CAAC,QAAL,CAAc;AAAE,gBAAA,MAAM,EAAE;AAAV,eAAd;AACD;;AACD,gBAAI,KAAI,CAAC,KAAL,CAAW,UAAX,KAA0B,SAA9B,EAAyC;AACvC,cAAA,KAAI,CAAC,QAAL,CAAc;AAAE,gBAAA,UAAU,EAAE;AAAd,eAAd;AACD;AACF;;AACD;AApBJ;AAsBD,KA3CO;;AAmEA,IAAA,KAAA,CAAA,mBAAA,GAAsB,YAAA;AAC5B,UAAI,KAAI,CAAC,uBAAL,EAAJ,EAAoC;AAClC;AACD,OAH2B,CAK5B;AACA;;;AACA,UAAI,KAAI,CAAC,KAAL,CAAW,WAAX,IAA0B,CAAC,KAAI,CAAC,KAAL,CAAW,MAA1C,EAAkD;AAChD;AACD;;AAED,MAAA,KAAI,CAAC,QAAL,CAAc;AACZ,QAAA,oCAAoC,EAAE,WAAW,CAAC;AADtC,OAAd;AAGD,KAdO;AAiDR;;;AAGG;;;AACK,IAAA,KAAA,CAAA,gBAAA,GAAmB,YAAA;AACjB,UAAA,QAAA,GAAA,KAAA,CAAA,KAAA,CAAA,QAAA;AACA,UAAA,MAAA,GAAA,KAAA,CAAA,KAAA,CAAA,MAAA;;AAER,UAAI,CAAC,QAAL,EAAe;AACb,QAAA,KAAI,CAAC,4BAAL,CAAkC,CAAC,MAAnC,EAA2C;AAAM;AAAjD;;AACA,QAAA,KAAI,CAAC,QAAL,CAAc;AAAE,UAAA,UAAU,EAAE;AAAd,SAAd;AACD;AACF,KARO;AAUR;;AAEG;;;AACK,IAAA,KAAA,CAAA,gBAAA,GAAmB,YAAA;AACnB,UAAA,EAAA,GAAA,KAAA,CAAA,KAAA;AAAA,UAAE,QAAA,GAAA,EAAA,CAAA,QAAF;AAAA,UAAY,aAAA,GAAA,EAAA,CAAA,aAAZ;;AACN,UAAI,aAAa,IAAI,CAAC,QAAtB,EAAgC;AAC9B,QAAA,KAAI,CAAC,KAAL,CAAW,KAAI,CAAC,KAAL,CAAW,MAAX,IAAqB,KAAI,CAAC,gBAArC;AACD,OAFD,MAEO;AACL,QAAA,KAAI,CAAC,gBAAL;AACD;AACF,KAPO;;AASA,IAAA,KAAA,CAAA,aAAA,GAA4B,YAAA;AAClC,UAAI,KAAI,CAAC,gBAAL,CAAsB,OAAtB,IAAiC,EAAE,mBAAmB,KAAI,CAAC,gBAA1B,CAArC,EAAkF;AAChF,QAAA,KAAI,CAAC,2BAAL;AACD;AACF,KAJO;;AAMA,IAAA,KAAA,CAAA,cAAA,GAAiB,UAAC,EAAD,EAAiB;AACxC,UAAI,EAAE,CAAC,WAAH,KAAmB,OAAvB,EAAgC;AAC9B,QAAA,KAAI,CAAC,2BAAL;;AAEA,QAAA,EAAE,CAAC,cAAH;AACA,QAAA,EAAE,CAAC,wBAAH;AACD;AACF,KAPO;;AA/zDN,IAAA,sBAAsB,CAAC,KAAD,CAAtB;AACA,IAAA,KAAI,CAAC,MAAL,GAAc,IAAI,KAAJ,CAAU,KAAV,CAAd;AACA,IAAA,KAAI,CAAC,OAAL,GAAe,IAAI,UAAJ,CAAe,KAAf,CAAf;AAEA,IAAA,qBAAqB,CAAC,cAAD,EAAiB,KAAjB,EAAwB;AAC3C,MAAA,kBAAkB,EAAE,aADuB;AAE3C,MAAA,IAAI,EAAE,oBAFqC;AAG3C,MAAA,WAAW,EAAE,OAH8B;AAI3C,MAAA,aAAa,EAAE;AAJ4B,KAAxB,CAArB;AAOA,IAAA,KAAI,CAAC,GAAL,GAAW,KAAK,CAAC,EAAN,IAAY,KAAK,CAAC,UAAD,CAA5B;AAEA,IAAA,KAAI,CAAC,aAAL,GAAqB,IAArB;AACA,IAAA,KAAI,CAAC,gBAAL,GAAwB,KAAxB;AACA,IAAA,KAAI,CAAC,aAAL,GAAqB,KAArB;AACA,IAAA,KAAI,CAAC,2BAAL,GAAmC,KAAnC;AAEA,IAAA,KAAI,CAAC,KAAL,GAAa;AACX,MAAA,MAAM,EAAE,KADG;AAEX,MAAA,UAAU,EAAE,MAFD;AAGX,MAAA,6BAA6B,EAAE,CAAC,CAHrB;AAIX,MAAA,mBAAmB,EAAE,SAJV;AAKX,MAAA,oCAAoC,EAAE,WAAW,CAAC;AALvC,KAAb;;AAOD;;AAKD,EAAA,MAAA,CAAA,cAAA,CAAW,gBAAA,CAAA,SAAX,EAAW,iBAAX,EAA0B;AAH1B;;AAEG;SACH,YAAA;AACQ,UAAA,EAAA,GAAA,KAAA,KAAA,CAAA,OAAA;AAAA,UAAE,cAAA,GAAA,EAAA,CAAA,cAAF;AAAA,UAAkB,eAAA,GAAA,EAAA,CAAA,eAAlB;AAEN,aAAO,qBAAqB,CAAC,cAAD,EAAiB,eAAjB,CAA5B;AACD,KAJyB;oBAAA;;AAAA,GAA1B;;AAMO,EAAA,gBAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,YAAA;AACE,QAAI,KAAK,gBAAL,CAAsB,OAAtB,IAAiC,CAAC,KAAK,KAAL,CAAW,QAAjD,EAA2D;AACzD;AACA,WAAK,OAAL,CAAa,EAAb,CAAgB,KAAK,gBAAL,CAAsB,OAAtC,EAA+C,OAA/C,EAAwD,KAAK,iBAA7D,EAAgF,IAAhF;;AACA,UAAI,mBAAmB,KAAK,gBAAL,CAAsB,OAA7C,EAAsD;AACpD;AACA;AACA;AACA,aAAK,OAAL,CAAa,EAAb,CAAgB,KAAK,gBAAL,CAAsB,OAAtC,EAA+C,aAA/C,EAA8D,KAAK,cAAnE,EAAmF,IAAnF;AACD;AACF;AACF,GAXM;;AAaA,EAAA,gBAAA,CAAA,SAAA,CAAA,kBAAA,GAAP,UAA0B,SAA1B,EAA6D,SAA7D,EAAsF;AAAtF,QAAA,KAAA,GAAA,IAAA;;AACQ,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QACJ,aAAA,GAAA,EAAA,CAAA,aADI;AAAA,QAEJ,IAAA,GAAA,EAAA,CAAA,IAFI;AAAA,QAGJ,UAAA,GAAA,EAAA,CAAA,UAHI;AAAA,QAIJ,eAAA,GAAA,EAAA,CAAA,eAJI;AAAA,QAKO,eAAA,GAAA,EAAA,CAAA,OAAA,CAAA,eALP;AAOA,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QAAE,MAAA,GAAA,EAAA,CAAA,MAAF;AAAA,QAAU,6BAAA,GAAA,EAAA,CAAA,6BAAV,CAR8E,CAUpF;AACA;;AACA,QAAI,MAAM,KAAK,CAAC,SAAS,CAAC,MAAX,IAAqB,SAAS,CAAC,6BAAV,KAA4C,6BAAtE,CAAV,EAAgH;AAC9G;AACA,WAAK,MAAL,CAAY,UAAZ,CAAuB,YAAA;AAAM,eAAA,KAAI,CAAJ,eAAA,EAAA;AAAsB,OAAnD,EAAqD,CAArD;AACD,KAfmF,CAiBpF;AACA;AACA;;;AACA,QACE,KAAK,SAAL,OACC,MAAM,IACJ,SAAS,CAAC,MAAV,IACC,CAAC,MADF,IAEC,KAAK,qBAFN,IAGC,KAAK,SAAL,CAAe,OAHhB,IAIC,QAAQ,CAAC,aAAT,KAA2B,KAAK,SAAL,CAAe,OAAf,CAAuB,YANtD,CADF,EAQE;AACA,WAAK,KAAL,CAAW;AAAU;AAArB,QAA4C;AAAK;AAAjD;AACD,KA9BmF,CAgCpF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,QACE,KAAK,qBAAL,KACE,SAAS,CAAC,MAAV,IAAoB,CAAC,MAAtB,IACE,KAAK,SAAL,OACG,CAAC,MAAD,IACA,CAAC,KAAK,KAAL,CAAW,WADZ,IAEA,SAAS,CAAC,OAAV,CAAkB,eAFlB,IAGA,eAHA,IAIA,SAAS,CAAC,OAAV,CAAkB,eAAlB,CAAkC,CAAlC,MAAyC,eAAe,CAAC,CAAD,CAJzD,IAKC,CAAC,aALF,IAMC,IAAI,KAAK,SAAS,CAAC,IAPtB,CAFH,CADF,EAWE;AACA,WAAK,QAAL;AACD;;AAED,SAAK,0BAAL,CAAgC,SAAhC;;AAEA,QAAI,MAAM,IAAI,CAAC,SAAS,CAAC,MAArB,IAA+B,UAAnC,EAA+C;AAC7C,MAAA,UAAU;AACX;;AAED,QAAI,CAAC,MAAD,IAAW,SAAS,CAAC,MAArB,IAA+B,eAAnC,EAAoD;AAClD,MAAA,eAAe;AAChB;AACF,GA/DM;;AAiEA,EAAA,gBAAA,CAAA,SAAA,CAAA,oBAAA,GAAP,YAAA;AACE,SAAK,MAAL,CAAY,OAAZ;;AACA,SAAK,OAAL,CAAa,OAAb;AACD,GAHM,CAxKT,CA6KE;;;AACO,EAAA,gBAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;AACE,QAAM,EAAE,GAAG,KAAK,GAAhB;AACA,QAAM,cAAc,GAAG,EAAE,GAAG,QAA5B;AACM,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QACJ,SAAA,GAAA,EAAA,CAAA,SADI;AAAA,QAEJ,QAAA,GAAA,EAAA,CAAA,QAFI;AAAA,QAGJ,QAAA,GAAA,EAAA,CAAA,QAHI;AAAA,QAIJ,YAAA,GAAA,EAAA,CAAA,YAJI;AAAA,QAKJ,EAAA,GAAA,EAAA,CAAA,iBALI;AAAA,QAKJ,iBAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,kBAAA,GAAA,EALI;AAAA,QAMJ,EAAA,GAAA,EAAA,CAAA,aANI;AAAA,QAMJ,aAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,cAAA,GAAA,EANI;AAAA,QAOJ,EAAA,GAAA,EAAA,CAAA,YAPI;AAAA,QAOJ,YAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,aAAA,GAAA,EAPI;AAAA,QAQJ,EAAA,GAAA,EAAA,CAAA,YARI;AAAA,QAQJ,YAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,aAAA,GAAA,EARI;AAAA,QASJ,EAAA,GAAA,EAAA,CAAA,cATI;AAAA,QASJ,cAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,sBAAA,GAAA,EATI;AAAA,QAUJ,aAAA,GAAA,EAAA,CAAA,aAVI;AAAA,QAWJ,YAAA,GAAA,EAAA,CAAA,MAXI;AAAA,QAYJ,KAAA,GAAA,EAAA,CAAA,KAZI;AAAA,QAaJ,WAAA,GAAA,EAAA,CAAA,WAbI;AAAA,QAcJ,WAAA,GAAA,EAAA,CAAA,WAdI;AAAA,QAeJ,EAAA,GAAA,EAAA,CAAA,OAfI;AAAA,QAeO,qBAAA,GAAA,EAAA,CAAA,qBAfP;AAAA,QAe8B,eAAA,GAAA,EAAA,CAAA,eAf9B;AAAA,QAe+C,cAAA,GAAA,EAAA,CAAA,cAf/C;AAiBE,QAAA,MAAA,GAAA,KAAA,KAAA,CAAA,MAAA;AACR,SAAK,oBAAL,GAA4B,KAAK,gBAAL,EAA5B,CArBF,CAuBE;AACA;AACA;;AACA,QAAM,yBAAyB,GAAG,WAAW,GACzC,KAAK,4BAAL,CAAkC,eAAlC,EAAmD,cAAnD,EAAmE,qBAAnE,CADyC,GAEzC,SAFJ;AAIA,QAAM,QAAQ,GAAG,cAAc,CAAuC,KAAK,KAA5C,EAAmD,aAAnD,EAAkE,CAC/F,UAD+F,EAE/F,OAF+F,CAAlE,CAA/B;AAKA,QAAM,eAAe,GAAG,YAAY,IAAI,YAAY,CAAC,MAAb,GAAsB,CAAtC,GAA0C,IAA1C,GAAiD,KAAzE;AAEA,SAAK,WAAL,GAAmB,KAAK,KAAL,CAAW,aAAX,GACf,KAAK,KAAL,CAAW,aAAX,CACE,KADF,EAEE,CAAC,CAAC,MAFJ,EAGE,CAAC,CAAC,QAHJ,EAIE,CAAC,CAAC,QAJJ,EAKE,CAAC,CAAC,KAAK,SAAL,EALJ,EAME,CAAC,CAAC,aANJ,EAOE,CAAC,CAAC,eAPJ,EAQE,SARF,CADe,GAWf,aAAa,CACX,SAAS,CAAC,KAAD,EAAS,YAAT,CADE,EAEX,SAFW,EAGX,CAAC,CAAC,MAHS,EAIX,CAAC,CAAC,QAJS,EAKX,CAAC,CAAC,QALS,EAMX,CAAC,CAAC,KAAK,SAAL,EANS,EAOX,CAAC,CAAC,aAPS,EAQX,CAAC,CAAC,eARS,CAXjB;;AAsBA,QAAM,eAAe,GAAG,KAAK,sBAAL,CAA4B,yBAA5B,EAAuD,cAAvD,CAAxB;;AAEA,WACE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA,QAAA,CAAA,EAAA,EAAS,QAAT,EAAiB;AAAE,MAAA,GAAG,EAAE,KAAK,KAAL,CAAW,OAAX,CAAmB,aAA1B;AAAyC,MAAA,SAAS,EAAE,KAAK,WAAL,CAAiB;AAArE,KAAjB,CAAA,EACG,aAAa,CAAC;AAAE,MAAA,KAAK,EAAE,KAAK,KAAd;AAAqB,MAAA,yBAAyB,EAAA;AAA9C,KAAD,EAAmD,KAAK,cAAxD,CADhB,EAEG,eAFH,EAGG,CAAC,WAAW,IAAI,MAAhB,KACC,iBAAiB,CAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAEV,KAAK,KAFK,CAAA,EAEA;AACb,MAAA,YAAY,EAAA,YADC;AAEb,MAAA,YAAY,EAAA,YAFC;AAGb,MAAA,cAAc,EAAA,cAHD;AAIb,MAAA,OAAO,EAAE,cAAc,CAAC,GAAf,CAAmB,UAAC,IAAD,EAAO,KAAP,EAAY;AAAK,eAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAAM,IAAN,CAAA,EAAU;AAAE,UAAA,KAAK,EAAjB;AAAU,SAAV,CAAA;AAA2B,OAA/D,CAJI;AAKb,MAAA,SAAS,EAAE,KAAK;AALH,KAFA,CAAA,EASf,KAAK,kBATU,CAJrB,EAeE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA,QAAA,CAAA;AACE,MAAA,IAAI,EAAC,QADP;AACe,mBACH,QAFZ;AAEoB,qBACN,MAHd;AAIE,MAAA,EAAE,EAAE;AAJN,KAAA,EAKO,eAAe,GAAG;AAAE,MAAA,SAAS,EAAE,KAAK,WAAL,CAAiB;AAA9B,KAAH,GAAkD;AAAE,qBAAe;AAAjB,KALxE,CAAA,EAOG,YAAY,KAAK,SAAjB,GAA6B,YAA7B,GAA4C,EAP/C,CAfF,CADF;AA2BD,GAxFM;;AA0UC,EAAA,gBAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,UACE,mBADF,EAEE,cAFF,EAGE,KAHF,EAGe;AAEb,WAAO,mBAAmB,KAAK,IAAxB,IAAgC,mBAAmB,KAAK,SAAxD,GACH,mBADG,GAEH,iBAAiB,CAAC,cAAD,EAAiB,KAAjB,CAAjB,GACA,cAAc,CAAC,KAAD,CAAd,CAAsB,IADtB,GAEA,EAJJ;AAKD,GAVO;AAYR;;;AAGG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,4BAAA,GAAR,UACE,eADF,EAEE,cAFF,EAGE,qBAHF,EAG2C;AAEzC,QAAM,aAAa,GAAG,EAAtB;;AACA,SAAK,IAAI,GAAG,GAAG,CAAf,EAAkB,eAAe,IAAI,GAAG,GAAG,eAAe,CAAC,MAA3D,EAAmE,GAAG,EAAtE,EAA0E;AACxE,UAAM,KAAK,GAAW,eAAe,CAAC,GAAD,CAArC;AACA,MAAA,aAAa,CAAC,IAAd,CACE,iBAAiB,CAAC,cAAD,EAAiB,KAAjB,CAAjB,GACI,cAAc,CAAC,KAAD,CAAd,CAAsB,IAD1B,GAEI,iBAAiB,CAAC,qBAAD,CAHvB;AAKD;;AACO,QAAA,EAAA,GAAA,KAAA,KAAA,CAAA,oBAAA;AAAA,QAAA,oBAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,IAAA,GAAA,EAAA;AACR,WAAO,aAAa,CAAC,IAAd,CAAmB,oBAAnB,CAAP;AACD,GAhBO;AAiCR;;;AAGG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,+BAAA,GAAR,UAAwC,YAAxC,EAA4D;AAClD,QAAA,cAAA,GAAA,KAAA,KAAA,CAAA,OAAA,CAAA,cAAA;AACR,QAAI,gCAAgC,GAAG,CAAC,CAAxC,CAF0D,CAI1D;;AACA,QAAI,YAAY,KAAK,EAArB,EAAyB;AACvB,UAAM,KAAK,GAAG,cAAc,CACzB,GADW,CACP,UAAC,IAAD,EAAO,KAAP,EAAY;AAAK,eAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAAM,IAAN,CAAA,EAAU;AAAE,UAAA,KAAK,EAAjB;AAAU,SAAV,CAAA;AAAoB,OAD9B,EAEX,MAFW,CAEJ,UAAA,MAAA,EAAM;AAAI,eAAA,cAAc,CAAC,MAAD,CAAd,IAA0B,cAAc,CAAC,MAAD,CAAd,KAA1B,YAAA;AAAiE,OAFvE,CAAd,CADuB,CAKvB;;AACA,UAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;AACtB,QAAA,gCAAgC,GAAG,KAAK,CAAC,CAAD,CAAL,CAAS,KAA5C;AACD;;AAED,WAAK,eAAL,CAAqB,YAArB,EAAmC,gCAAnC,EAAqE,YAArE;;AACA;AACD,KAjByD,CAmB1D;;;AACA,QAAM,oBAAoB,GAAW,YAArC;AACA,IAAA,YAAY,GAAG,YAAY,CAAC,iBAAb,EAAf;AAEA,QAAI,wBAAwB,GAAG,EAA/B,CAvB0D,CAyB1D;;AACA,QAAI,KAAK,KAAL,CAAW,YAAX,KAA4B,IAAhC,EAAsC;AACpC;AACA,UAAM,KAAK,GAAG,cAAc,CACzB,GADW,CACP,UAAC,IAAD,EAAO,KAAP,EAAY;AAAK,eAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAAM,IAAN,CAAA,EAAU;AAAE,UAAA,KAAK,EAAjB;AAAU,SAAV,CAAA;AAAoB,OAD9B,EAEX,MAFW,CAGV,UAAA,MAAA,EAAM;AACJ,eAAA,cAAc,CAAC,MAAD,CAAd,IACA,cAAc,CAAC,MAAD,CAAd,CACG,iBADH,GAEG,OAFH,CAEW,YAFX,MAE6B,CAH7B;AAG8B,OAPtB,CAAd;;AASA,UAAI,KAAK,CAAC,MAAN,GAAe,CAAnB,EAAsB;AACpB;AACA,YAAM,IAAI,GAAW,cAAc,CAAC,KAAK,CAAC,CAAD,CAAN,CAAnC,CAFoB,CAIpB;;AACA,QAAA,wBAAwB,GAAG,IAAI,CAAC,iBAAL,OAA6B,YAA7B,GAA4C,IAA5C,GAAmD,EAA9E,CALoB,CAOpB;;AACA,QAAA,gCAAgC,GAAG,KAAK,CAAC,CAAD,CAAL,CAAS,KAA5C;AACD;AACF,KArBD,MAqBO;AACL;AACA,UAAM,KAAK,GAAG,cAAc,CACzB,GADW,CACP,UAAC,IAAD,EAAO,KAAP,EAAY;AAAK,eAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAAM,IAAN,CAAA,EAAU;AAAE,UAAA,KAAK,EAAjB;AAAU,SAAV,CAAA;AAAoB,OAD9B,EAEX,MAFW,CAEJ,UAAA,MAAA,EAAM;AAAI,eAAA,cAAc,CAAC,MAAD,CAAd,IAA0B,cAAc,CAAC,MAAD,CAAd,CAAuB,iBAAvB,OAA1B,YAAA;AAAqF,OAF3F,CAAd,CAFK,CAML;;AACA,UAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;AACtB,QAAA,gCAAgC,GAAG,KAAK,CAAC,CAAD,CAAL,CAAS,KAA5C;AACD;AACF,KAzDyD,CA2D1D;;;AACA,SAAK,eAAL,CAAqB,oBAArB,EAA2C,gCAA3C,EAA6E,wBAA7E;AACD,GA7DO;AA+DR;;;AAGG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,kCAAA,GAAR,UAA2C,YAA3C,EAA+D;AAA/D,QAAA,KAAA,GAAA,IAAA;;AACU,QAAA,cAAA,GAAA,KAAA,KAAA,CAAA,OAAA,CAAA,cAAA;AACF,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QAAE,mBAAA,GAAA,EAAA,CAAA,mBAAF;AAAA,QAAuB,6BAAA,GAAA,EAAA,CAAA,6BAAvB;;AAEN,QAAI,KAAK,KAAL,CAAW,YAAX,KAA4B,IAAhC,EAAsC;AACpC;AACA;AACA;AACA;AACA;AACA,UAAI,YAAY,KAAK,EAArB,EAAyB;AACvB;AACA;AACA;AACA;AACA,YAAI,KAAK,oBAAT,EAA+B;AAC7B,eAAK,MAAL,CAAY,YAAZ,CAAyB,KAAK,oBAA9B;;AACA,eAAK,oBAAL,GAA4B,SAA5B;AACA,UAAA,YAAY,GAAG,iBAAiB,CAAC,mBAAD,CAAjB,GAAyC,YAAxD;AACD;;AAED,YAAM,oBAAoB,GAAW,YAArC;AACA,QAAA,YAAY,GAAG,YAAY,CAAC,iBAAb,EAAf,CAZuB,CAcvB;;AACA,YAAM,KAAK,GAAG,cAAc,CACzB,GADW,CACP,UAAC,IAAD,EAAO,CAAP,EAAQ;AAAK,iBAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAAM,IAAN,CAAA,EAAU;AAAE,YAAA,KAAK,EAAjB;AAAU,WAAV,CAAA;AAAuB,SAD7B,EAGX,MAHW,CAGJ,UAAA,MAAA,EAAM;AAAI,iBAAA,cAAc,CAAC,MAAD,CAAd,IAA0B,MAAM,CAAC,IAAP,CAAY,iBAAZ,GAAgC,OAAhC,CAAwC,YAAxC,MAA1B,CAAA;AAAqF,SAH3F,CAAd,CAfuB,CAoBvB;;AACA,YAAI,KAAK,CAAC,MAAN,GAAe,CAAnB,EAAsB;AACpB,eAAK,eAAL,CAAqB,oBAArB,EAA2C,KAAK,CAAC,CAAD,CAAL,CAAS,KAApD,EAA2D,cAAc,CAAC,KAAK,CAAC,CAAD,CAAN,CAAzE;AACD,SAvBsB,CAyBvB;;;AACA,aAAK,oBAAL,GAA4B,KAAK,MAAL,CAAY,UAAZ,CAAuB,YAAA;AACjD,UAAA,KAAI,CAAC,oBAAL,GAA4B,SAA5B;AACD,SAF2B,EAEzB,kCAFyB,CAA5B;AAGA;AACD;AACF,KAzC4D,CA2C7D;AACA;AACA;;;AACA,QAAM,KAAK,GAAG,6BAA6B,IAAI,CAAjC,GAAqC,6BAArC,GAAqE,KAAK,sBAAL,EAAnF,CA9C6D,CAgD7D;AACA;AACA;AACA;;AACA,SAAK,wBAAL,CAA8B,KAA9B;AACD,GArDO;;AAuDA,EAAA,gBAAA,CAAA,SAAA,CAAA,sBAAA,GAAR,YAAA;;;AACU,QAAA,eAAA,GAAA,KAAA,KAAA,CAAA,OAAA,CAAA,eAAA;AACR,WAAO,CAAA,CAAA,EAAA,GAAA,eAAA,MAAe,IAAf,IAAe,EAAA,KAAA,KAAA,CAAf,GAAe,KAAA,CAAf,GAAe,EAAA,CAAE,MAAjB,IAA0B,eAAe,CAAC,CAAD,CAAzC,GAA+C,CAAC,CAAvD;AACD,GAHO;AAKR;;;;;;;AAOG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,uBAAA,GAAR,UAAgC,KAAhC,EAA+C,eAA/C,EAA+E;AACrE,QAAA,cAAA,GAAA,KAAA,KAAA,CAAA,OAAA,CAAA,cAAA;AAER,QAAI,QAAQ,GAAG,KAAK,GAAG,eAAvB;AAEA,IAAA,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,IAAI,CAAC,GAAL,CAAS,cAAc,CAAC,MAAf,GAAwB,CAAjC,EAAoC,QAApC,CAAZ,CAAX;;AAEA,QAAI,CAAC,iBAAiB,CAAC,cAAD,EAAiB,QAAjB,CAAtB,EAAkD;AAChD,aAAO,CAAC,CAAR;AACD;;AAED,QAAM,MAAM,GAAoB,cAAc,CAAC,QAAD,CAA9C;;AAEA,QAAI,CAAC,cAAc,CAAC,MAAD,CAAf,IAA2B,MAAM,CAAC,MAAP,KAAkB,IAAjD,EAAuD;AACrD;AACA,UACE,eAAe,KAAK,eAAe,CAAC,IAApC,KACE,QAAQ,GAAG,CAAX,IAAgB,eAAe,GAAG,eAAe,CAAC,IAAnD,IACE,QAAQ,IAAI,CAAZ,IAAiB,QAAQ,GAAG,cAAc,CAAC,MAA3C,IAAqD,eAAe,GAAG,eAAe,CAAC,IAF1F,CADF,EAIE;AACA,QAAA,QAAQ,GAAG,KAAK,uBAAL,CAA6B,QAA7B,EAAuC,eAAvC,CAAX;AACD,OAND,MAMO;AACL;AACA,eAAO,KAAP;AACD;AACF,KAzB4E,CA2B7E;;;AACA,WAAO,QAAP;AACD,GA7BO;AA+BR;;;;;AAKG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,UACE,KADF,EAEE,uBAFF,EAGE,eAHF,EAGyD;AAAvD,QAAA,eAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,eAAA,GAAmC,eAAe,CAAC,IAAnD;AAAuD;;AAEjD,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QACJ,QAAA,GAAA,EAAA,CAAA,QADI;AAAA,QAEJ,qBAAA,GAAA,EAAA,CAAA,qBAFI;AAAA,QAGJ,EAAA,GAAA,EAAA,CAAA,OAHI;AAAA,QAGO,cAAA,GAAA,EAAA,CAAA,eAHP;AAAA,QAGwC,cAAA,GAAA,EAAA,CAAA,cAHxC,CAFiD,CAQvD;;AACA,QAAI,eAAe,GAAG,cAAc,GAAG,cAAc,CAAC,KAAf,EAAH,GAA4B,EAAhE,CATuD,CAWvD;AACA;;AACA,IAAA,KAAK,GAAG,KAAK,uBAAL,CAA6B,KAA7B,EAAoC,eAApC,CAAR;;AAEA,QAAI,CAAC,iBAAiB,CAAC,cAAD,EAAiB,KAAjB,CAAtB,EAA+C;AAC7C;AACD,KAjBsD,CAmBvD;AACA;;;AACA,QACE,KAAK,KAAL,CAAW,WAAX,IACA,eAAe,CAAC,MAAhB,GAAyB,CADzB,IAEC,eAAe,CAAC,MAAhB,KAA2B,CAA3B,IAAgC,eAAe,CAAC,CAAD,CAAf,KAAuB,KAH1D,EAIE;AACA,UAAM,MAAM,GAAA,QAAA,CAAA,EAAA,EAAyB,cAAc,CAAC,KAAD,CAAvC,CAAZ,CADA,CAEA;;;AACA,UAAI,CAAC,MAAD,IAAW,MAAM,CAAC,QAAtB,EAAgC;AAC9B;AACD;;AACD,UAAI,KAAK,KAAL,CAAW,WAAf,EAA4B;AAC1B;AACA;AACA,QAAA,MAAM,CAAC,QAAP,GAAkB,MAAM,CAAC,QAAP,KAAoB,SAApB,GAAgC,CAAC,MAAM,CAAC,QAAxC,GAAmD,eAAe,CAAC,OAAhB,CAAwB,KAAxB,IAAiC,CAAtG;;AACA,YAAI,MAAM,CAAC,QAAP,IAAmB,eAAe,CAAC,OAAhB,CAAwB,KAAxB,IAAiC,CAAxD,EAA2D;AACzD,UAAA,eAAe,CAAC,IAAhB,CAAqB,KAArB;AACD,SAFD,MAEO,IAAI,CAAC,MAAM,CAAC,QAAR,IAAoB,eAAe,CAAC,OAAhB,CAAwB,KAAxB,KAAkC,CAA1D,EAA6D;AAClE,UAAA,eAAe,GAAG,eAAe,CAAC,MAAhB,CAAuB,UAAC,KAAD,EAAc;AAAK,mBAAA,KAAK,KAAL,KAAA;AAAe,WAAzD,CAAlB;AACD;AACF,OATD,MASO;AACL,QAAA,eAAe,CAAC,CAAD,CAAf,GAAqB,KAArB;AACD;;AAED,MAAA,uBAAuB,CAAC,OAAxB,GAnBA,CAqBA;;AACA,UAAI,KAAK,KAAL,CAAW,WAAX,IAA0B,KAAK,KAAL,CAAW,WAAX,KAA2B,IAAzD,EAA+D;AAC7D;AACA,YAAI,KAAK,gBAAL,IAAyB,qBAA7B,EAAoD;AAClD,UAAA,qBAAqB;AACrB,eAAK,gBAAL,GAAwB,KAAxB;AACD;;AACD,YAAI,QAAJ,EAAc;AACZ,UAAA,QAAQ,CAAC,uBAAD,EAA0B,MAA1B,EAAkC,KAAlC,EAAyC,SAAzC,CAAR;AACD;AACF,OATD,MASO;AACL;AACA,YAAM,cAAc,GAAG,cAAc,CAAC,KAAf,EAAvB;AACA,QAAA,cAAc,CAAC,KAAD,CAAd,GAAwB,MAAxB,CAHK,CAKL;;AACA,aAAK,KAAL,CAAW,OAAX,CAAmB,kBAAnB,CAAsC,eAAtC;AACA,aAAK,KAAL,CAAW,OAAX,CAAmB,iBAAnB,CAAqC,cAArC,EAPK,CASL;;AACA,YAAI,KAAK,gBAAL,IAAyB,qBAA7B,EAAoD;AAClD,UAAA,qBAAqB;AACrB,eAAK,gBAAL,GAAwB,KAAxB;AACD;;AAED,YAAI,QAAJ,EAAc;AACZ,UAAA,QAAQ,CAAC,uBAAD,EAA0B,MAA1B,EAAkC,KAAlC,EAAyC,SAAzC,CAAR;AACD;AACF;AACF;;AACD,QAAI,KAAK,KAAL,CAAW,WAAX,IAA0B,KAAK,KAAL,CAAW,MAAzC,EAAiD;AAC/C;AACD,KA9EsD,CA+EvD;;;AACA,SAAK,iBAAL;AACD,GApFO;AA8KR;;AAEG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,mBAAA,GAAR,UAA4B,uBAA5B,EAA8E;;;AACtE,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QAAE,QAAA,GAAA,EAAA,CAAA,QAAF;AAAA,QAAY,aAAA,GAAA,EAAA,CAAA,aAAZ;AAAA,QAA2B,YAAA,GAAA,EAAA,CAAA,YAA3B;AAAA,QAAyC,WAAA,GAAA,EAAA,CAAA,WAAzC;AAAA,QAAsD,OAAA,GAAA,EAAA,CAAA,OAAtD;AACE,QAAA,cAAA,GAAA,OAAA,CAAA,cAAA;AACF,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QAAE,mBAAA,GAAA,EAAA,CAAA,mBAAF;AAAA,QAAuB,6BAAA,GAAA,EAAA,CAAA,6BAAvB;AAAA,QAAsD,oCAAA,GAAA,EAAA,CAAA,oCAAtD;AACA,QAAA,eAAA,GAAA,KAAA,KAAA,CAAA,OAAA,CAAA,eAAA,CAJsE,CAM5E;AACA;;AACA,QAAI,KAAK,2BAAT,EAAsC;AACpC;AACD,KAV2E,CAY5E;;;AACA,QAAI,aAAJ,EAAmB;AACjB;AACA;AACA,UAAI,mBAAmB,KAAK,IAAxB,IAAgC,mBAAmB,KAAK,SAA5D,EAAuE;AACrE;AACA,YAAI,oCAAoC,IAAI,CAA5C,EAA+C;AAC7C,eAAK,iBAAL,CAAuB,oCAAvB,EAA6D,uBAA7D;;AACA,eAAK,iBAAL;AACD;;AAED;AACD,OAXgB,CAajB;;;AACA,UAAI,iBAAiB,CAAC,cAAD,EAAiB,6BAAjB,CAArB,EAAsE;AACpE,YAAM,iBAAiB,GAAG,cAAc,CAAC,cAAc,CAAC,6BAAD,CAAf,CAAd,CAA8D,iBAA9D,EAA1B;AACA,YAAM,QAAQ,GAAG,KAAK,SAAL,CAAe,OAAhC,CAFoE,CAIpE;AACA;AACA;AACA;;AACA,YACE,mBAAmB,CAAC,iBAApB,OAA4C,iBAA5C,IACC,YAAY,IACX,iBAAiB,CAAC,OAAlB,CAA0B,mBAAmB,CAAC,iBAApB,EAA1B,MAAuE,CADxE,KACyE,CAAA,EAAA,GACxE,QADwE,MAChE,IADgE,IAChE,EAAA,KAAA,KAAA,CADgE,GAChE,KAAA,CADgE,GAChE,EAAA,CAAE,eAFX,KAGC,mBAAmB,CAAC,MAApB,IAA8B,QAAQ,CAAC,YAAT,GAAyB,QAAQ,CAAC,cAAhE,MACE,iBAAiB,CAAC,MALtB,IAMA,CAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,QAAA,MAAQ,IAAR,IAAQ,EAAA,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAQ,EAAA,CAAE,YAAV,MAAsB,IAAtB,IAAsB,EAAA,KAAA,KAAA,CAAtB,GAAsB,KAAA,CAAtB,GAAsB,EAAA,CAAE,KAAF,CAAQ,iBAAR,EAAtB,MAAsD,iBAPxD,EAQE;AACA,eAAK,iBAAL,CAAuB,6BAAvB,EAAsD,uBAAtD;;AACA,cAAI,WAAW,IAAI,KAAK,KAAL,CAAW,MAA9B,EAAsC;AACpC;AACD;;AACD,eAAK,iBAAL;;AACA;AACD;AACF;;AAED,UAAI,QAAJ,EAAc;AACZ,YAAI,QAAJ,EAAc;AACZ;AACA,UAAA,QAAQ,CAAC,uBAAD,EAA0B,SAA1B,EAAqC,SAArC,EAAgD,mBAAhD,CAAR;AACD;AACF,OALD,MAKO;AACL;AACA,YAAM,SAAS,GAAoB;AACjC,UAAA,GAAG,EAAE,mBAAmB,IAAI,KAAK,EADA;AAEjC,UAAA,IAAI,EAAE,iBAAiB,CAAC,mBAAD;AAFU,SAAnC,CAFK,CAML;;AACA,YAAI,WAAJ,EAAiB;AACf,UAAA,SAAS,CAAC,QAAV,GAAqB,IAArB;AACD;;AACD,YAAM,UAAU,GAAsB,cAAc,CAAC,MAAf,CAAsB,CAAC,SAAD,CAAtB,CAAtC;;AACA,YAAI,eAAJ,EAAqB;AACnB,cAAI,CAAC,WAAL,EAAkB;AAChB,YAAA,eAAe,GAAG,EAAlB;AACD;;AACD,UAAA,eAAe,CAAC,IAAhB,CAAqB,UAAU,CAAC,MAAX,GAAoB,CAAzC;AACD;;AACD,QAAA,OAAO,CAAC,iBAAR,CAA0B,UAA1B;AACA,QAAA,OAAO,CAAC,kBAAR,CAA2B,eAA3B;AACD;AACF,KAjED,MAiEO,IAAI,6BAA6B,IAAI,CAArC,EAAwC;AAC7C;AACA;AACA,WAAK,iBAAL,CAAuB,6BAAvB,EAAsD,uBAAtD;AACD,KAJM,MAIA,IAAI,oCAAoC,IAAI,CAA5C,EAA+C;AACpD;AACA,WAAK,iBAAL,CAAuB,oCAAvB,EAA6D,uBAA7D;AACD,KArF2E,CAuF5E;;;AACA,SAAK,iBAAL;AACD,GAzFO;;AAkJA,EAAA,gBAAA,CAAA,SAAA,CAAA,sBAAA,GAAR,YAAA;AACE;AACA;AACA;AACA;AACA,SAAK,aAAL,GAAqB,KAArB;AACD,GANO,CA5hCV,CAomCE;;;AACQ,EAAA,gBAAA,CAAA,SAAA,CAAA,gBAAA,GAAR,UAAyB,IAAzB,EAA8C;AACpC,QAAA,KAAA,GAAA,IAAA,CAAA,KAAA;AAAA,QAAO,GAAA,GAAA,IAAA,CAAA,GAAP;;AAER,QAAI,KAAK,IAAI,KAAK,GAAG,CAArB,EAAwB;AACtB,aAAO,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AAAK,QAAA,IAAI,EAAC,WAAV;AAAsB,QAAA,GAAG,EAAE,GAA3B;AAAgC,QAAA,SAAS,EAAE,KAAK,WAAL,CAAiB;AAA5D,OAAA,CAAP;AACD;;AACD,WAAO,IAAP;AACD,GAPO;;AASA,EAAA,gBAAA,CAAA,SAAA,CAAA,aAAA,GAAR,UAAsB,IAAtB,EAA2C;AACjC,QAAA,EAAA,GAAA,KAAA,KAAA,CAAA,cAAA;AAAA,QAAA,cAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,sBAAA,GAAA,EAAA;AAER,WACE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AAAK,MAAA,GAAG,EAAE,IAAI,CAAC,GAAf;AAAoB,MAAA,SAAS,EAAE,KAAK,WAAL,CAAiB;AAAhD,KAAA,EACG,cAAc,CAAC,IAAD,EAAO,KAAK,sBAAZ,CADjB,CADF;AAKD,GARO;AA2FR;;;;;;;;;;;AAWK;;;AACG,EAAA,gBAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,UAA0B,KAA1B,EAAmD;AACzC,QAAA,oCAAA,GAAA,KAAA,KAAA,CAAA,oCAAA,CADyC,CAGjD;AACA;;AACA,QAAI,oCAAoC,KAAK,WAAW,CAAC,QAAzD,EAAmE;AACjE,aAAO,KAAP;AACD;;AAED,WAAO,KAAK,wBAAL,CAA8B;AAAK;AAAnC,UAAkE,KAAlE,GAA0E,IAA1E,GAAiF,KAAxF;AACD,GAVO;;AAYA,EAAA,gBAAA,CAAA,SAAA,CAAA,gBAAA,GAAR,UAAyB,KAAzB,EAAkD;AAChD,QAAI,KAAK,KAAL,CAAW,WAAX,IAA0B,KAAK,KAAK,SAApC,IAAiD,KAAK,KAAL,CAAW,OAAX,CAAmB,eAAxE,EAAyF;AACvF,UAAI,kBAAkB,GAAG,CAAC,CAA1B;AAEA,MAAA,kBAAkB,GAAG,KAAK,KAAL,CAAW,OAAX,CAAmB,eAAnB,CAAmC,OAAnC,CAA2C,KAA3C,CAArB;AACA,aAAO,kBAAkB,IAAI,CAA7B;AACD;;AACD,WAAO,KAAP;AACD,GARO;AAUR;;;;AAIG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,wBAAA,GAAR,UAAiC,0BAAjC,EAAoE;AAC5D,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QAAE,oCAAA,GAAA,EAAA,CAAA,oCAAF;AAAA,QAAwC,6BAAA,GAAA,EAAA,CAAA,6BAAxC;AAAA,QAAuE,mBAAA,GAAA,EAAA,CAAA,mBAAvE;AAEN,WAAO,oCAAoC,IAAI,CAAxC,GACH,oCADG,GAEH,6BAA6B,IAAI,CAAjC,IACC,0BAA0B,IAAI,mBAAmB,KAAK,IAAtD,IAA8D,mBAAmB,KAAK,SADvF,GAEA,6BAFA,GAGA,KAAK,KAAL,CAAW,WAAX,GACA,CADA,GAEA,KAAK,sBAAL,EAPJ;AAQD,GAXO;AAqCR;;AAEG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,eAAA,GAAR,YAAA;AACQ,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QAAE,cAAA,GAAA,EAAA,CAAA,cAAF;AAAA,QAAkB,mBAAA,GAAA,EAAA,CAAA,mBAAlB;AAEA,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QAAE,6BAAA,GAAA,EAAA,CAAA,6BAAF;AAAA,QAAiC,mBAAA,GAAA,EAAA,CAAA,mBAAjC;;AAEN,QAAI,cAAJ,EAAoB;AAClB;AACA,MAAA,cAAc,CACZ,6BAA6B,IAAI,CAAjC,IAAsC,mBAAmB,KAAK,EAA9D,GACI,6BADJ,GAEI,KAAK,sBAAL,EAHQ,CAAd;AAKD,KAPD,MAOO,IAAI,KAAK,gBAAL,CAAsB,OAAtB,IAAiC,KAAK,gBAAL,CAAsB,OAAtB,CAA8B,YAAnE,EAAiF;AACtF;AACA,UAAI,mBAAJ,EAAyB;AACvB,aAAK,gBAAL,CAAsB,OAAtB,CAA8B,YAA9B,CAA2C,cAA3C,CAA0D,IAA1D;AACD,OAFD,MAEO;AACL,YAAI,UAAU,GAAG,IAAjB;;AAEA,YAAI,KAAK,aAAL,CAAmB,OAAnB,IAA8B,KAAK,aAAL,CAAmB,OAAnB,CAA2B,YAA7D,EAA2E;AACzE,cAAM,oBAAoB,GAAG,KAAK,aAAL,CAAmB,OAAnB,CAA2B,YAA3B,CAAwC,qBAAxC,EAA7B;;AACA,cAAM,mBAAmB,GAAG,KAAK,gBAAL,CAAsB,OAAtB,CAA8B,YAA9B,CAA2C,qBAA3C,EAA5B,CAFyE,CAIzE;;;AACA,cACE,oBAAoB,CAAC,GAArB,IAA4B,mBAAmB,CAAC,GAAhD,IACA,oBAAoB,CAAC,GAArB,GAA2B,oBAAoB,CAAC,MAAhD,IACE,mBAAmB,CAAC,GAApB,GAA0B,mBAAmB,CAAC,MAHlD,EAIE;AACA;AACD,WAXwE,CAazE;;;AACA,cACE,oBAAoB,CAAC,GAArB,GAA2B,oBAAoB,CAAC,MAAhD,IACA,mBAAmB,CAAC,GAApB,GAA0B,mBAAmB,CAAC,MAFhD,EAGE;AACA,YAAA,UAAU,GAAG,KAAb;AACD;AACF;;AAED,aAAK,gBAAL,CAAsB,OAAtB,CAA8B,YAA9B,CAA2C,cAA3C,CAA0D,UAA1D;AACD;AACF;AACF,GA5CO;AAmDR;;;;AAIG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,YAAA,GAAR,UAAqB,IAArB,EAA0C;AAA1C,QAAA,KAAA,GAAA,IAAA;;AACU,QAAA,WAAA,GAAA,KAAA,KAAA,CAAA,WAAA;AACA,QAAA,KAAA,GAAA,IAAA,CAAA,KAAA;AACR,WAAO,UAAC,EAAD,EAA0B;AAC/B;AACA,UAAI,CAAC,KAAI,CAAC,KAAL,CAAW,WAAhB,EAA6B;AAC3B;AACA,QAAA,KAAI,CAAC,SAAL,CAAe,OAAf,IAA0B,KAAI,CAAC,SAAL,CAAe,OAAf,CAAuB,KAAvB,EAA1B;;AACA,QAAA,KAAI,CAAC,QAAL,CAAc;AACZ,UAAA,MAAM,EAAE;AADI,SAAd;AAGD,OAR8B,CAU/B;AACA;;;AACA,MAAA,WAAW,IAAI,WAAW,CAAC,EAAD,EAAK,IAAL,EAAW,KAAX,CAA1B;;AACA,MAAA,KAAI,CAAC,iBAAL,CAAuB,KAAvB,EAAwC,EAAxC;AACD,KAdD;AAeD,GAlBO;AA4CR;;;;;AAKG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,mBAAA,GAAR,YAAA;AACU,QAAA,cAAA,GAAA,KAAA,KAAA,CAAA,OAAA,CAAA,cAAA;;AACR,SAAK,iBAAL;;AAEA,QAAM,aAAa,GAAW,KAAK,sBAAL,EAA9B;;AACA,QAAI,aAAa,GAAG,CAAhB,IAAqB,aAAa,GAAG,cAAc,CAAC,MAAxD,EAAgE;AAC9D,WAAK,KAAL,CAAW,OAAX,CAAmB,wBAAnB,CAA4C,cAAc,CAAC,aAAD,CAAd,CAA8B,IAA1E;AACD,KAFD,MAEO,IAAI,KAAK,KAAL,CAAW,IAAf,EAAqB;AAC1B;AACA,WAAK,KAAL,CAAW,OAAX,CAAmB,wBAAnB,CAA4C,KAAK,KAAL,CAAW,IAAvD;AACD;AACF,GAXO;AAaR;;AAEG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,YAAA;AACE,SAAK,2BAAL,GAAmC,IAAnC;AAEA,SAAK,KAAL,CAAW,OAAX,CAAmB,wBAAnB,CAA4C,SAA5C;AACA,SAAK,QAAL,CACE;AACE,MAAA,mBAAmB,EAAE,SADvB;AAEE,MAAA,6BAA6B,EAAE,CAAC,CAFlC;AAGE,MAAA,oCAAoC,EAAE,WAAW,CAAC;AAHpD,KADF,EAME,KAAK,wBANP;AAQD,GAZO;AAkBR;;;;;AAKG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,eAAA,GAAR,UACE,mBADF,EAEE,6BAFF,EAGE,qBAHF,EAGgC;AAD9B,QAAA,6BAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,6BAAA,GAAA,CAAyC,CAAzC;AAA0C;;AAG1C,QAAI,KAAK,2BAAT,EAAsC;AACpC;AACD;;AAED,SAAK,KAAL,CAAW,OAAX,CAAmB,wBAAnB,CAA4C,qBAA5C;AACA,SAAK,QAAL,CAAc;AACZ,MAAA,mBAAmB,EAAE,iBAAiB,CAAC,mBAAD,CAD1B;AAEZ,MAAA,6BAA6B,EAAE,6BAFnB;AAGZ,MAAA,oCAAoC,EAAE,WAAW,CAAC;AAHtC,KAAd;AAKD,GAfO;AAiBR;;;AAGG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,wBAAA,GAAR,UAAiC,KAAjC,EAA8C;AACpC,QAAA,cAAA,GAAA,KAAA,KAAA,CAAA,OAAA,CAAA,cAAA;;AAER,QAAI,KAAK,IAAI,CAAT,IAAc,KAAK,GAAG,cAAc,CAAC,MAAzC,EAAiD;AAC/C,UAAM,MAAM,GAAG,cAAc,CAAC,KAAD,CAA7B;;AACA,WAAK,eAAL,CAAqB,cAAc,CAAC,MAAD,CAAnC,EAA6C,KAA7C,EAAoD,cAAc,CAAC,MAAD,CAAlE;AACD,KAHD,MAGO;AACL,WAAK,iBAAL;AACD;AACF,GATO;AAWR;;;;AAIG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,oCAAA,GAAR,UAA6C,KAA7C,EAA4D,eAA5D,EAA4F;AAClF,QAAA,cAAA,GAAA,KAAA,KAAA,CAAA,OAAA,CAAA,cAAA,CADkF,CAG1F;;AACA,QAAI,eAAe,KAAK,eAAe,CAAC,OAApC,IAA+C,KAAK,IAAI,cAAc,CAAC,MAAf,GAAwB,CAApF,EAAuF;AACrF,MAAA,KAAK,GAAG,CAAC,CAAT;AACD,KAFD,MAEO,IAAI,eAAe,KAAK,eAAe,CAAC,QAApC,IAAgD,KAAK,IAAI,CAA7D,EAAgE;AACrE,MAAA,KAAK,GAAG,cAAc,CAAC,MAAvB;AACD,KARyF,CAU1F;;;AACA,QAAM,WAAW,GAAG,KAAK,uBAAL,CAA6B,KAA7B,EAAoC,eAApC,CAApB,CAX0F,CAa1F;AACA;AACA;AACA;;;AACA,QAAI,KAAK,KAAK,WAAd,EAA2B;AACzB,UAAI,eAAe,KAAK,eAAe,CAAC,OAAxC,EAAiD;AAC/C,QAAA,KAAK,GAAG,KAAK,uBAAL,CAA6B,CAAC,CAA9B,EAAiC,eAAjC,CAAR;AACD,OAFD,MAEO,IAAI,eAAe,KAAK,eAAe,CAAC,QAAxC,EAAkD;AACvD,QAAA,KAAK,GAAG,KAAK,uBAAL,CAA6B,cAAc,CAAC,MAA5C,EAAoD,eAApD,CAAR;AACD;AACF,KAND,MAMO;AACL,MAAA,KAAK,GAAG,WAAR;AACD;;AAED,QAAI,iBAAiB,CAAC,cAAD,EAAiB,KAAjB,CAArB,EAA8C;AAC5C,WAAK,wBAAL,CAA8B,KAA9B;AACD;AACF,GA9BO;;AAgCA,EAAA,gBAAA,CAAA,SAAA,CAAA,0BAAA,GAAR,UAAmC,SAAnC,EAA4D;AAClD,QAAA,qBAAA,GAAA,KAAA,KAAA,CAAA,qBAAA;;AAER,QAAI,CAAC,qBAAL,EAA4B;AAC1B;AACD;;AAEO,QAAA,cAAA,GAAA,KAAA,KAAA,CAAA,OAAA,CAAA,cAAA;AACF,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QAAE,mBAAA,GAAA,EAAA,CAAA,mBAAF;AAAA,QAAuB,6BAAA,GAAA,EAAA,CAAA,6BAAvB;AAAA,QAAsD,oCAAA,GAAA,EAAA,CAAA,oCAAtD;AAEN,QAAI,eAAe,GAAuB,SAA1C;AACA,QAAI,eAAe,GAAuB,SAA1C;;AAEA,QACE,oCAAoC,KAAK,SAAS,CAAC,oCAAnD,IACA,iBAAiB,CAAC,cAAD,EAAiB,oCAAjB,CAFnB,EAGE;AACA;AACA,MAAA,eAAe,GAAG,oCAAlB;AACD,KAND,MAMO,IACL,6BAA6B,KAAK,SAAS,CAAC,6BAA5C,IACA,iBAAiB,CAAC,cAAD,EAAiB,6BAAjB,CAFZ,EAGL;AACA;AACA,MAAA,eAAe,GAAG,6BAAlB;AACD,KANM,MAMA,IAAI,mBAAmB,KAAK,SAAS,CAAC,mBAAtC,EAA2D;AAChE;AACA,MAAA,eAAe,GAAG,mBAAlB;AACD,KA5ByD,CA8B1D;;;AACA,QAAI,eAAe,KAAK,SAApB,IAAiC,eAAe,KAAK,SAArD,IAAkE,KAAK,gBAA3E,EAA6F;AAC3F,MAAA,qBAAqB,CACnB,eAAe,KAAK,SAApB,GAAgC,cAAc,CAAC,eAAD,CAA9C,GAAkE,SAD/C,EAEnB,eAFmB,EAGnB,eAHmB,CAArB;AAKA,WAAK,gBAAL,GAAwB,eAAe,KAAK,SAApB,IAAiC,eAAe,KAAK,SAA7E;AACD;AACF,GAvCO;AAyCR;;AAEG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,4BAAA,GAAR,UAAqC,MAArC,EAAsD,oBAAtD,EAAmF;AACjF,SAAK,qBAAL,GAA6B,oBAA7B;AACA,SAAK,QAAL,CAAc;AACZ,MAAA,MAAM,EAAE;AADI,KAAd;AAGD,GALO;;AAmPA,EAAA,gBAAA,CAAA,SAAA,CAAA,mBAAA,GAAR,UAA4B,KAA5B,EAAyC;AACvC,QAAI,KAAK,uBAAL,EAAJ,EAAoC;AAClC;AACD;;AAED,SAAK,QAAL,CAAc;AACZ,MAAA,oCAAoC,EAAE;AAD1B,KAAd;AAGD,GARO;;AAUA,EAAA,gBAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,UAA2B,KAA3B,EAAwC;AACtC,SAAK,aAAL,GAAqB,IAArB;;AAEA,QAAI,CAAC,KAAK,aAAN,IAAuB,KAAK,KAAL,CAAW,oCAAX,KAAoD,KAA/E,EAAsF;AACpF;AACD;;AAED,SAAK,QAAL,CAAc;AACZ,MAAA,oCAAoC,EAAE;AAD1B,KAAd;AAGD,GAVO;;AA4BA,EAAA,gBAAA,CAAA,SAAA,CAAA,uBAAA,GAAR,YAAA;AACE,WAAO,CAAC,KAAK,aAAN,IAAuB,CAAC,KAAK,aAApC;AACD,GAFO;AAIR;;;AAGG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,wBAAA,GAAR,UAAiC,EAAjC,EAAuF;AACrF;AACA;AACA,QAAI,KAAK,KAAL,CAAW,QAAf,EAAyB;AACvB,UAAI,KAAK,KAAL,CAAW,MAAf,EAAuB;AACrB,aAAK,QAAL,CAAc;AAAE,UAAA,MAAM,EAAE;AAAV,SAAd;AACD,OAHsB,CAKvB;AACA;;;AACA,UACE,EAAE,KAAK,IAAP,IACA;AACA,MAAA,EAAE,CAAC,KAAH,KAAa,QAAQ,CAAC,GAFtB,IAGA;AACA,MAAA,EAAE,CAAC,KAAH,KAAa,QAAQ,CAAC,MAJtB,MAKA;AACC,MAAA,EAAE,CAAC,KAAH,GAAW;AAAI;AAAf,SAA2B,EAAE,CAAC,KAAH,GAAW,GANvC;AAM4C;AAP9C,QAQE;AACA,UAAA,EAAE,CAAC,eAAH;AACA,UAAA,EAAE,CAAC,cAAH;AACD;AACF;AACF,GAvBO;;AAkEA,EAAA,gBAAA,CAAA,SAAA,CAAA,2BAAA,GAAR,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA,CAAA,CACE;AACA;;;AACA,QAAI,KAAK,mBAAL,KAA6B,SAAjC,EAA4C;AAC1C,WAAK,MAAL,CAAY,YAAZ,CAAyB,KAAK,mBAA9B;;AACA,WAAK,mBAAL,GAA2B,SAA3B;AACD;;AACD,SAAK,gBAAL,GAAwB,IAAxB;AAEA,SAAK,mBAAL,GAA2B,KAAK,MAAL,CAAY,UAAZ,CAAuB,YAAA;AAChD,MAAA,KAAI,CAAC,gBAAL,GAAwB,KAAxB;AACA,MAAA,KAAI,CAAC,mBAAL,GAA2B,SAA3B;AACD,KAH0B,EAGxB,cAHwB,CAA3B;AAID,GAbO;AAeR;;;AAGG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,qBAAA,GAAR,YAAA;AACU,QAAA,2BAAA,GAAA,KAAA,KAAA,CAAA,qBAAA;AACR,WAAO,wBAAwB,CAAC,KAAK,KAAL,CAAW,KAAZ,EAAoB,2BAApB,CAA/B;AACD,GAHO;AAKR;;;AAGG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,uBAAA,GAAR,UAAgC,IAAhC,EAAqD;AAC3C,QAAA,yBAAA,GAAA,KAAA,KAAA,CAAA,oBAAA;AACA,QAAA,4BAAA,GAAA,IAAA,CAAA,MAAA;AAER,WAAO,eAAe,CACpB,KAAK,KAAL,CAAW,KADS,EAEpB,yBAFoB,EAGpB,4BAHoB,EAIpB,KAAK,gBAAL,CAAsB,IAAtB,CAJoB,EAKpB,IAAI,CAAC,MALe,CAAtB;AAOD,GAXO;AAaR;;;;AAIG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,6BAAA,GAAR,YAAA;;;AACU,QAAA,eAAA,GAAA,KAAA,KAAA,CAAA,OAAA,CAAA,eAAA;AACF,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QAAE,MAAA,GAAA,EAAA,CAAA,MAAF;AAAA,QAAU,6BAAA,GAAA,EAAA,CAAA,6BAAV;AACN,QAAI,cAAc,GAAG,MAAM,KAAA,CAAA,EAAA,GAAI,eAAJ,MAAmB,IAAnB,IAAmB,EAAA,KAAA,KAAA,CAAnB,GAAmB,KAAA,CAAnB,GAAmB,EAAA,CAAE,MAArB,CAAN,GAAoC,KAAK,GAAL,GAAW,OAAX,GAAqB,eAAe,CAAC,CAAD,CAAxE,GAA8E,SAAnG;;AACA,QAAI,MAAM,IAAI,KAAK,SAAL,EAAV,IAA8B,6BAA6B,KAAK,CAAC,CAArE,EAAwE;AACtE,MAAA,cAAc,GAAG,KAAK,GAAL,GAAW,OAAX,GAAqB,6BAAtC;AACD;;AACD,WAAO,cAAP;AACD,GARO;AAUR;;;;AAIG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,yBAAA,GAAR,YAAA;AACE,QAAM,YAAY,GAAG,CAAC,KAAK,KAAL,CAAW,QAAZ,IAAwB,KAAK,KAAL,CAAW,YAAX,KAA4B,IAAzE;AACA,WAAO,YAAY,GAAI,KAAK,KAAL,CAAW,aAAX,GAA2B,QAA3B,GAAsC,MAA1C,GAAoD,MAAvE;AACD,GAHO;;AAKA,EAAA,gBAAA,CAAA,SAAA,CAAA,gBAAA,GAAR,UAAyB,IAAzB,EAA8C;AAC5C,WAAO,IAAI,IAAI,IAAI,CAAC,KAAL,KAAe,KAAK,KAAL,CAAW,6BAAzC;AACD,GAFO;AAIR;;AAEG;;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,SAAA,GAAR,YAAA;AACE,WAAO,KAAK,KAAL,CAAW,UAAX,KAA0B,MAAjC;AACD,GAFO;;AAv8DJ,EAAA,gBAAgB,GAAA,UAAA,CAAA,CADrB,YAAY,CAAC,UAAD,EAAa,CAAC,OAAD,EAAU,QAAV,CAAb,EAAkC,IAAlC,CACS,CAAA,EAAhB,gBAAgB,CAAhB;AA08DN,SAAA,gBAAA;AAAC,CA18DD,CAA+B,KAAK,CAAC,SAArC,CAAA;AA48DA;;;;;AAKG;;;AACH,SAAS,kBAAT,CACE,OADF,EAEE,YAFF,EAE+C;AAE7C,MAAI,CAAC,OAAD,IAAY,CAAC,YAAjB,EAA+B;AAC7B,WAAO,EAAP;AACD;;AAED,MAAM,eAAe,GAA+B,EAApD;AACA,EAAA,OAAO,CAAC,OAAR,CAAgB,UAAC,MAAD,EAA0B,KAA1B,EAAuC;AACrD,QAAI,MAAM,CAAC,QAAX,EAAqB;AACnB,MAAA,eAAe,CAAC,KAAD,CAAf,GAAyB,IAAzB;AACD;AACF,GAJD;;0BAMW,W,EAAW;AACpB,QAAM,KAAK,GAAG,SAAS,CAAC,OAAD,EAAU,UAAA,MAAA,EAAM;AAAI,aAAA,MAAM,CAAC,GAAP,KAAA,WAAA;AAA0B,KAA9C,CAAvB;;AACA,QAAI,KAAK,GAAG,CAAC,CAAb,EAAgB;AACd,MAAA,eAAe,CAAC,KAAD,CAAf,GAAyB,IAAzB;AACD;;;AAJH,OAA0B,IAAA,EAAA,GAAA,CAAA,EAAA,cAAA,GAAA,YAA1B,EAA0B,EAAA,GAAA,cAAA,CAAA,MAA1B,EAA0B,EAAA,EAA1B,EAAsC;AAAjC,QAAM,WAAW,GAAA,cAAA,CAAA,EAAA,CAAjB;;YAAM,W;AAKV;;AAED,SAAO,MAAM,CAAC,IAAP,CAAY,eAAZ,EACJ,GADI,CACA,MADA,EAEJ,IAFI,EAAP;AAGD;AAED;;;;;;AAMG;;;AACH,SAAS,wBAAT,CACE,kBADF,EAEE,WAFF,EAEuE;AAErE,MAAM,YAAY,GAAwB,iBAAiB,CAAC,kBAAD,CAA3D;;AACA,MAAI,YAAY,CAAC,MAAjB,EAAyB;AACvB,WAAO,YAAP;AACD;;AACD,SAAO,iBAAiB,CAAC,WAAD,CAAxB;AACD;;AAED,SAAS,iBAAT,CAA2B,WAA3B,EAAgG;AAC9F,MAAI,WAAW,KAAK,SAApB,EAA+B;AAC7B,WAAO,EAAP;AACD,GAH6F,CAK9F;;;AACA,SAAQ,WAAW,YAAY,KAAvB,GAA+B,WAA/B,GAA6C,CAAC,WAAD,CAArD;AACD;;AAED,SAAS,iBAAT,CAA2B,KAA3B,EAAoD;AAClD,SAAO,KAAK,IAAI,EAAhB;AACD;AAED;;;;;AAKG;;;AACH,SAAS,iBAAT,CAA2B,OAA3B,EAAmE,KAAnE,EAAgF;AAC9E,SAAO,CAAC,CAAC,OAAF,IAAa,KAAK,IAAI,CAAtB,IAA2B,KAAK,GAAG,OAAO,CAAC,MAAlD;AACD;AAED;;;AACA,SAAS,cAAT,CAAwB,MAAxB,EAA+C;AAC7C,SACE,MAAM,CAAC,QAAP,KAAoB,4BAA4B,CAAC,MAAjD,IAA2D,MAAM,CAAC,QAAP,KAAoB,4BAA4B,CAAC,OAD9G;AAGD;AAED;;;;AAIG;;;AACH,SAAS,cAAT,CAAwB,IAAxB,EAA6C;AAC3C,SAAO,IAAI,CAAC,kBAAL,IAA2B,IAAI,CAAC,SAAhC,GAA4C,IAAI,CAAC,SAAjD,GAA6D,IAAI,CAAC,IAAzE;AACD;AAED;;AAEG;;;AACH,SAAS,WAAT,CAAqB,EAArB,EAAoE;AAClE;AACA,SAAO,EAAE,CAAC,KAAH,KAAa,QAAQ,CAAC,GAAtB,IAA6B,EAAE,CAAC,GAAH,KAAW,MAA/C;AACD","sourcesContent":["import * as React from 'react';\nimport { Autofill, IAutofill } from '../../Autofill';\nimport {\n  initializeComponentRef,\n  css,\n  customizable,\n  divProperties,\n  findElementRecursive,\n  findIndex,\n  focusAsync,\n  getId,\n  getNativeProps,\n  isIOS,\n  isMac,\n  KeyCodes,\n  shallowCompare,\n  mergeAriaAttributeValues,\n  warnMutuallyExclusive,\n  Async,\n  EventGroup,\n  getPropsWithDefaults,\n} from '../../Utilities';\nimport { Callout, DirectionalHint } from '../../Callout';\nimport { Checkbox } from '../../Checkbox';\nimport { getCaretDownButtonStyles, getOptionStyles, getStyles } from './ComboBox.styles';\nimport { getClassNames, getComboBoxOptionClassNames, IComboBoxClassNames } from './ComboBox.classNames';\nimport {\n  IComboBoxOption,\n  IComboBoxOptionStyles,\n  IComboBoxProps,\n  IOnRenderComboBoxLabelProps,\n  IComboBox,\n} from './ComboBox.types';\nimport { Label } from '../../Label';\nimport { SelectableOptionMenuItemType, getAllSelectedOptions } from '../../SelectableOption';\nimport { BaseButton, Button, CommandButton, IButtonStyles, IconButton } from '../../Button';\nimport { ICalloutProps } from '../../Callout';\nimport { useMergedRefs } from '@fluentui/react-hooks';\n\nexport interface IComboBoxState {\n  /** The open state */\n  isOpen?: boolean;\n\n  /** The focused state of the combo box */\n  focusState?: 'none' | 'focused' | 'focusing';\n\n  /**\n   * When taking input, this will store the index that the options input matches\n   * (-1 if no input or match)\n   */\n  currentPendingValueValidIndex: number;\n\n  /**\n   * Stores the hovered over value in the dropdown\n   * (used for styling the options without updating the input)\n   */\n  currentPendingValueValidIndexOnHover: number;\n\n  /** When taking input, this will store the actual text that is being entered */\n  currentPendingValue?: string;\n}\n\nenum SearchDirection {\n  backward = -1,\n  none = 0,\n  forward = 1,\n}\n\nenum HoverStatus {\n  /** Used when the user was hovering and has since moused out of the menu items */\n  clearAll = -2,\n  /** Default \"normal\" state, when no hover has happened or a hover is in progress */\n  default = -1,\n}\n\nconst ScrollIdleDelay = 250; /* ms */\nconst TouchIdleDelay = 500; /* ms */\n\n/**\n * This is used to clear any pending autocomplete text (used when autocomplete is true and\n * allowFreeform is false)\n */\nconst ReadOnlyPendingAutoCompleteTimeout = 1000; /* ms */\n\ninterface IComboBoxOptionWrapperProps extends IComboBoxOption {\n  /** True if the option is currently selected */\n  isSelected: boolean;\n\n  /** True if the option is currently checked (multi-select) */\n  isChecked: boolean;\n\n  /**\n   * A function that returns the children of the OptionWrapper. We pass this in as a function to ensure that\n   * children methods don't get called unnecessarily if the component doesn't need to be updated. This leads\n   * to a significant performance increase in ComboBoxes with many options and/or complex onRenderOption functions\n   */\n  render: () => JSX.Element;\n}\n\n/**\n * Internal component that is used to wrap all ComboBox options.\n * This is used to customize when we want to re-render components,\n * so we don't re-render every option every time render is executed.\n */\nconst ComboBoxOptionWrapper = React.memo(\n  ({ render }: IComboBoxOptionWrapperProps) => render(),\n  (\n    { render: oldRender, ...oldProps }: IComboBoxOptionWrapperProps,\n    { render: newRender, ...newProps }: IComboBoxOptionWrapperProps,\n  ) =>\n    // The render function will always be different, so we ignore that prop\n    shallowCompare(oldProps, newProps),\n);\n\nconst COMPONENT_NAME = 'ComboBox';\nconst DEFAULT_PROPS: Partial<IComboBoxProps> = {\n  options: [],\n  allowFreeform: false,\n  autoComplete: 'on',\n  buttonIconProps: { iconName: 'ChevronDown' },\n};\n\nfunction useOptionsState({ options, defaultSelectedKey, selectedKey }: IComboBoxProps) {\n  /** The currently selected indices */\n  const [selectedIndices, setSelectedIndices] = React.useState<number[]>(() =>\n    getSelectedIndices(options, buildDefaultSelectedKeys(defaultSelectedKey, selectedKey)),\n  );\n  /** The options currently available for the callout */\n  const [currentOptions, setCurrentOptions] = React.useState<IComboBoxOption[]>(options);\n  /** This value is used for the autocomplete hint value */\n  const [suggestedDisplayValue, setSuggestedDisplayValue] = React.useState<string>();\n\n  React.useEffect(() => {\n    if (selectedKey !== undefined) {\n      const selectedKeys: string[] | number[] = buildSelectedKeys(selectedKey);\n      const indices: number[] = getSelectedIndices(options, selectedKeys);\n\n      setSelectedIndices(indices);\n    }\n    setCurrentOptions(options);\n  }, [options, selectedKey]);\n\n  React.useEffect(() => {\n    if (selectedKey === null) {\n      setSuggestedDisplayValue(undefined);\n    }\n  }, [selectedKey]);\n\n  return [\n    selectedIndices,\n    setSelectedIndices,\n    currentOptions,\n    setCurrentOptions,\n    suggestedDisplayValue,\n    setSuggestedDisplayValue,\n  ] as const;\n}\n\nexport const ComboBox: React.FunctionComponent<IComboBoxProps> = React.forwardRef<HTMLDivElement, IComboBoxProps>(\n  (propsWithoutDefaults: IComboBoxProps, forwardedRef: React.Ref<HTMLDivElement>) => {\n    const { ref, ...props } = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n    const rootRef = React.useRef<HTMLDivElement>(null);\n\n    const mergedRootRef = useMergedRefs(rootRef, forwardedRef);\n\n    const [\n      selectedIndices,\n      setSelectedIndices,\n      currentOptions,\n      setCurrentOptions,\n      suggestedDisplayValue,\n      setSuggestedDisplayValue,\n    ] = useOptionsState(props);\n\n    return (\n      <ComboBoxInternal\n        {...props}\n        hoisted={{\n          mergedRootRef,\n          rootRef,\n          selectedIndices,\n          setSelectedIndices,\n          currentOptions,\n          setCurrentOptions,\n          suggestedDisplayValue,\n          setSuggestedDisplayValue,\n        }}\n      />\n    );\n  },\n);\nComboBox.displayName = COMPONENT_NAME;\n\ninterface IComboBoxInternalProps extends Omit<IComboBoxProps, 'ref'> {\n  hoisted: {\n    mergedRootRef: React.Ref<HTMLDivElement>;\n    rootRef: React.RefObject<HTMLDivElement>;\n    selectedIndices: number[];\n    currentOptions: IComboBoxOption[];\n    suggestedDisplayValue?: string;\n    setSelectedIndices: React.Dispatch<React.SetStateAction<number[]>>;\n    setCurrentOptions: React.Dispatch<React.SetStateAction<IComboBoxOption[]>>;\n    setSuggestedDisplayValue: React.Dispatch<React.SetStateAction<string | undefined>>;\n  };\n}\n\n@customizable('ComboBox', ['theme', 'styles'], true)\nclass ComboBoxInternal extends React.Component<IComboBoxInternalProps, IComboBoxState> implements IComboBox {\n  /** The input aspect of the combo box */\n  private _autofill = React.createRef<IAutofill>();\n\n  /** The wrapping div of the input and button */\n  private _comboBoxWrapper = React.createRef<HTMLDivElement>();\n\n  /** The callout element */\n  private _comboBoxMenu = React.createRef<HTMLDivElement>();\n\n  /** The menu item element that is currently selected */\n  private _selectedElement = React.createRef<HTMLSpanElement>();\n\n  /** The base id for the ComboBox */\n  private _id: string;\n\n  /**\n   * After a character is inserted when autocomplete is true and allowFreeform is false,\n   * remember the task that will clear the pending string of characters.\n   */\n  private _autoCompleteTimeout: number | undefined;\n\n  /** Promise used when resolving the comboBox options */\n  private _currentPromise: PromiseLike<IComboBoxOption[]>;\n\n  /** The current visible value sent to the auto fill on render */\n  private _currentVisibleValue: string | undefined;\n  private _classNames: IComboBoxClassNames;\n  private _isScrollIdle: boolean;\n  private _hasPendingValue: boolean;\n  private _scrollIdleTimeoutId: number | undefined;\n  private _processingTouch: boolean;\n  private _lastTouchTimeoutId: number | undefined;\n  /** True if the most recent keydown event was for alt (option) or meta (command). */\n  private _lastKeyDownWasAltOrMeta: boolean | undefined;\n\n  /**\n   * Determines if we should be setting focus back to the input when the menu closes.\n   * The general rule of thumb is if the menu was launched via the keyboard focus should go back\n   * to the input, if it was dropped via the mouse focus should not be forced back to the input.\n   */\n  private _focusInputAfterClose: boolean;\n\n  /** Flag for when we get the first mouseMove */\n  private _gotMouseMove: boolean;\n\n  private _processingClearPendingInfo: boolean;\n\n  private _async: Async;\n  private _events: EventGroup;\n\n  constructor(props: IComboBoxInternalProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    warnMutuallyExclusive(COMPONENT_NAME, props, {\n      defaultSelectedKey: 'selectedKey',\n      text: 'defaultSelectedKey',\n      selectedKey: 'value',\n      dropdownWidth: 'useComboBoxAsMenuWidth',\n    });\n\n    this._id = props.id || getId('ComboBox');\n\n    this._isScrollIdle = true;\n    this._processingTouch = false;\n    this._gotMouseMove = false;\n    this._processingClearPendingInfo = false;\n\n    this.state = {\n      isOpen: false,\n      focusState: 'none',\n      currentPendingValueValidIndex: -1,\n      currentPendingValue: undefined,\n      currentPendingValueValidIndexOnHover: HoverStatus.default,\n    };\n  }\n\n  /**\n   * All selected options\n   */\n  public get selectedOptions(): IComboBoxOption[] {\n    const { currentOptions, selectedIndices } = this.props.hoisted;\n\n    return getAllSelectedOptions(currentOptions, selectedIndices!);\n  }\n\n  public componentDidMount(): void {\n    if (this._comboBoxWrapper.current && !this.props.disabled) {\n      // hook up resolving the options if needed on focus\n      this._events.on(this._comboBoxWrapper.current, 'focus', this._onResolveOptions, true);\n      if ('onpointerdown' in this._comboBoxWrapper.current) {\n        // For ComboBoxes, touching anywhere in the combo box should drop the dropdown, including the input element.\n        // This gives more hit target space for touch environments. We're setting the onpointerdown here, because React\n        // does not support Pointer events yet.\n        this._events.on(this._comboBoxWrapper.current, 'pointerdown', this._onPointerDown, true);\n      }\n    }\n  }\n\n  public componentDidUpdate(prevProps: IComboBoxInternalProps, prevState: IComboBoxState) {\n    const {\n      allowFreeform,\n      text,\n      onMenuOpen,\n      onMenuDismissed,\n      hoisted: { selectedIndices },\n    } = this.props;\n    const { isOpen, currentPendingValueValidIndex } = this.state;\n\n    // If we are newly open or are open and the pending valid index changed,\n    // make sure the currently selected/pending option is scrolled into view\n    if (isOpen && (!prevState.isOpen || prevState.currentPendingValueValidIndex !== currentPendingValueValidIndex)) {\n      // Need this timeout so that the selectedElement ref is correctly updated\n      this._async.setTimeout(() => this._scrollIntoView(), 0);\n    }\n\n    // if an action is taken that put focus in the ComboBox\n    // and If we are open or we are just closed, shouldFocusAfterClose is set,\n    // but we are not the activeElement set focus on the input\n    if (\n      this._hasFocus() &&\n      (isOpen ||\n        (prevState.isOpen &&\n          !isOpen &&\n          this._focusInputAfterClose &&\n          this._autofill.current &&\n          document.activeElement !== this._autofill.current.inputElement))\n    ) {\n      this.focus(undefined /*shouldOpenOnFocus*/, true /*useFocusAsync*/);\n    }\n\n    // If we should focusAfterClose AND\n    //   just opened/closed the menu OR\n    //   are focused AND\n    //     updated the selectedIndex with the menu closed OR\n    //     are not allowing freeform OR\n    //     the value changed\n    // we need to set selection\n    if (\n      this._focusInputAfterClose &&\n      ((prevState.isOpen && !isOpen) ||\n        (this._hasFocus() &&\n          ((!isOpen &&\n            !this.props.multiSelect &&\n            prevProps.hoisted.selectedIndices &&\n            selectedIndices &&\n            prevProps.hoisted.selectedIndices[0] !== selectedIndices[0]) ||\n            !allowFreeform ||\n            text !== prevProps.text)))\n    ) {\n      this._onFocus();\n    }\n\n    this._notifyPendingValueChanged(prevState);\n\n    if (isOpen && !prevState.isOpen && onMenuOpen) {\n      onMenuOpen();\n    }\n\n    if (!isOpen && prevState.isOpen && onMenuDismissed) {\n      onMenuDismissed();\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n  }\n\n  // Primary Render\n  public render(): JSX.Element {\n    const id = this._id;\n    const errorMessageId = id + '-error';\n    const {\n      className,\n      disabled,\n      required,\n      errorMessage,\n      onRenderContainer = this._onRenderContainer,\n      onRenderLabel = this._onRenderLabel,\n      onRenderList = this._onRenderList,\n      onRenderItem = this._onRenderItem,\n      onRenderOption = this._onRenderOptionContent,\n      allowFreeform,\n      styles: customStyles,\n      theme,\n      persistMenu,\n      multiSelect,\n      hoisted: { suggestedDisplayValue, selectedIndices, currentOptions },\n    } = this.props;\n    const { isOpen } = this.state;\n    this._currentVisibleValue = this._getVisibleValue();\n\n    // Single select is already accessible since the whole text is selected\n    // when focus enters the input. Since multiselect appears to clear the input\n    // it needs special accessible text\n    const multiselectAccessibleText = multiSelect\n      ? this._getMultiselectDisplayString(selectedIndices, currentOptions, suggestedDisplayValue)\n      : undefined;\n\n    const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties, [\n      'onChange',\n      'value',\n    ]);\n\n    const hasErrorMessage = errorMessage && errorMessage.length > 0 ? true : false;\n\n    this._classNames = this.props.getClassNames\n      ? this.props.getClassNames(\n          theme!,\n          !!isOpen,\n          !!disabled,\n          !!required,\n          !!this._hasFocus(),\n          !!allowFreeform,\n          !!hasErrorMessage,\n          className,\n        )\n      : getClassNames(\n          getStyles(theme!, customStyles),\n          className!,\n          !!isOpen,\n          !!disabled,\n          !!required,\n          !!this._hasFocus(),\n          !!allowFreeform,\n          !!hasErrorMessage,\n        );\n\n    const comboBoxWrapper = this._renderComboBoxWrapper(multiselectAccessibleText, errorMessageId);\n\n    return (\n      <div {...divProps} ref={this.props.hoisted.mergedRootRef} className={this._classNames.container}>\n        {onRenderLabel({ props: this.props, multiselectAccessibleText }, this._onRenderLabel)}\n        {comboBoxWrapper}\n        {(persistMenu || isOpen) &&\n          onRenderContainer(\n            {\n              ...this.props,\n              onRenderList,\n              onRenderItem,\n              onRenderOption,\n              options: currentOptions.map((item, index) => ({ ...item, index: index })),\n              onDismiss: this._onDismiss,\n            },\n            this._onRenderContainer,\n          )}\n        <div\n          role=\"region\"\n          aria-live=\"polite\"\n          aria-atomic=\"true\"\n          id={errorMessageId}\n          {...(hasErrorMessage ? { className: this._classNames.errorMessage } : { 'aria-hidden': true })}\n        >\n          {errorMessage !== undefined ? errorMessage : ''}\n        </div>\n      </div>\n    );\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public focus = (shouldOpenOnFocus?: boolean, useFocusAsync?: boolean): void => {\n    if (this._autofill.current) {\n      if (useFocusAsync) {\n        focusAsync(this._autofill.current);\n      } else {\n        this._autofill.current.focus();\n      }\n\n      if (shouldOpenOnFocus) {\n        this.setState({\n          isOpen: true,\n        });\n      }\n    }\n\n    // Programmatically setting focus means that there is nothing else that needs to be done\n    // Focus is now contained\n    if (!this._hasFocus()) {\n      this.setState({ focusState: 'focused' });\n    }\n  };\n\n  /**\n   * Close menu callout if it is open\n   */\n  public dismissMenu = (): void => {\n    const { isOpen } = this.state;\n    isOpen && this.setState({ isOpen: false });\n  };\n\n  /**\n   * componentWillReceiveProps handler for the auto fill component\n   * Checks/updates the input value to set, if needed\n   * @param defaultVisibleValue - the defaultVisibleValue that got passed\n   *  in to the auto fill's componentWillReceiveProps\n   * @returns - the updated value to set, if needed\n   */\n  private _onUpdateValueInAutofillWillReceiveProps = (): string | null => {\n    const comboBox = this._autofill.current;\n\n    if (!comboBox) {\n      return null;\n    }\n\n    if (comboBox.value === null || comboBox.value === undefined) {\n      return null;\n    }\n\n    const visibleValue = normalizeToString(this._currentVisibleValue);\n    if (comboBox.value !== visibleValue) {\n      return visibleValue;\n    }\n\n    return comboBox.value;\n  };\n\n  private _renderComboBoxWrapper = (\n    multiselectAccessibleText: string | undefined,\n    errorMessageId: string,\n  ): JSX.Element => {\n    const {\n      label,\n      disabled,\n      ariaLabel,\n      ariaDescribedBy,\n      required,\n      errorMessage,\n      buttonIconProps,\n      isButtonAriaHidden = true,\n      title,\n      placeholder: placeholderProp,\n      tabIndex,\n      autofill,\n      iconButtonProps,\n      hoisted: { suggestedDisplayValue },\n    } = this.props;\n\n    const { isOpen } = this.state;\n\n    // If the combo box has focus, is multiselect, and has a display string, then use that placeholder\n    // so that the selected items don't appear to vanish. This is not ideal but it's the only reasonable way\n    // to correct the behavior where the input is cleared so the user can type. If a full refactor is done, then this\n    // should be removed and the multiselect combo box should behave like a picker.\n    const placeholder =\n      this._hasFocus() && this.props.multiSelect && multiselectAccessibleText\n        ? multiselectAccessibleText\n        : placeholderProp;\n\n    return (\n      <div\n        data-ktp-target={true}\n        ref={this._comboBoxWrapper}\n        id={this._id + 'wrapper'}\n        className={this._classNames.root}\n      >\n        <Autofill\n          data-ktp-execute-target={true}\n          data-is-interactable={!disabled}\n          componentRef={this._autofill}\n          id={this._id + '-input'}\n          className={this._classNames.input}\n          type=\"text\"\n          onFocus={this._onFocus}\n          onBlur={this._onBlur}\n          onKeyDown={this._onInputKeyDown}\n          onKeyUp={this._onInputKeyUp}\n          onClick={this._onAutofillClick}\n          onTouchStart={this._onTouchStart}\n          onInputValueChange={this._onInputChange}\n          aria-expanded={isOpen}\n          aria-autocomplete={this._getAriaAutoCompleteValue()}\n          role=\"combobox\"\n          readOnly={disabled}\n          aria-labelledby={label && this._id + '-label'}\n          aria-label={ariaLabel && !label ? ariaLabel : undefined}\n          aria-describedby={\n            errorMessage !== undefined ? mergeAriaAttributeValues(ariaDescribedBy, errorMessageId) : ariaDescribedBy\n          }\n          aria-activedescendant={this._getAriaActiveDescendantValue()}\n          aria-required={required}\n          aria-disabled={disabled}\n          aria-owns={isOpen ? this._id + '-list' : undefined}\n          spellCheck={false}\n          defaultVisibleValue={this._currentVisibleValue}\n          suggestedDisplayValue={suggestedDisplayValue}\n          updateValueInWillReceiveProps={this._onUpdateValueInAutofillWillReceiveProps}\n          shouldSelectFullInputValueInComponentDidUpdate={\n            this._onShouldSelectFullInputValueInAutofillComponentDidUpdate\n          }\n          title={title}\n          preventValueSelection={!this._hasFocus()}\n          placeholder={placeholder}\n          tabIndex={tabIndex}\n          {...autofill}\n        />\n        <IconButton\n          className={'ms-ComboBox-CaretDown-button'}\n          styles={this._getCaretButtonStyles()}\n          role=\"presentation\"\n          aria-hidden={isButtonAriaHidden}\n          data-is-focusable={false}\n          tabIndex={-1}\n          onClick={this._onComboBoxClick}\n          onBlur={this._onBlur}\n          iconProps={buttonIconProps}\n          disabled={disabled}\n          checked={isOpen}\n          {...iconButtonProps}\n        />\n      </div>\n    );\n  };\n\n  /**\n   * componentDidUpdate handler for the auto fill component\n   *\n   * @param defaultVisibleValue - the current defaultVisibleValue in the auto fill's componentDidUpdate\n   * @param suggestedDisplayValue - the current suggestedDisplayValue in the auto fill's componentDidUpdate\n   * @returns - should the full value of the input be selected?\n   * True if the defaultVisibleValue equals the suggestedDisplayValue, false otherwise\n   */\n  private _onShouldSelectFullInputValueInAutofillComponentDidUpdate = (): boolean => {\n    return this._currentVisibleValue === this.props.hoisted.suggestedDisplayValue;\n  };\n\n  /**\n   * Get the correct value to pass to the input\n   * to show to the user based off of the current props and state\n   * @returns the value to pass to the input\n   */\n  private _getVisibleValue = (): string | undefined => {\n    const {\n      text,\n      allowFreeform,\n      autoComplete,\n      hoisted: { suggestedDisplayValue, selectedIndices, currentOptions },\n    } = this.props;\n    const { currentPendingValueValidIndex, currentPendingValue, isOpen } = this.state;\n\n    const currentPendingIndexValid = indexWithinBounds(currentOptions, currentPendingValueValidIndex);\n\n    // If the user passed is a value prop, use that\n    // unless we are open and have a valid current pending index\n    if (\n      !(isOpen && currentPendingIndexValid) &&\n      text &&\n      (currentPendingValue === null || currentPendingValue === undefined)\n    ) {\n      return text;\n    }\n\n    if (this.props.multiSelect) {\n      // Multi-select\n      if (this._hasFocus()) {\n        let index = -1;\n        if (autoComplete === 'on' && currentPendingIndexValid) {\n          index = currentPendingValueValidIndex;\n        }\n        return this._getPendingString(currentPendingValue, currentOptions, index);\n      } else {\n        return this._getMultiselectDisplayString(selectedIndices, currentOptions, suggestedDisplayValue);\n      }\n    } else {\n      // Single-select\n      let index: number = this._getFirstSelectedIndex();\n      if (allowFreeform) {\n        // If we are allowing freeform and autocomplete is also true\n        // and we've got a pending value that matches an option, remember\n        // the matched option's index\n        if (autoComplete === 'on' && currentPendingIndexValid) {\n          index = currentPendingValueValidIndex;\n        }\n\n        // Since we are allowing freeform, if there is currently a pending value, use that\n        // otherwise use the index determined above (falling back to '' if we did not get a valid index)\n        return this._getPendingString(currentPendingValue, currentOptions, index);\n      } else {\n        // If we are not allowing freeform and have a valid index that matches the pending value,\n        // we know we will need some version of the pending value\n        if (currentPendingIndexValid && autoComplete === 'on') {\n          // If autoComplete is on, return the raw pending value, otherwise remember\n          // the matched option's index\n          index = currentPendingValueValidIndex;\n          return normalizeToString(currentPendingValue);\n        } else if (!this.state.isOpen && currentPendingValue) {\n          return indexWithinBounds(currentOptions, index)\n            ? currentPendingValue\n            : normalizeToString(suggestedDisplayValue);\n        } else {\n          return indexWithinBounds(currentOptions, index)\n            ? getPreviewText(currentOptions[index])\n            : normalizeToString(suggestedDisplayValue);\n        }\n      }\n    }\n  };\n\n  private _getPendingString(\n    currentPendingValue: string | null | undefined,\n    currentOptions: IComboBoxOption[],\n    index: number,\n  ) {\n    return currentPendingValue !== null && currentPendingValue !== undefined\n      ? currentPendingValue\n      : indexWithinBounds(currentOptions, index)\n      ? currentOptions[index].text\n      : '';\n  }\n\n  /**\n   * Returns a string that concatenates all of the selected values\n   * for multiselect combo box.\n   */\n  private _getMultiselectDisplayString(\n    selectedIndices: number[] | undefined,\n    currentOptions: IComboBoxOption[],\n    suggestedDisplayValue: string | undefined,\n  ) {\n    const displayValues = [];\n    for (let idx = 0; selectedIndices && idx < selectedIndices.length; idx++) {\n      const index: number = selectedIndices[idx];\n      displayValues.push(\n        indexWithinBounds(currentOptions, index)\n          ? currentOptions[index].text\n          : normalizeToString(suggestedDisplayValue),\n      );\n    }\n    const { multiSelectDelimiter = ', ' } = this.props;\n    return displayValues.join(multiSelectDelimiter);\n  }\n\n  /**\n   * Handler for typing changes on the input\n   * @param updatedValue - the newly changed value\n   */\n  private _onInputChange = (updatedValue: string): void => {\n    if (this.props.disabled) {\n      this._handleInputWhenDisabled(null /* event */);\n      return;\n    }\n\n    this.props.allowFreeform\n      ? this._processInputChangeWithFreeform(updatedValue)\n      : this._processInputChangeWithoutFreeform(updatedValue);\n  };\n\n  /**\n   * Process the new input's new value when the combo box allows freeform entry\n   * @param updatedValue - the input's newly changed value\n   */\n  private _processInputChangeWithFreeform(updatedValue: string): void {\n    const { currentOptions } = this.props.hoisted;\n    let newCurrentPendingValueValidIndex = -1;\n\n    // if the new value is empty, see if we have an exact match and then set the pending info\n    if (updatedValue === '') {\n      const items = currentOptions\n        .map((item, index) => ({ ...item, index }))\n        .filter(option => isNormalOption(option) && getPreviewText(option) === updatedValue);\n\n      // if we found a match remember the index\n      if (items.length === 1) {\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n\n      this._setPendingInfo(updatedValue, newCurrentPendingValueValidIndex, updatedValue);\n      return;\n    }\n\n    // Remember the original value and then make the value lowercase for comparison\n    const originalUpdatedValue: string = updatedValue;\n    updatedValue = updatedValue.toLocaleLowerCase();\n\n    let newSuggestedDisplayValue = '';\n\n    // If autoComplete is on, attempt to find a match from the available options\n    if (this.props.autoComplete === 'on') {\n      // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\n      const items = currentOptions\n        .map((item, index) => ({ ...item, index }))\n        .filter(\n          option =>\n            isNormalOption(option) &&\n            getPreviewText(option)\n              .toLocaleLowerCase()\n              .indexOf(updatedValue) === 0,\n        );\n      if (items.length > 0) {\n        // use ariaLabel as the value when the option is set\n        const text: string = getPreviewText(items[0]);\n\n        // If the user typed out the complete option text, we don't need any suggested display text anymore\n        newSuggestedDisplayValue = text.toLocaleLowerCase() !== updatedValue ? text : '';\n\n        // remember the index of the match we found\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n    } else {\n      // If autoComplete is off, attempt to find a match only when the value is exactly equal to the text of an option\n      const items = currentOptions\n        .map((item, index) => ({ ...item, index }))\n        .filter(option => isNormalOption(option) && getPreviewText(option).toLocaleLowerCase() === updatedValue);\n\n      // if we found a match remember the index\n      if (items.length === 1) {\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n    }\n\n    // Set the updated state\n    this._setPendingInfo(originalUpdatedValue, newCurrentPendingValueValidIndex, newSuggestedDisplayValue);\n  }\n\n  /**\n   * Process the new input's new value when the combo box does not allow freeform entry\n   * @param updatedValue - the input's newly changed value\n   */\n  private _processInputChangeWithoutFreeform(updatedValue: string): void {\n    const { currentOptions } = this.props.hoisted;\n    const { currentPendingValue, currentPendingValueValidIndex } = this.state;\n\n    if (this.props.autoComplete === 'on') {\n      // If autoComplete is on while allow freeform is off,\n      // we will remember the key press and build up a string to attempt to match\n      // as long as characters are typed within a the timeout span of each other,\n      // otherwise we will clear the string and start building a new one on the next keypress.\n      // Also, only do this processing if we have a non-empty value\n      if (updatedValue !== '') {\n        // If we have a pending autocomplete clearing task,\n        // we know that the user is typing with key press happening\n        // within the timeout of each other so remove the clearing task\n        // and continue building the pending value with the updated value\n        if (this._autoCompleteTimeout) {\n          this._async.clearTimeout(this._autoCompleteTimeout);\n          this._autoCompleteTimeout = undefined;\n          updatedValue = normalizeToString(currentPendingValue) + updatedValue;\n        }\n\n        const originalUpdatedValue: string = updatedValue;\n        updatedValue = updatedValue.toLocaleLowerCase();\n\n        // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\n        const items = currentOptions\n          .map((item, i) => ({ ...item, index: i }))\n\n          .filter(option => isNormalOption(option) && option.text.toLocaleLowerCase().indexOf(updatedValue) === 0);\n\n        // If we found a match, update the state\n        if (items.length > 0) {\n          this._setPendingInfo(originalUpdatedValue, items[0].index, getPreviewText(items[0]));\n        }\n\n        // Schedule a timeout to clear the pending value after the timeout span\n        this._autoCompleteTimeout = this._async.setTimeout(() => {\n          this._autoCompleteTimeout = undefined;\n        }, ReadOnlyPendingAutoCompleteTimeout);\n        return;\n      }\n    }\n\n    // If we get here, either autoComplete is on or we did not find a match with autoComplete on.\n    // Remember we are not allowing freeform, so at this point, if we have a pending valid value index\n    // use that; otherwise use the selectedIndex\n    const index = currentPendingValueValidIndex >= 0 ? currentPendingValueValidIndex : this._getFirstSelectedIndex();\n\n    // Since we are not allowing freeform, we need to\n    // set both the pending and suggested values/index\n    // to allow us to select all content in the input to\n    // give the illusion that we are readonly (e.g. freeform off)\n    this._setPendingInfoFromIndex(index);\n  }\n\n  private _getFirstSelectedIndex(): number {\n    const { selectedIndices } = this.props.hoisted;\n    return selectedIndices?.length ? selectedIndices[0] : -1;\n  }\n\n  /**\n   * Walk along the options starting at the index, stepping by the delta (positive or negative)\n   * looking for the next valid selectable index (e.g. skipping headings and dividers)\n   * @param index - the index to get the next selectable index from\n   * @param delta - optional delta to step by when finding the next index, defaults to 0\n   * @returns - the next valid selectable index. If the new index is outside of the bounds,\n   * it will snap to the edge of the options array. If delta == 0 and the given index is not selectable\n   */\n  private _getNextSelectableIndex(index: number, searchDirection: SearchDirection): number {\n    const { currentOptions } = this.props.hoisted;\n\n    let newIndex = index + searchDirection;\n\n    newIndex = Math.max(0, Math.min(currentOptions.length - 1, newIndex));\n\n    if (!indexWithinBounds(currentOptions, newIndex)) {\n      return -1;\n    }\n\n    const option: IComboBoxOption = currentOptions[newIndex];\n\n    if (!isNormalOption(option) || option.hidden === true) {\n      // Should we continue looking for an index to select?\n      if (\n        searchDirection !== SearchDirection.none &&\n        ((newIndex > 0 && searchDirection < SearchDirection.none) ||\n          (newIndex >= 0 && newIndex < currentOptions.length && searchDirection > SearchDirection.none))\n      ) {\n        newIndex = this._getNextSelectableIndex(newIndex, searchDirection);\n      } else {\n        // If we cannot perform a useful search just return the index we were given\n        return index;\n      }\n    }\n\n    // We have the next valid selectable index, return it\n    return newIndex;\n  }\n\n  /**\n   * Set the selected index. Note, this is\n   * the \"real\" selected index, not the pending selected index\n   * @param index - the index to set (or the index to set from if a search direction is provided)\n   * @param searchDirection - the direction to search along the options from the given index\n   */\n  private _setSelectedIndex(\n    index: number,\n    submitPendingValueEvent: React.SyntheticEvent<any>,\n    searchDirection: SearchDirection = SearchDirection.none,\n  ): void {\n    const {\n      onChange,\n      onPendingValueChanged,\n      hoisted: { selectedIndices: initialIndices, currentOptions },\n    } = this.props;\n\n    // Clone selectedIndices so we don't mutate state\n    let selectedIndices = initialIndices ? initialIndices.slice() : [];\n\n    // Find the next selectable index, if searchDirection is none\n    // we will get our starting index back\n    index = this._getNextSelectableIndex(index, searchDirection);\n\n    if (!indexWithinBounds(currentOptions, index)) {\n      return;\n    }\n\n    // Are we at a new index? If so, update the state, otherwise\n    // there is nothing to do\n    if (\n      this.props.multiSelect ||\n      selectedIndices.length < 1 ||\n      (selectedIndices.length === 1 && selectedIndices[0] !== index)\n    ) {\n      const option: IComboBoxOption = { ...currentOptions[index] };\n      // if option doesn't existing, or option is disabled, we noop\n      if (!option || option.disabled) {\n        return;\n      }\n      if (this.props.multiSelect) {\n        // Setting the initial state of option.selected in Multi-select combo box by checking the\n        // selectedIndices array and overriding the undefined issue\n        option.selected = option.selected !== undefined ? !option.selected : selectedIndices.indexOf(index) < 0;\n        if (option.selected && selectedIndices.indexOf(index) < 0) {\n          selectedIndices.push(index);\n        } else if (!option.selected && selectedIndices.indexOf(index) >= 0) {\n          selectedIndices = selectedIndices.filter((value: number) => value !== index);\n        }\n      } else {\n        selectedIndices[0] = index;\n      }\n\n      submitPendingValueEvent.persist();\n\n      // Only setState if combo box is uncontrolled.\n      if (this.props.selectedKey || this.props.selectedKey === null) {\n        // If combo box value is changed, revert preview first\n        if (this._hasPendingValue && onPendingValueChanged) {\n          onPendingValueChanged();\n          this._hasPendingValue = false;\n        }\n        if (onChange) {\n          onChange(submitPendingValueEvent, option, index, undefined);\n        }\n      } else {\n        // Update current options\n        const changedOptions = currentOptions.slice();\n        changedOptions[index] = option;\n\n        // Call onChange after state is updated\n        this.props.hoisted.setSelectedIndices(selectedIndices);\n        this.props.hoisted.setCurrentOptions(changedOptions);\n\n        // If ComboBox value is changed, revert preview first\n        if (this._hasPendingValue && onPendingValueChanged) {\n          onPendingValueChanged();\n          this._hasPendingValue = false;\n        }\n\n        if (onChange) {\n          onChange(submitPendingValueEvent, option, index, undefined);\n        }\n      }\n    }\n    if (this.props.multiSelect && this.state.isOpen) {\n      return;\n    }\n    // clear all of the pending info\n    this._clearPendingInfo();\n  }\n\n  /**\n   * Focus (and select) the content of the input\n   * and set the focused state\n   */\n  private _onFocus = (): void => {\n    this._autofill.current?.inputElement?.select();\n\n    if (!this._hasFocus()) {\n      this.setState({ focusState: 'focusing' });\n    }\n  };\n\n  /**\n   * Callback issued when the options should be resolved, if they have been updated or\n   * if they need to be passed in the first time. This only does work if an onResolveOptions\n   * callback was passed in\n   */\n  private _onResolveOptions = (): void => {\n    if (this.props.onResolveOptions) {\n      // get the options\n      const newOptions = this.props.onResolveOptions([...this.props.hoisted.currentOptions]);\n\n      // Check to see if the returned value is an array, if it is update the state\n      // If the returned value is not an array then check to see if it's a promise or PromiseLike.\n      // If it is then resolve it asynchronously.\n      if (Array.isArray(newOptions)) {\n        this.props.hoisted.setCurrentOptions(newOptions);\n      } else if (newOptions && newOptions.then) {\n        // Ensure that the promise will only use the callback if it was the most recent one\n        // and update the state when the promise returns\n        const promise: PromiseLike<IComboBoxOption[]> = (this._currentPromise = newOptions);\n        promise.then((newOptionsFromPromise: IComboBoxOption[]) => {\n          if (promise === this._currentPromise) {\n            this.props.hoisted.setCurrentOptions(newOptionsFromPromise);\n          }\n        });\n      }\n    }\n  };\n\n  /**\n   * OnBlur handler. Set the focused state to false\n   * and submit any pending value\n   */\n  // eslint-disable-next-line deprecation/deprecation\n  private _onBlur = (event: React.FocusEvent<HTMLElement | Autofill | BaseButton | Button>): void => {\n    // Do nothing if the blur is coming from something\n    // inside the comboBox root or the comboBox menu since\n    // it we are not really blurring from the whole comboBox\n    let relatedTarget = event.relatedTarget;\n    if (event.relatedTarget === null) {\n      // In IE11, due to lack of support, event.relatedTarget is always\n      // null making every onBlur call to be \"outside\" of the ComboBox\n      // even when it's not. Using document.activeElement is another way\n      // for us to be able to get what the relatedTarget without relying\n      // on the event\n      relatedTarget = document.activeElement as Element;\n    }\n\n    if (relatedTarget) {\n      const isBlurFromComboBoxTitle = this.props.hoisted.rootRef.current?.contains(relatedTarget as HTMLElement);\n      const isBlurFromComboBoxMenu = this._comboBoxMenu.current?.contains(relatedTarget as HTMLElement);\n      const isBlurFromComboBoxMenuAncestor =\n        this._comboBoxMenu.current &&\n        findElementRecursive(this._comboBoxMenu.current, (element: HTMLElement) => element === relatedTarget);\n\n      if (isBlurFromComboBoxTitle || isBlurFromComboBoxMenu || isBlurFromComboBoxMenuAncestor) {\n        if (\n          isBlurFromComboBoxMenuAncestor &&\n          this._hasFocus() &&\n          (!this.props.multiSelect || this.props.allowFreeform)\n        ) {\n          this._submitPendingValue(event);\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        return;\n      }\n    }\n\n    if (this._hasFocus()) {\n      this.setState({ focusState: 'none' });\n      if (!this.props.multiSelect || this.props.allowFreeform) {\n        this._submitPendingValue(event);\n      }\n    }\n  };\n\n  /**\n   * Submit a pending value if there is one\n   */\n  private _submitPendingValue(submitPendingValueEvent: React.SyntheticEvent<any>): void {\n    const { onChange, allowFreeform, autoComplete, multiSelect, hoisted } = this.props;\n    const { currentOptions } = hoisted;\n    const { currentPendingValue, currentPendingValueValidIndex, currentPendingValueValidIndexOnHover } = this.state;\n    let { selectedIndices } = this.props.hoisted;\n\n    // Do not submit any pending value if we\n    // have already initiated clearing the pending info\n    if (this._processingClearPendingInfo) {\n      return;\n    }\n\n    // If we allow freeform we need to handle that\n    if (allowFreeform) {\n      // if currentPendingValue is null or undefined the user did not submit anything\n      // (not even empty because we would have stored that as the pending value)\n      if (currentPendingValue === null || currentPendingValue === undefined) {\n        // if a user did not type anything they may just hovered over an item\n        if (currentPendingValueValidIndexOnHover >= 0) {\n          this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\n          this._clearPendingInfo();\n        }\n\n        return;\n      }\n\n      // Check to see if the user typed an exact match\n      if (indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {\n        const pendingOptionText = getPreviewText(currentOptions[currentPendingValueValidIndex]).toLocaleLowerCase();\n        const autofill = this._autofill.current;\n\n        // By exact match, that means: our pending value is the same as the pending option text OR\n        // the pending option starts with the pending value and we have an \"autoComplete\" selection\n        // where the total length is equal to pending option length OR\n        // the live value in the underlying input matches the pending option; update the state\n        if (\n          currentPendingValue.toLocaleLowerCase() === pendingOptionText ||\n          (autoComplete &&\n            pendingOptionText.indexOf(currentPendingValue.toLocaleLowerCase()) === 0 &&\n            autofill?.isValueSelected &&\n            currentPendingValue.length + (autofill.selectionEnd! - autofill.selectionStart!) ===\n              pendingOptionText.length) ||\n          autofill?.inputElement?.value.toLocaleLowerCase() === pendingOptionText\n        ) {\n          this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\n          if (multiSelect && this.state.isOpen) {\n            return;\n          }\n          this._clearPendingInfo();\n          return;\n        }\n      }\n\n      if (onChange) {\n        if (onChange) {\n          // trigger onChange to clear value\n          onChange(submitPendingValueEvent, undefined, undefined, currentPendingValue);\n        }\n      } else {\n        // If we are not controlled, create a new selected option\n        const newOption: IComboBoxOption = {\n          key: currentPendingValue || getId(),\n          text: normalizeToString(currentPendingValue),\n        };\n        // If it's multiselect, set selected state to true\n        if (multiSelect) {\n          newOption.selected = true;\n        }\n        const newOptions: IComboBoxOption[] = currentOptions.concat([newOption]);\n        if (selectedIndices) {\n          if (!multiSelect) {\n            selectedIndices = [];\n          }\n          selectedIndices.push(newOptions.length - 1);\n        }\n        hoisted.setCurrentOptions(newOptions);\n        hoisted.setSelectedIndices(selectedIndices);\n      }\n    } else if (currentPendingValueValidIndex >= 0) {\n      // Since we are not allowing freeform, we must have a matching\n      // to be able to update state\n      this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\n    } else if (currentPendingValueValidIndexOnHover >= 0) {\n      // If all else failed and we were hovering over an item, select it\n      this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\n    }\n\n    // Finally, clear the pending info\n    this._clearPendingInfo();\n  }\n\n  // Render Callout container and pass in list\n  private _onRenderContainer = (props: IComboBoxProps): JSX.Element => {\n    const {\n      onRenderList,\n      calloutProps,\n      dropdownWidth,\n      dropdownMaxWidth,\n      onRenderUpperContent = this._onRenderUpperContent,\n      onRenderLowerContent = this._onRenderLowerContent,\n      useComboBoxAsMenuWidth,\n      persistMenu,\n      shouldRestoreFocus = true,\n    } = props;\n\n    const { isOpen } = this.state;\n    const id = this._id;\n\n    const comboBoxMenuWidth =\n      useComboBoxAsMenuWidth && this._comboBoxWrapper.current\n        ? this._comboBoxWrapper.current.clientWidth + 2\n        : undefined;\n\n    return (\n      <Callout\n        isBeakVisible={false}\n        gapSpace={0}\n        doNotLayer={false}\n        directionalHint={DirectionalHint.bottomLeftEdge}\n        directionalHintFixed={false}\n        {...calloutProps}\n        onLayerMounted={this._onLayerMounted}\n        className={css(this._classNames.callout, calloutProps?.className)}\n        target={this._comboBoxWrapper.current}\n        onDismiss={this._onDismiss}\n        onMouseDown={this._onCalloutMouseDown}\n        onScroll={this._onScroll}\n        setInitialFocus={false}\n        calloutWidth={\n          useComboBoxAsMenuWidth && this._comboBoxWrapper.current\n            ? comboBoxMenuWidth && comboBoxMenuWidth\n            : dropdownWidth\n        }\n        calloutMaxWidth={dropdownMaxWidth ? dropdownMaxWidth : comboBoxMenuWidth}\n        hidden={persistMenu ? !isOpen : undefined}\n        shouldRestoreFocus={shouldRestoreFocus}\n      >\n        {onRenderUpperContent(this.props, this._onRenderUpperContent)}\n        <div className={this._classNames.optionsContainerWrapper} ref={this._comboBoxMenu}>\n          {onRenderList?.({ ...props, id }, this._onRenderList)}\n        </div>\n        {onRenderLowerContent(this.props, this._onRenderLowerContent)}\n      </Callout>\n    );\n  };\n\n  private _onCalloutLayerMounted() {\n    // In persistMenu mode _onLayerMounted is only called once for the lifetime\n    // of the component. Any functionality required for callout \"on mount\" can\n    // go here so that we can also call it again during callout dismissal to reset\n    // object state.\n    this._gotMouseMove = false;\n  }\n\n  private _onLayerMounted = () => {\n    this._onCalloutLayerMounted();\n\n    if (this.props.calloutProps && this.props.calloutProps.onLayerMounted) {\n      this.props.calloutProps.onLayerMounted();\n    }\n  };\n\n  private _onRenderLabel = (onRenderLabelProps: IOnRenderComboBoxLabelProps): JSX.Element | null => {\n    const { label, disabled, required } = onRenderLabelProps.props;\n\n    if (label) {\n      return (\n        <Label id={this._id + '-label'} disabled={disabled} required={required} className={this._classNames.label}>\n          {label}\n          {onRenderLabelProps.multiselectAccessibleText && (\n            <span className={this._classNames.screenReaderText}>{onRenderLabelProps.multiselectAccessibleText}</span>\n          )}\n        </Label>\n      );\n    }\n\n    return null;\n  };\n\n  // Render List of items\n  private _onRenderList = (props: IComboBoxProps): JSX.Element => {\n    const { onRenderItem, options } = props;\n\n    const id = this._id;\n    return (\n      <div\n        id={id + '-list'}\n        className={this._classNames.optionsContainer}\n        aria-labelledby={id + '-label'}\n        role=\"listbox\"\n      >\n        {options.map(item => onRenderItem?.(item, this._onRenderItem))}\n      </div>\n    );\n  };\n\n  // Render items\n  private _onRenderItem = (item: IComboBoxOption): JSX.Element | null => {\n    switch (item.itemType) {\n      case SelectableOptionMenuItemType.Divider:\n        return this._renderSeparator(item);\n      case SelectableOptionMenuItemType.Header:\n        return this._renderHeader(item);\n      default:\n        return this._renderOption(item);\n    }\n  };\n\n  // Default _onRenderLowerContent function returns nothing\n  private _onRenderLowerContent = (): null => {\n    return null;\n  };\n\n  // Default _onRenderUpperContent function returns nothing\n  private _onRenderUpperContent = (): null => {\n    return null;\n  };\n\n  // Render separator\n  private _renderSeparator(item: IComboBoxOption): JSX.Element | null {\n    const { index, key } = item;\n\n    if (index && index > 0) {\n      return <div role=\"separator\" key={key} className={this._classNames.divider} />;\n    }\n    return null;\n  }\n\n  private _renderHeader(item: IComboBoxOption): JSX.Element {\n    const { onRenderOption = this._onRenderOptionContent } = this.props;\n\n    return (\n      <div key={item.key} className={this._classNames.header}>\n        {onRenderOption(item, this._onRenderOptionContent)}\n      </div>\n    );\n  }\n\n  private _renderOption = (item: IComboBoxOption): JSX.Element => {\n    const { onRenderOption = this._onRenderOptionContent } = this.props;\n    const id = this._id;\n    const isSelected: boolean = this._isOptionSelected(item.index);\n    const isChecked: boolean = this._isOptionChecked(item.index);\n    const optionStyles = this._getCurrentOptionStyles(item);\n    const optionClassNames = getComboBoxOptionClassNames(this._getCurrentOptionStyles(item));\n    const title = getPreviewText(item);\n\n    const onRenderCheckboxLabel = () => onRenderOption(item, this._onRenderOptionContent);\n\n    const getOptionComponent = () => {\n      return !this.props.multiSelect ? (\n        <CommandButton\n          id={id + '-list' + item.index}\n          key={item.key}\n          data-index={item.index}\n          styles={optionStyles}\n          checked={isSelected}\n          className={'ms-ComboBox-option'}\n          onClick={this._onItemClick(item)}\n          // eslint-disable-next-line react/jsx-no-bind\n          onMouseEnter={this._onOptionMouseEnter.bind(this, item.index)}\n          // eslint-disable-next-line react/jsx-no-bind\n          onMouseMove={this._onOptionMouseMove.bind(this, item.index)}\n          onMouseLeave={this._onOptionMouseLeave}\n          role=\"option\"\n          // aria-selected should only be applied to checked items, not hovered items\n          aria-selected={isChecked ? 'true' : 'false'}\n          ariaLabel={getPreviewText(item)}\n          disabled={item.disabled}\n          title={title}\n        >\n          {\n            <span className={optionClassNames.optionTextWrapper} ref={isSelected ? this._selectedElement : undefined}>\n              {onRenderOption(item, this._onRenderOptionContent)}\n            </span>\n          }\n        </CommandButton>\n      ) : (\n        <Checkbox\n          id={id + '-list' + item.index}\n          ariaLabel={getPreviewText(item)}\n          key={item.key}\n          styles={optionStyles}\n          className={'ms-ComboBox-option'}\n          onChange={this._onItemClick(item)}\n          label={item.text}\n          checked={isChecked}\n          title={title}\n          disabled={item.disabled}\n          // eslint-disable-next-line react/jsx-no-bind\n          onRenderLabel={onRenderCheckboxLabel}\n          inputProps={{\n            // aria-selected should only be applied to checked items, not hovered items\n            'aria-selected': isChecked ? 'true' : 'false',\n            role: 'option',\n            ...({\n              'data-index': item.index,\n              'data-is-focusable': true,\n            } as any),\n          }}\n        />\n      );\n    };\n\n    return (\n      <ComboBoxOptionWrapper\n        key={item.key}\n        index={item.index}\n        disabled={item.disabled}\n        isSelected={isSelected}\n        isChecked={isChecked}\n        text={item.text}\n        // eslint-disable-next-line react/jsx-no-bind\n        render={getOptionComponent}\n        data={item.data}\n      />\n    );\n  };\n\n  /**\n   * If we are coming from a mouseOut:\n   * there is no visible selected option.\n   *\n   * Else if We are hovering over an item:\n   * that gets the selected look.\n   *\n   * Else:\n   * Use the current valid pending index if it exists OR\n   * we do not have a valid index and we currently have a pending input value,\n   * otherwise use the selected index\n   * */\n  private _isOptionSelected(index: number | undefined): boolean {\n    const { currentPendingValueValidIndexOnHover } = this.state;\n\n    // If the hover state is set to clearAll, don't show a selected index.\n    // Note, this happens when the user moused out of the menu items\n    if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n      return false;\n    }\n\n    return this._getPendingSelectedIndex(true /* includePendingValue */) === index ? true : false;\n  }\n\n  private _isOptionChecked(index: number | undefined): boolean {\n    if (this.props.multiSelect && index !== undefined && this.props.hoisted.selectedIndices) {\n      let idxOfSelectedIndex = -1;\n\n      idxOfSelectedIndex = this.props.hoisted.selectedIndices.indexOf(index);\n      return idxOfSelectedIndex >= 0;\n    }\n    return false;\n  }\n\n  /**\n   * Gets the pending selected index taking into account hover, valueValidIndex, and selectedIndex\n   * @param includeCurrentPendingValue - Should we include the currentPendingValue when\n   * finding the index\n   */\n  private _getPendingSelectedIndex(includeCurrentPendingValue: boolean): number {\n    const { currentPendingValueValidIndexOnHover, currentPendingValueValidIndex, currentPendingValue } = this.state;\n\n    return currentPendingValueValidIndexOnHover >= 0\n      ? currentPendingValueValidIndexOnHover\n      : currentPendingValueValidIndex >= 0 ||\n        (includeCurrentPendingValue && currentPendingValue !== null && currentPendingValue !== undefined)\n      ? currentPendingValueValidIndex\n      : this.props.multiSelect\n      ? 0\n      : this._getFirstSelectedIndex();\n  }\n\n  /**\n   * Mouse clicks to headers, dividers and scrollbar should not make input lose focus\n   */\n  private _onCalloutMouseDown: ICalloutProps['onMouseDown'] = ev => {\n    ev.preventDefault();\n  };\n\n  /**\n   * Scroll handler for the callout to make sure the mouse events\n   * for updating focus are not interacting during scroll\n   */\n  private _onScroll = () => {\n    if (!this._isScrollIdle && this._scrollIdleTimeoutId !== undefined) {\n      this._async.clearTimeout(this._scrollIdleTimeoutId);\n      this._scrollIdleTimeoutId = undefined;\n    } else {\n      this._isScrollIdle = false;\n    }\n\n    this._scrollIdleTimeoutId = this._async.setTimeout(() => {\n      this._isScrollIdle = true;\n    }, ScrollIdleDelay);\n  };\n\n  /**\n   * Scroll the selected element into view\n   */\n  private _scrollIntoView(): void {\n    const { onScrollToItem, scrollSelectedToTop } = this.props;\n\n    const { currentPendingValueValidIndex, currentPendingValue } = this.state;\n\n    if (onScrollToItem) {\n      // Use the custom scroll handler\n      onScrollToItem(\n        currentPendingValueValidIndex >= 0 || currentPendingValue !== ''\n          ? currentPendingValueValidIndex\n          : this._getFirstSelectedIndex(),\n      );\n    } else if (this._selectedElement.current && this._selectedElement.current.offsetParent) {\n      // We are using refs, scroll the ref into view\n      if (scrollSelectedToTop) {\n        this._selectedElement.current.offsetParent.scrollIntoView(true);\n      } else {\n        let alignToTop = true;\n\n        if (this._comboBoxMenu.current && this._comboBoxMenu.current.offsetParent) {\n          const scrollableParentRect = this._comboBoxMenu.current.offsetParent.getBoundingClientRect();\n          const selectedElementRect = this._selectedElement.current.offsetParent.getBoundingClientRect();\n\n          // If we are completely in view then we do not need to scroll\n          if (\n            scrollableParentRect.top <= selectedElementRect.top &&\n            scrollableParentRect.top + scrollableParentRect.height >=\n              selectedElementRect.top + selectedElementRect.height\n          ) {\n            return;\n          }\n\n          // If we are lower than the scrollable parent viewport then we should align to the bottom\n          if (\n            scrollableParentRect.top + scrollableParentRect.height <=\n            selectedElementRect.top + selectedElementRect.height\n          ) {\n            alignToTop = false;\n          }\n        }\n\n        this._selectedElement.current.offsetParent.scrollIntoView(alignToTop);\n      }\n    }\n  }\n\n  private _onRenderOptionContent = (item: IComboBoxOption): JSX.Element => {\n    const optionClassNames = getComboBoxOptionClassNames(this._getCurrentOptionStyles(item));\n    return <span className={optionClassNames.optionText}>{item.text}</span>;\n  };\n\n  /**\n   * Click handler for the menu items\n   * to select the item and also close the menu\n   * @param index - the index of the item that was clicked\n   */\n  private _onItemClick(item: IComboBoxOption): (ev: React.MouseEvent<any>) => void {\n    const { onItemClick } = this.props;\n    const { index } = item;\n    return (ev: React.MouseEvent<any>): void => {\n      // only close the callout when it's in single-select mode\n      if (!this.props.multiSelect) {\n        // ensure that focus returns to the input, not the button\n        this._autofill.current && this._autofill.current.focus();\n        this.setState({\n          isOpen: false,\n        });\n      }\n\n      // Continue processing the click only after\n      // performing menu close / control focus(inner working)\n      onItemClick && onItemClick(ev, item, index);\n      this._setSelectedIndex(index as number, ev);\n    };\n  }\n\n  /**\n   * Handles dismissing (cancelling) the menu\n   */\n  private _onDismiss = (): void => {\n    const { onMenuDismiss } = this.props;\n    if (onMenuDismiss) {\n      onMenuDismiss();\n    }\n\n    // In persistMode we need to simulate callout layer mount\n    // since that only happens once. We do it on dismiss since\n    // it works either way.\n    if (this.props.persistMenu) {\n      this._onCalloutLayerMounted();\n    }\n\n    // close the menu\n    this._setOpenStateAndFocusOnClose(false /* isOpen */, false /* focusInputAfterClose */);\n\n    // reset the selected index\n    // to the last value state\n    this._resetSelectedIndex();\n  };\n\n  /**\n   * Reset the selected index by clearing the\n   * input (of any pending text), clearing the pending state,\n   * and setting the suggested display value to the last\n   * selected state text\n   */\n  private _resetSelectedIndex(): void {\n    const { currentOptions } = this.props.hoisted;\n    this._clearPendingInfo();\n\n    const selectedIndex: number = this._getFirstSelectedIndex();\n    if (selectedIndex > 0 && selectedIndex < currentOptions.length) {\n      this.props.hoisted.setSuggestedDisplayValue(currentOptions[selectedIndex].text);\n    } else if (this.props.text) {\n      // If we had a value initially, restore it\n      this.props.hoisted.setSuggestedDisplayValue(this.props.text);\n    }\n  }\n\n  /**\n   * Clears the pending info state\n   */\n  private _clearPendingInfo(): void {\n    this._processingClearPendingInfo = true;\n\n    this.props.hoisted.setSuggestedDisplayValue(undefined);\n    this.setState(\n      {\n        currentPendingValue: undefined,\n        currentPendingValueValidIndex: -1,\n        currentPendingValueValidIndexOnHover: HoverStatus.default,\n      },\n      this._onAfterClearPendingInfo,\n    );\n  }\n\n  private _onAfterClearPendingInfo = () => {\n    this._processingClearPendingInfo = false;\n  };\n\n  /**\n   * Set the pending info\n   * @param currentPendingValue - new pending value to set\n   * @param currentPendingValueValidIndex - new pending value index to set\n   * @param suggestedDisplayValue - new suggest display value to set\n   */\n  private _setPendingInfo(\n    currentPendingValue?: string,\n    currentPendingValueValidIndex: number = -1,\n    suggestedDisplayValue?: string,\n  ): void {\n    if (this._processingClearPendingInfo) {\n      return;\n    }\n\n    this.props.hoisted.setSuggestedDisplayValue(suggestedDisplayValue);\n    this.setState({\n      currentPendingValue: normalizeToString(currentPendingValue),\n      currentPendingValueValidIndex: currentPendingValueValidIndex,\n      currentPendingValueValidIndexOnHover: HoverStatus.default,\n    });\n  }\n\n  /**\n   * Set the pending info from the given index\n   * @param index - the index to set the pending info from\n   */\n  private _setPendingInfoFromIndex(index: number): void {\n    const { currentOptions } = this.props.hoisted;\n\n    if (index >= 0 && index < currentOptions.length) {\n      const option = currentOptions[index];\n      this._setPendingInfo(getPreviewText(option), index, getPreviewText(option));\n    } else {\n      this._clearPendingInfo();\n    }\n  }\n\n  /**\n   * Sets the pending info for the combo box\n   * @param index - the index to search from\n   * @param searchDirection - the direction to search\n   */\n  private _setPendingInfoFromIndexAndDirection(index: number, searchDirection: SearchDirection): void {\n    const { currentOptions } = this.props.hoisted;\n\n    // update index to allow content to wrap\n    if (searchDirection === SearchDirection.forward && index >= currentOptions.length - 1) {\n      index = -1;\n    } else if (searchDirection === SearchDirection.backward && index <= 0) {\n      index = currentOptions.length;\n    }\n\n    // get the next \"valid\" index\n    const indexUpdate = this._getNextSelectableIndex(index, searchDirection);\n\n    // if the two indices are equal we didn't move and\n    // we should attempt to get  get the first/last \"valid\" index to use\n    // (Note, this takes care of the potential cases where the first/last\n    // item is not focusable), otherwise use the updated index\n    if (index === indexUpdate) {\n      if (searchDirection === SearchDirection.forward) {\n        index = this._getNextSelectableIndex(-1, searchDirection);\n      } else if (searchDirection === SearchDirection.backward) {\n        index = this._getNextSelectableIndex(currentOptions.length, searchDirection);\n      }\n    } else {\n      index = indexUpdate;\n    }\n\n    if (indexWithinBounds(currentOptions, index)) {\n      this._setPendingInfoFromIndex(index);\n    }\n  }\n\n  private _notifyPendingValueChanged(prevState: IComboBoxState): void {\n    const { onPendingValueChanged } = this.props;\n\n    if (!onPendingValueChanged) {\n      return;\n    }\n\n    const { currentOptions } = this.props.hoisted;\n    const { currentPendingValue, currentPendingValueValidIndex, currentPendingValueValidIndexOnHover } = this.state;\n\n    let newPendingIndex: number | undefined = undefined;\n    let newPendingValue: string | undefined = undefined;\n\n    if (\n      currentPendingValueValidIndexOnHover !== prevState.currentPendingValueValidIndexOnHover &&\n      indexWithinBounds(currentOptions, currentPendingValueValidIndexOnHover)\n    ) {\n      // Set new pending index if hover index was changed\n      newPendingIndex = currentPendingValueValidIndexOnHover;\n    } else if (\n      currentPendingValueValidIndex !== prevState.currentPendingValueValidIndex &&\n      indexWithinBounds(currentOptions, currentPendingValueValidIndex)\n    ) {\n      // Set new pending index if currentPendingValueValidIndex was changed\n      newPendingIndex = currentPendingValueValidIndex;\n    } else if (currentPendingValue !== prevState.currentPendingValue) {\n      // Set pendingValue in the case it was changed and no index was changed\n      newPendingValue = currentPendingValue;\n    }\n\n    // Notify when there is a new pending index/value. Also, if there is a pending value, it needs to send undefined.\n    if (newPendingIndex !== undefined || newPendingValue !== undefined || this._hasPendingValue) {\n      onPendingValueChanged(\n        newPendingIndex !== undefined ? currentOptions[newPendingIndex] : undefined,\n        newPendingIndex,\n        newPendingValue,\n      );\n      this._hasPendingValue = newPendingIndex !== undefined || newPendingValue !== undefined;\n    }\n  }\n\n  /**\n   * Sets the isOpen state and updates focusInputAfterClose\n   */\n  private _setOpenStateAndFocusOnClose(isOpen: boolean, focusInputAfterClose: boolean): void {\n    this._focusInputAfterClose = focusInputAfterClose;\n    this.setState({\n      isOpen: isOpen,\n    });\n  }\n\n  /**\n   * Handle keydown on the input\n   * @param ev - The keyboard event that was fired\n   */\n  private _onInputKeyDown = (ev: React.KeyboardEvent<HTMLElement | Autofill>): void => {\n    const {\n      disabled,\n      allowFreeform,\n      autoComplete,\n      hoisted: { currentOptions },\n    } = this.props;\n    const { isOpen, currentPendingValueValidIndexOnHover } = this.state;\n\n    // Take note if we are processing an alt (option) or meta (command) keydown.\n    // See comment in _onInputKeyUp for reasoning.\n    this._lastKeyDownWasAltOrMeta = isAltOrMeta(ev);\n\n    if (disabled) {\n      this._handleInputWhenDisabled(ev);\n      return;\n    }\n\n    let index = this._getPendingSelectedIndex(false /* includeCurrentPendingValue */);\n\n    // eslint-disable-next-line deprecation/deprecation\n    switch (ev.which) {\n      case KeyCodes.enter:\n        if (this._autofill.current && this._autofill.current.inputElement) {\n          this._autofill.current.inputElement.select();\n        }\n\n        this._submitPendingValue(ev);\n        if (this.props.multiSelect && isOpen) {\n          this.setState({\n            currentPendingValueValidIndex: index,\n          });\n        } else {\n          // On enter submit the pending value\n          if (\n            isOpen ||\n            ((!allowFreeform ||\n              this.state.currentPendingValue === undefined ||\n              this.state.currentPendingValue === null ||\n              this.state.currentPendingValue.length <= 0) &&\n              this.state.currentPendingValueValidIndex < 0)\n          ) {\n            // if we are open or\n            // if we are not allowing freeform or\n            // our we have no pending value\n            // and no valid pending index\n            // flip the open state\n            this.setState({\n              isOpen: !isOpen,\n            });\n          }\n        }\n        break;\n\n      case KeyCodes.tab:\n        // On enter submit the pending value\n        if (!this.props.multiSelect) {\n          this._submitPendingValue(ev);\n        }\n\n        // If we are not allowing freeform\n        // or the combo box is open, flip the open state\n        if (isOpen) {\n          this._setOpenStateAndFocusOnClose(!isOpen, false /* focusInputAfterClose */);\n        }\n\n        // Allow TAB to propagate\n        return;\n\n      case KeyCodes.escape:\n        // reset the selected index\n        this._resetSelectedIndex();\n\n        // Close the menu if opened\n        if (isOpen) {\n          this.setState({\n            isOpen: false,\n          });\n        } else {\n          return;\n        }\n        break;\n\n      case KeyCodes.up:\n        // if we are in clearAll state (e.g. the user as hovering\n        // and has since mousedOut of the menu items),\n        // go to the last index\n        if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n          index = this.props.hoisted.currentOptions.length;\n        }\n\n        if (ev.altKey || ev.metaKey) {\n          // Close the menu if it is open and break so\n          // that the event get stopPropagation and prevent default.\n          // Otherwise, we need to let the event continue to propagate\n          if (isOpen) {\n            this._setOpenStateAndFocusOnClose(!isOpen, true /* focusInputAfterClose */);\n            break;\n          }\n\n          return;\n        }\n\n        // Go to the previous option\n        this._setPendingInfoFromIndexAndDirection(index, SearchDirection.backward);\n        break;\n\n      case KeyCodes.down:\n        // Expand the combo box on ALT + DownArrow\n        if (ev.altKey || ev.metaKey) {\n          this._setOpenStateAndFocusOnClose(true /* isOpen */, true /* focusInputAfterClose */);\n        } else {\n          // if we are in clearAll state (e.g. the user as hovering\n          // and has since mousedOut of the menu items),\n          // go to the first index\n          if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n            index = -1;\n          }\n\n          // Got to the next option\n          this._setPendingInfoFromIndexAndDirection(index, SearchDirection.forward);\n        }\n        break;\n\n      case KeyCodes.home:\n      case KeyCodes.end:\n        if (allowFreeform) {\n          return;\n        }\n\n        // Set the initial values to respond to HOME\n        // which goes to the first selectable option\n        index = -1;\n        let directionToSearch = SearchDirection.forward;\n\n        // If end, update the values to respond to END\n        // which goes to the last selectable option\n        // eslint-disable-next-line deprecation/deprecation\n        if (ev.which === KeyCodes.end) {\n          index = currentOptions.length;\n          directionToSearch = SearchDirection.backward;\n        }\n\n        this._setPendingInfoFromIndexAndDirection(index, directionToSearch);\n        break;\n\n      /* eslint-disable no-fallthrough */\n      case KeyCodes.space:\n        // event handled in _onComboBoxKeyUp\n        if (!allowFreeform && autoComplete === 'off') {\n          break;\n        }\n\n      default:\n        /* eslint-enable no-fallthrough */\n        // are we processing a function key? if so bail out\n        // eslint-disable-next-line deprecation/deprecation\n        if (ev.which >= 112 /* F1 */ && ev.which <= 123 /* F12 */) {\n          return;\n        }\n\n        // If we get here and we got either and ALT key\n        // or meta key, let the event propagate\n        if (ev.keyCode === KeyCodes.alt || ev.key === 'Meta' /* && isOpen */) {\n          return;\n        }\n\n        // If we are not allowing freeform and\n        // allowing autoComplete, handle the input here\n        // since we have marked the input as readonly\n        if (!allowFreeform && autoComplete === 'on') {\n          this._onInputChange(ev.key);\n          break;\n        }\n\n        // allow the key to propagate by default\n        return;\n    }\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n\n  /**\n   * Handle keyup on the input\n   * @param ev - the keyboard event that was fired\n   */\n  private _onInputKeyUp = (ev: React.KeyboardEvent<HTMLElement | Autofill>): void => {\n    const { disabled, allowFreeform, autoComplete } = this.props;\n    const isOpen = this.state.isOpen;\n\n    // We close the menu on key up only if ALL of the following are true:\n    // - Most recent key down was alt or meta (command)\n    // - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n    //   expand/collapse the menu)\n    // - We're not on a Mac (or iOS)\n    // This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n    // closing any open context menus. There is not a similar behavior on Macs.\n    const keyPressIsAltOrMetaAlone = this._lastKeyDownWasAltOrMeta && isAltOrMeta(ev);\n    this._lastKeyDownWasAltOrMeta = false;\n    const shouldHandleKey = keyPressIsAltOrMetaAlone && !(isMac() || isIOS());\n\n    if (disabled) {\n      this._handleInputWhenDisabled(ev);\n      return;\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    switch (ev.which) {\n      case KeyCodes.space:\n        // If we are not allowing freeform and are not autoComplete\n        // make space expand/collapse the combo box\n        // and allow the event to propagate\n        if (!allowFreeform && autoComplete === 'off') {\n          this._setOpenStateAndFocusOnClose(!isOpen, !!isOpen);\n        }\n        return;\n      default:\n        if (shouldHandleKey && isOpen) {\n          this._setOpenStateAndFocusOnClose(!isOpen, true /* focusInputAfterClose */);\n        } else {\n          if (this.state.focusState === 'focusing' && this.props.openOnKeyboardFocus) {\n            this.setState({ isOpen: true });\n          }\n          if (this.state.focusState !== 'focused') {\n            this.setState({ focusState: 'focused' });\n          }\n        }\n        return;\n    }\n  };\n\n  private _onOptionMouseEnter(index: number): void {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValueValidIndexOnHover: index,\n    });\n  }\n\n  private _onOptionMouseMove(index: number): void {\n    this._gotMouseMove = true;\n\n    if (!this._isScrollIdle || this.state.currentPendingValueValidIndexOnHover === index) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValueValidIndexOnHover: index,\n    });\n  }\n\n  private _onOptionMouseLeave = () => {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    // Ignore the event in persistMenu mode if the callout has\n    // closed. This is to avoid clearing the visuals on item click.\n    if (this.props.persistMenu && !this.state.isOpen) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValueValidIndexOnHover: HoverStatus.clearAll,\n    });\n  };\n\n  private _shouldIgnoreMouseEvent(): boolean {\n    return !this._isScrollIdle || !this._gotMouseMove;\n  }\n\n  /**\n   * Handle dismissing the menu and eating the required key event when disabled\n   * @param ev - the keyboard event that was fired\n   */\n  private _handleInputWhenDisabled(ev: React.KeyboardEvent<HTMLElement | Autofill> | null): void {\n    // If we are disabled, close the menu (if needed)\n    // and eat all keystrokes other than TAB or ESC\n    if (this.props.disabled) {\n      if (this.state.isOpen) {\n        this.setState({ isOpen: false });\n      }\n\n      // When disabled stop propagation and prevent default\n      // of the event unless we have a tab, escape, or function key\n      if (\n        ev !== null &&\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which !== KeyCodes.tab &&\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which !== KeyCodes.escape &&\n        // eslint-disable-next-line deprecation/deprecation\n        (ev.which < 112 /* F1 */ || ev.which > 123) /* F12 */\n      ) {\n        ev.stopPropagation();\n        ev.preventDefault();\n      }\n    }\n  }\n\n  /**\n   * Click handler for the button of the combo box and the input when not allowing freeform.\n   * This toggles the expand/collapse state of the combo box (if enabled).\n   */\n  private _onComboBoxClick = (): void => {\n    const { disabled } = this.props;\n    const { isOpen } = this.state;\n\n    if (!disabled) {\n      this._setOpenStateAndFocusOnClose(!isOpen, false /* focusInputAfterClose */);\n      this.setState({ focusState: 'focused' });\n    }\n  };\n\n  /**\n   * Click handler for the autofill.\n   */\n  private _onAutofillClick = (): void => {\n    const { disabled, allowFreeform } = this.props;\n    if (allowFreeform && !disabled) {\n      this.focus(this.state.isOpen || this._processingTouch);\n    } else {\n      this._onComboBoxClick();\n    }\n  };\n\n  private _onTouchStart: () => void = () => {\n    if (this._comboBoxWrapper.current && !('onpointerdown' in this._comboBoxWrapper)) {\n      this._handleTouchAndPointerEvent();\n    }\n  };\n\n  private _onPointerDown = (ev: PointerEvent): void => {\n    if (ev.pointerType === 'touch') {\n      this._handleTouchAndPointerEvent();\n\n      ev.preventDefault();\n      ev.stopImmediatePropagation();\n    }\n  };\n\n  private _handleTouchAndPointerEvent() {\n    // If we already have an existing timeout from a previous touch and pointer event\n    // cancel that timeout so we can set a nwe one.\n    if (this._lastTouchTimeoutId !== undefined) {\n      this._async.clearTimeout(this._lastTouchTimeoutId);\n      this._lastTouchTimeoutId = undefined;\n    }\n    this._processingTouch = true;\n\n    this._lastTouchTimeoutId = this._async.setTimeout(() => {\n      this._processingTouch = false;\n      this._lastTouchTimeoutId = undefined;\n    }, TouchIdleDelay);\n  }\n\n  /**\n   * Get the styles for the current option.\n   * @param item - Item props for the current option\n   */\n  private _getCaretButtonStyles(): IButtonStyles {\n    const { caretDownButtonStyles: customCaretDownButtonStyles } = this.props;\n    return getCaretDownButtonStyles(this.props.theme!, customCaretDownButtonStyles);\n  }\n\n  /**\n   * Get the styles for the current option.\n   * @param item - Item props for the current option\n   */\n  private _getCurrentOptionStyles(item: IComboBoxOption): Partial<IComboBoxOptionStyles> {\n    const { comboBoxOptionStyles: customStylesForAllOptions } = this.props;\n    const { styles: customStylesForCurrentOption } = item;\n\n    return getOptionStyles(\n      this.props.theme!,\n      customStylesForAllOptions,\n      customStylesForCurrentOption,\n      this._isPendingOption(item),\n      item.hidden,\n    );\n  }\n\n  /**\n   * Get the aria-activedescendant value for the combo box.\n   * @returns the id of the current focused combo item, otherwise the id of the currently selected element,\n   * null otherwise\n   */\n  private _getAriaActiveDescendantValue(): string | undefined {\n    const { selectedIndices } = this.props.hoisted;\n    const { isOpen, currentPendingValueValidIndex } = this.state;\n    let descendantText = isOpen && selectedIndices?.length ? this._id + '-list' + selectedIndices[0] : undefined;\n    if (isOpen && this._hasFocus() && currentPendingValueValidIndex !== -1) {\n      descendantText = this._id + '-list' + currentPendingValueValidIndex;\n    }\n    return descendantText;\n  }\n\n  /**\n   * Get the aria autocomplete value for the combo box\n   * @returns 'inline' if auto-complete automatically dynamic, 'both' if we have a list of possible values to pick from\n   * and can dynamically populate input, and 'none' if auto-complete is not enabled as we can't give user inputs.\n   */\n  private _getAriaAutoCompleteValue(): 'none' | 'inline' | 'list' | 'both' | undefined {\n    const autoComplete = !this.props.disabled && this.props.autoComplete === 'on';\n    return autoComplete ? (this.props.allowFreeform ? 'inline' : 'both') : 'none';\n  }\n\n  private _isPendingOption(item: IComboBoxOption): boolean {\n    return item && item.index === this.state.currentPendingValueValidIndex;\n  }\n\n  /**\n   * Returns true if the component has some kind of focus. If it's either focusing or if it's focused\n   */\n  private _hasFocus() {\n    return this.state.focusState !== 'none';\n  }\n}\n\n/**\n * Get the indices of the options that are marked as selected\n * @param options - the combo box options\n * @param selectedKeys - the known selected keys to find\n * @returns - an array of the indices of the selected options, empty array if nothing is selected\n */\nfunction getSelectedIndices(\n  options: IComboBoxOption[] | undefined,\n  selectedKeys: (string | number | undefined)[],\n): number[] {\n  if (!options || !selectedKeys) {\n    return [];\n  }\n\n  const selectedIndices: { [key: number]: boolean } = {};\n  options.forEach((option: IComboBoxOption, index: number) => {\n    if (option.selected) {\n      selectedIndices[index] = true;\n    }\n  });\n\n  for (const selectedKey of selectedKeys) {\n    const index = findIndex(options, option => option.key === selectedKey);\n    if (index > -1) {\n      selectedIndices[index] = true;\n    }\n  }\n\n  return Object.keys(selectedIndices)\n    .map(Number)\n    .sort();\n}\n\n/**\n * Given default selected key(s) and selected key(s), return the selected keys(s).\n * When default selected key(s) are available, they take precedence and return them instead of selected key(s).\n *\n * @returns No matter what specific types the input parameters are, always return an array of\n *  either strings or numbers instead of primitive type.  This normalization makes caller's logic easier.\n */\nfunction buildDefaultSelectedKeys(\n  defaultSelectedKey: string | number | string[] | number[] | null | undefined,\n  selectedKey: string | number | string[] | number[] | null | undefined,\n): string[] | number[] {\n  const selectedKeys: string[] | number[] = buildSelectedKeys(defaultSelectedKey);\n  if (selectedKeys.length) {\n    return selectedKeys;\n  }\n  return buildSelectedKeys(selectedKey);\n}\n\nfunction buildSelectedKeys(selectedKey: string | number | string[] | number[] | null | undefined): string[] | number[] {\n  if (selectedKey === undefined) {\n    return [];\n  }\n\n  // need to cast here so typescript does not complain\n  return (selectedKey instanceof Array ? selectedKey : [selectedKey]) as string[] | number[];\n}\n\nfunction normalizeToString(value: string | undefined) {\n  return value || '';\n}\n\n/**\n * Is the index within the bounds of the array?\n * @param options - options to check if the index is valid for\n * @param index - the index to check\n * @returns - true if the index is valid for the given options, false otherwise\n */\nfunction indexWithinBounds(options: IComboBoxOption[] | undefined, index: number): boolean {\n  return !!options && index >= 0 && index < options.length;\n}\n\n/** Whether this is a normal option, not a header or divider. */\nfunction isNormalOption(option: IComboBoxOption) {\n  return (\n    option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider\n  );\n}\n\n/**\n * For scenarios where the option's `text` prop contains embedded styles, we use the option's\n * `ariaLabel` value as the text in the input and for autocomplete matching. We know to use this\n * when the `useAriaLabelAsText` prop is set to true.\n */\nfunction getPreviewText(item: IComboBoxOption): string {\n  return item.useAriaLabelAsText && item.ariaLabel ? item.ariaLabel : item.text;\n}\n\n/**\n * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n */\nfunction isAltOrMeta(ev: React.KeyboardEvent<HTMLElement | Autofill>): boolean {\n  // eslint-disable-next-line deprecation/deprecation\n  return ev.which === KeyCodes.alt || ev.key === 'Meta';\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}