{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, getNativeProps, imgProperties } from '../../Utilities';\nimport { ImageCoverStyle, ImageFit, ImageLoadState } from './Image.types';\nimport { useMergedRefs } from '@fluentui/react-hooks';\nvar getClassNames = classNamesFunction();\nvar SVG_REGEX = /\\.svg$/i;\nvar KEY_PREFIX = 'fabricImage';\n\nfunction useLoadState(props, imageElement) {\n  var onLoadingStateChange = props.onLoadingStateChange,\n      onLoad = props.onLoad,\n      onError = props.onError,\n      src = props.src;\n\n  var _a = React.useState(ImageLoadState.notLoaded),\n      loadState = _a[0],\n      setLoadState = _a[1]; // eslint-disable-next-line no-restricted-properties\n\n\n  React.useLayoutEffect(function () {\n    // If the src property changes, reset the load state\n    // (does nothing if the load state is already notLoaded)\n    setLoadState(ImageLoadState.notLoaded);\n  }, [src]); // eslint-disable-next-line react-hooks/exhaustive-deps -- intended to run every render\n\n  React.useEffect(function () {\n    if (loadState === ImageLoadState.notLoaded) {\n      // testing if naturalWidth and naturalHeight are greater than zero is better than checking\n      // .complete, because .complete will also be set to true if the image breaks. However,\n      // for some browsers, SVG images do not have a naturalWidth or naturalHeight, so fall back\n      // to checking .complete for these images.\n      var isLoaded = imageElement.current ? src && imageElement.current.naturalWidth > 0 && imageElement.current.naturalHeight > 0 || imageElement.current.complete && SVG_REGEX.test(src) : false;\n\n      if (isLoaded) {\n        setLoadState(ImageLoadState.loaded);\n      }\n    }\n  });\n  React.useEffect(function () {\n    var _a;\n\n    (_a = onLoadingStateChange) === null || _a === void 0 ? void 0 : _a(loadState); // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run when loadState changes\n  }, [loadState]);\n  var onImageLoaded = React.useCallback(function (ev) {\n    var _a;\n\n    (_a = onLoad) === null || _a === void 0 ? void 0 : _a(ev);\n\n    if (src) {\n      setLoadState(ImageLoadState.loaded);\n    }\n  }, [src, onLoad]);\n  var onImageError = React.useCallback(function (ev) {\n    var _a;\n\n    (_a = onError) === null || _a === void 0 ? void 0 : _a(ev);\n    setLoadState(ImageLoadState.error);\n  }, [onError]);\n  return [loadState, onImageLoaded, onImageError];\n}\n\nexport var ImageBase = React.forwardRef(function (props, forwardedRef) {\n  var frameElement = React.useRef();\n  var imageElement = React.useRef();\n\n  var _a = useLoadState(props, imageElement),\n      loadState = _a[0],\n      onImageLoaded = _a[1],\n      onImageError = _a[2];\n\n  var imageProps = getNativeProps(props, imgProperties, ['width', 'height']);\n  var src = props.src,\n      alt = props.alt,\n      width = props.width,\n      height = props.height,\n      _b = props.shouldFadeIn,\n      shouldFadeIn = _b === void 0 ? true : _b,\n      shouldStartVisible = props.shouldStartVisible,\n      className = props.className,\n      imageFit = props.imageFit,\n      role = props.role,\n      maximizeFrame = props.maximizeFrame,\n      styles = props.styles,\n      theme = props.theme,\n      loading = props.loading;\n  var coverStyle = useCoverStyle(props, loadState, imageElement, frameElement);\n  var classNames = getClassNames(styles, {\n    theme: theme,\n    className: className,\n    width: width,\n    height: height,\n    maximizeFrame: maximizeFrame,\n    shouldFadeIn: shouldFadeIn,\n    shouldStartVisible: shouldStartVisible,\n    isLoaded: loadState === ImageLoadState.loaded || loadState === ImageLoadState.notLoaded && props.shouldStartVisible,\n    isLandscape: coverStyle === ImageCoverStyle.landscape,\n    isCenter: imageFit === ImageFit.center,\n    isCenterContain: imageFit === ImageFit.centerContain,\n    isCenterCover: imageFit === ImageFit.centerCover,\n    isContain: imageFit === ImageFit.contain,\n    isCover: imageFit === ImageFit.cover,\n    isNone: imageFit === ImageFit.none,\n    isError: loadState === ImageLoadState.error,\n    isNotImageFit: imageFit === undefined\n  }); // If image dimensions aren't specified, the natural size of the image is used.\n\n  return React.createElement(\"div\", {\n    className: classNames.root,\n    style: {\n      width: width,\n      height: height\n    },\n    ref: frameElement\n  }, React.createElement(\"img\", __assign({}, imageProps, {\n    onLoad: onImageLoaded,\n    onError: onImageError,\n    key: KEY_PREFIX + props.src || '',\n    className: classNames.image,\n    ref: useMergedRefs(imageElement, forwardedRef),\n    src: src,\n    alt: alt,\n    role: role,\n    loading: loading\n  })));\n});\nImageBase.displayName = 'ImageBase';\n\nfunction useCoverStyle(props, loadState, imageElement, frameElement) {\n  var previousLoadState = React.useRef(loadState);\n  var coverStyle = React.useRef();\n\n  if (coverStyle === undefined || previousLoadState.current === ImageLoadState.notLoaded && loadState === ImageLoadState.loaded) {\n    coverStyle.current = computeCoverStyle(props, loadState, imageElement, frameElement);\n  }\n\n  previousLoadState.current = loadState;\n  return coverStyle.current;\n}\n\nfunction computeCoverStyle(props, loadState, imageElement, frameElement) {\n  var imageFit = props.imageFit,\n      width = props.width,\n      height = props.height; // Do not compute cover style if it was already specified in props\n\n  if (props.coverStyle !== undefined) {\n    return props.coverStyle;\n  } else if (loadState === ImageLoadState.loaded && (imageFit === ImageFit.cover || imageFit === ImageFit.contain || imageFit === ImageFit.centerContain || imageFit === ImageFit.centerCover) && imageElement.current && frameElement.current) {\n    // Determine the desired ratio using the width and height props.\n    // If those props aren't available, measure measure the frame.\n    var desiredRatio = void 0;\n\n    if (typeof width === 'number' && typeof height === 'number' && imageFit !== ImageFit.centerContain && imageFit !== ImageFit.centerCover) {\n      desiredRatio = width / height;\n    } else {\n      desiredRatio = frameElement.current.clientWidth / frameElement.current.clientHeight;\n    } // Examine the source image to determine its original ratio.\n\n\n    var naturalRatio = imageElement.current.naturalWidth / imageElement.current.naturalHeight; // Should we crop from the top or the sides?\n\n    if (naturalRatio > desiredRatio) {\n      return ImageCoverStyle.landscape;\n    }\n  }\n\n  return ImageCoverStyle.portrait;\n}","map":{"version":3,"sources":["components/Image/Image.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { classNamesFunction, getNativeProps, imgProperties } from '../../Utilities';\nimport { IImageProps, IImageStyleProps, IImageStyles, ImageCoverStyle, ImageFit, ImageLoadState } from './Image.types';\nimport { useMergedRefs } from '@fluentui/react-hooks';\n\nconst getClassNames = classNamesFunction<IImageStyleProps, IImageStyles>();\n\nexport interface IImageState {\n  loadState?: ImageLoadState;\n}\n\nconst SVG_REGEX = /\\.svg$/i;\nconst KEY_PREFIX = 'fabricImage';\n\nfunction useLoadState(\n  props: IImageProps,\n  imageElement: React.RefObject<HTMLImageElement>,\n): readonly [\n  ImageLoadState,\n  /* onImageLoad */ (ev: React.SyntheticEvent<HTMLImageElement>) => void,\n  /* onImageError */ (ev: React.SyntheticEvent<HTMLImageElement>) => void,\n] {\n  const { onLoadingStateChange, onLoad, onError, src } = props;\n\n  const [loadState, setLoadState] = React.useState<ImageLoadState>(ImageLoadState.notLoaded);\n\n  // eslint-disable-next-line no-restricted-properties\n  React.useLayoutEffect(() => {\n    // If the src property changes, reset the load state\n    // (does nothing if the load state is already notLoaded)\n    setLoadState(ImageLoadState.notLoaded);\n  }, [src]);\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps -- intended to run every render\n  React.useEffect(() => {\n    if (loadState === ImageLoadState.notLoaded) {\n      // testing if naturalWidth and naturalHeight are greater than zero is better than checking\n      // .complete, because .complete will also be set to true if the image breaks. However,\n      // for some browsers, SVG images do not have a naturalWidth or naturalHeight, so fall back\n      // to checking .complete for these images.\n      const isLoaded: boolean = imageElement.current\n        ? (src && imageElement.current.naturalWidth > 0 && imageElement.current.naturalHeight > 0) ||\n          (imageElement.current.complete && SVG_REGEX.test(src!))\n        : false;\n\n      if (isLoaded) {\n        setLoadState(ImageLoadState.loaded);\n      }\n    }\n  });\n\n  React.useEffect(() => {\n    onLoadingStateChange?.(loadState);\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run when loadState changes\n  }, [loadState]);\n\n  const onImageLoaded = React.useCallback(\n    (ev: React.SyntheticEvent<HTMLImageElement>) => {\n      onLoad?.(ev);\n      if (src) {\n        setLoadState(ImageLoadState.loaded);\n      }\n    },\n    [src, onLoad],\n  );\n\n  const onImageError = React.useCallback(\n    (ev: React.SyntheticEvent<HTMLImageElement>) => {\n      onError?.(ev);\n      setLoadState(ImageLoadState.error);\n    },\n    [onError],\n  );\n\n  return [loadState, onImageLoaded, onImageError] as const;\n}\n\nexport const ImageBase: React.FunctionComponent<IImageProps> = React.forwardRef<HTMLImageElement, IImageProps>(\n  (props, forwardedRef) => {\n    const frameElement = React.useRef<HTMLDivElement>() as React.RefObject<HTMLDivElement>;\n    const imageElement = React.useRef<HTMLImageElement>() as React.RefObject<HTMLImageElement>;\n    const [loadState, onImageLoaded, onImageError] = useLoadState(props, imageElement);\n\n    const imageProps = getNativeProps<React.ImgHTMLAttributes<HTMLImageElement>>(props, imgProperties, [\n      'width',\n      'height',\n    ]);\n    const {\n      src,\n      alt,\n      width,\n      height,\n      shouldFadeIn = true,\n      shouldStartVisible,\n      className,\n      imageFit,\n      role,\n      maximizeFrame,\n      styles,\n      theme,\n      loading,\n    } = props;\n    const coverStyle = useCoverStyle(props, loadState, imageElement, frameElement);\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n      width,\n      height,\n      maximizeFrame,\n      shouldFadeIn,\n      shouldStartVisible,\n      isLoaded:\n        loadState === ImageLoadState.loaded || (loadState === ImageLoadState.notLoaded && props.shouldStartVisible),\n      isLandscape: coverStyle === ImageCoverStyle.landscape,\n      isCenter: imageFit === ImageFit.center,\n      isCenterContain: imageFit === ImageFit.centerContain,\n      isCenterCover: imageFit === ImageFit.centerCover,\n      isContain: imageFit === ImageFit.contain,\n      isCover: imageFit === ImageFit.cover,\n      isNone: imageFit === ImageFit.none,\n      isError: loadState === ImageLoadState.error,\n      isNotImageFit: imageFit === undefined,\n    });\n\n    // If image dimensions aren't specified, the natural size of the image is used.\n    return (\n      <div className={classNames.root} style={{ width: width, height: height }} ref={frameElement}>\n        <img\n          {...imageProps}\n          onLoad={onImageLoaded}\n          onError={onImageError}\n          key={KEY_PREFIX + props.src || ''}\n          className={classNames.image}\n          ref={useMergedRefs(imageElement, forwardedRef)}\n          src={src}\n          alt={alt}\n          role={role}\n          loading={loading}\n        />\n      </div>\n    );\n  },\n);\nImageBase.displayName = 'ImageBase';\n\nfunction useCoverStyle(\n  props: IImageProps,\n  loadState: ImageLoadState,\n  imageElement: React.RefObject<HTMLImageElement>,\n  frameElement: React.RefObject<HTMLDivElement>,\n) {\n  const previousLoadState = React.useRef(loadState);\n  const coverStyle = React.useRef<ImageCoverStyle | undefined>();\n\n  if (\n    coverStyle === undefined ||\n    (previousLoadState.current === ImageLoadState.notLoaded && loadState === ImageLoadState.loaded)\n  ) {\n    coverStyle.current = computeCoverStyle(props, loadState, imageElement, frameElement);\n  }\n\n  previousLoadState.current = loadState;\n\n  return coverStyle.current!;\n}\n\nfunction computeCoverStyle(\n  props: IImageProps,\n  loadState: ImageLoadState,\n  imageElement: React.RefObject<HTMLImageElement>,\n  frameElement: React.RefObject<HTMLDivElement>,\n): ImageCoverStyle {\n  const { imageFit, width, height } = props;\n\n  // Do not compute cover style if it was already specified in props\n  if (props.coverStyle !== undefined) {\n    return props.coverStyle;\n  } else if (\n    loadState === ImageLoadState.loaded &&\n    (imageFit === ImageFit.cover ||\n      imageFit === ImageFit.contain ||\n      imageFit === ImageFit.centerContain ||\n      imageFit === ImageFit.centerCover) &&\n    imageElement.current &&\n    frameElement.current\n  ) {\n    // Determine the desired ratio using the width and height props.\n    // If those props aren't available, measure measure the frame.\n    let desiredRatio;\n    if (\n      typeof width === 'number' &&\n      typeof height === 'number' &&\n      imageFit !== ImageFit.centerContain &&\n      imageFit !== ImageFit.centerCover\n    ) {\n      desiredRatio = width / height;\n    } else {\n      desiredRatio = frameElement.current.clientWidth / frameElement.current.clientHeight;\n    }\n\n    // Examine the source image to determine its original ratio.\n    const naturalRatio = imageElement.current.naturalWidth / imageElement.current.naturalHeight;\n\n    // Should we crop from the top or the sides?\n    if (naturalRatio > desiredRatio) {\n      return ImageCoverStyle.landscape;\n    }\n  }\n  return ImageCoverStyle.portrait;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}