{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, allowScrollOnElement, allowOverscrollOnElement, getPropsWithDefaults, KeyCodes, elementContains, EventGroup } from '../../Utilities';\nimport { FocusTrapZone } from '../../FocusTrapZone';\nimport { animationDuration } from './Modal.styles';\nimport { Overlay } from '../../Overlay';\nimport { Layer } from '../../Layer';\nimport { Popup } from '../../Popup';\nimport { ResponsiveMode, useResponsiveMode } from '../../ResponsiveMode';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { Icon } from '../../Icon';\nimport { DraggableZone } from '../../utilities/DraggableZone/index';\nimport { useWindow } from '@fluentui/react-window-provider';\nimport { useBoolean, useMergedRefs, useWarnings, useConst, useSetTimeout, useId, useUnmount } from '@fluentui/react-hooks';\nvar ZERO = {\n  x: 0,\n  y: 0\n};\nvar DEFAULT_PROPS = {\n  isOpen: false,\n  isDarkOverlay: true,\n  className: '',\n  containerClassName: ''\n};\nvar getClassNames = classNamesFunction();\n\nvar getMoveDelta = function (ev) {\n  var delta = 10;\n\n  if (ev.shiftKey) {\n    if (!ev.ctrlKey) {\n      delta = 50;\n    }\n  } else if (ev.ctrlKey) {\n    delta = 1;\n  }\n\n  return delta;\n};\n\nvar useComponentRef = function (props, focusTrapZone) {\n  React.useImperativeHandle(props.componentRef, function () {\n    return {\n      focus: function () {\n        if (focusTrapZone.current) {\n          focusTrapZone.current.focus();\n        }\n      }\n    };\n  }, [focusTrapZone]);\n};\n\nexport var ModalBase = React.forwardRef(function (propsWithoutDefaults, ref) {\n  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n  var allowTouchBodyScroll = props.allowTouchBodyScroll,\n      className = props.className,\n      children = props.children,\n      containerClassName = props.containerClassName,\n      scrollableContentClassName = props.scrollableContentClassName,\n      elementToFocusOnDismiss = props.elementToFocusOnDismiss,\n      firstFocusableSelector = props.firstFocusableSelector,\n      forceFocusInsideTrap = props.forceFocusInsideTrap,\n      ignoreExternalFocusing = props.ignoreExternalFocusing,\n      isBlocking = props.isBlocking,\n      isClickableOutsideFocusTrap = props.isClickableOutsideFocusTrap,\n      isDarkOverlay = props.isDarkOverlay,\n      onDismiss = props.onDismiss,\n      layerProps = props.layerProps,\n      overlay = props.overlay,\n      isOpen = props.isOpen,\n      titleAriaId = props.titleAriaId,\n      styles = props.styles,\n      subtitleAriaId = props.subtitleAriaId,\n      theme = props.theme,\n      topOffsetFixed = props.topOffsetFixed,\n      responsiveMode = props.responsiveMode,\n      // eslint-disable-next-line deprecation/deprecation\n  onLayerDidMount = props.onLayerDidMount,\n      isModeless = props.isModeless,\n      dragOptions = props.dragOptions,\n      onDismissed = props.onDismissed,\n      enableAriaHiddenSiblings = props.enableAriaHiddenSiblings;\n  var rootRef = React.useRef(null);\n  var focusTrapZone = React.useRef(null);\n  var focusTrapZoneElm = React.useRef(null);\n  var mergedRef = useMergedRefs(rootRef, ref);\n  var modalResponsiveMode = useResponsiveMode(mergedRef);\n  var focusTrapZoneId = useId('ModalFocusTrapZone');\n  var win = useWindow();\n\n  var _a = useSetTimeout(),\n      setTimeout = _a.setTimeout,\n      clearTimeout = _a.clearTimeout;\n\n  var _b = React.useState(isOpen),\n      isModalOpen = _b[0],\n      setIsModalOpen = _b[1];\n\n  var _c = React.useState(isOpen),\n      isVisible = _c[0],\n      setIsVisible = _c[1];\n\n  var _d = React.useState(ZERO),\n      coordinates = _d[0],\n      setCoordinates = _d[1];\n\n  var _e = React.useState(),\n      modalRectangleTop = _e[0],\n      setModalRectangleTop = _e[1];\n\n  var _f = useBoolean(false),\n      isModalMenuOpen = _f[0],\n      _g = _f[1],\n      toggleModalMenuOpen = _g.toggle,\n      setModalMenuClose = _g.setFalse;\n\n  var internalState = useConst(function () {\n    return {\n      onModalCloseTimer: 0,\n      allowTouchBodyScroll: allowTouchBodyScroll,\n      scrollableContent: null,\n      lastSetCoordinates: ZERO,\n      events: new EventGroup({})\n    };\n  });\n  var keepInBounds = (dragOptions || {}).keepInBounds;\n  var layerClassName = layerProps === undefined ? '' : layerProps.className;\n  var classNames = getClassNames(styles, {\n    theme: theme,\n    className: className,\n    containerClassName: containerClassName,\n    scrollableContentClassName: scrollableContentClassName,\n    isOpen: isOpen,\n    isVisible: isVisible,\n    hasBeenOpened: internalState.hasBeenOpened,\n    modalRectangleTop: modalRectangleTop,\n    topOffsetFixed: topOffsetFixed,\n    isModeless: isModeless,\n    layerClassName: layerClassName,\n    windowInnerHeight: win === null || win === void 0 ? void 0 : win.innerHeight,\n    isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector\n  });\n\n  var mergedLayerProps = __assign(__assign({\n    eventBubblingEnabled: false\n  }, layerProps), {\n    onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount,\n    insertFirst: isModeless,\n    className: classNames.layer\n  }); // Allow the user to scroll within the modal but not on the body\n\n\n  var allowScrollOnModal = React.useCallback(function (elt) {\n    if (elt) {\n      if (internalState.allowTouchBodyScroll) {\n        allowOverscrollOnElement(elt, internalState.events);\n      } else {\n        allowScrollOnElement(elt, internalState.events);\n      }\n    } else {\n      internalState.events.off(internalState.scrollableContent);\n    }\n\n    internalState.scrollableContent = elt;\n  }, [internalState]);\n\n  var registerInitialModalPosition = function () {\n    var dialogMain = focusTrapZoneElm.current;\n    var modalRectangle = dialogMain === null || dialogMain === void 0 ? void 0 : dialogMain.getBoundingClientRect();\n\n    if (modalRectangle) {\n      if (topOffsetFixed) {\n        setModalRectangleTop(modalRectangle.top);\n      }\n\n      if (keepInBounds) {\n        // x/y are unavailable in IE, so use the equivalent left/top\n        internalState.minPosition = {\n          x: -modalRectangle.left,\n          y: -modalRectangle.top\n        };\n        internalState.maxPosition = {\n          x: modalRectangle.left,\n          y: modalRectangle.top\n        };\n      }\n    }\n  };\n  /**\n   * Clamps an axis to a specified min and max position.\n   *\n   * @param axis A string that represents the axis (x/y).\n   * @param position The position on the axis.\n   */\n\n\n  var getClampedAxis = React.useCallback(function (axis, position) {\n    var minPosition = internalState.minPosition,\n        maxPosition = internalState.maxPosition;\n\n    if (keepInBounds && minPosition && maxPosition) {\n      position = Math.max(minPosition[axis], position);\n      position = Math.min(maxPosition[axis], position);\n    }\n\n    return position;\n  }, [keepInBounds, internalState]);\n\n  var handleModalClose = function () {\n    var _a;\n\n    internalState.lastSetCoordinates = ZERO;\n    setModalMenuClose();\n    internalState.isInKeyboardMoveMode = false;\n    setIsModalOpen(false);\n    setCoordinates(ZERO);\n    (_a = internalState.disposeOnKeyUp) === null || _a === void 0 ? void 0 : _a.call(internalState);\n    onDismissed === null || onDismissed === void 0 ? void 0 : onDismissed();\n  };\n\n  var handleDragStart = React.useCallback(function () {\n    setModalMenuClose();\n    internalState.isInKeyboardMoveMode = false;\n  }, [internalState, setModalMenuClose]);\n  var handleDrag = React.useCallback(function (ev, dragData) {\n    setCoordinates(function (prevValue) {\n      return {\n        x: getClampedAxis('x', prevValue.x + dragData.delta.x),\n        y: getClampedAxis('y', prevValue.y + dragData.delta.y)\n      };\n    });\n  }, [getClampedAxis]);\n  var handleDragStop = React.useCallback(function () {\n    if (focusTrapZone.current) {\n      focusTrapZone.current.focus();\n    }\n  }, []);\n\n  var handleEnterKeyboardMoveMode = function () {\n    // We need a global handleKeyDown event when we are in the move mode so that we can\n    // handle the key presses and the components inside the modal do not get the events\n    var handleKeyDown = function (ev) {\n      if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n        // CTRL + ALT + SPACE is handled during keyUp\n        ev.preventDefault();\n        ev.stopPropagation();\n        return;\n      }\n\n      if (isModalMenuOpen && (ev.altKey || ev.keyCode === KeyCodes.escape)) {\n        setModalMenuClose();\n      }\n\n      if (internalState.isInKeyboardMoveMode && (ev.keyCode === KeyCodes.escape || ev.keyCode === KeyCodes.enter)) {\n        internalState.isInKeyboardMoveMode = false;\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n\n      if (internalState.isInKeyboardMoveMode) {\n        var handledEvent = true;\n        var delta_1 = getMoveDelta(ev);\n\n        switch (ev.keyCode) {\n          /* eslint-disable no-fallthrough */\n          case KeyCodes.escape:\n            setCoordinates(internalState.lastSetCoordinates);\n\n          case KeyCodes.enter:\n            {\n              // TODO: determine if fallthrough was intentional\n\n              /* eslint-enable no-fallthrough */\n              internalState.lastSetCoordinates = ZERO; // setIsInKeyboardMoveMode(false);\n\n              break;\n            }\n\n          case KeyCodes.up:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: prevValue.x,\n                  y: getClampedAxis('y', prevValue.y - delta_1)\n                };\n              });\n              break;\n            }\n\n          case KeyCodes.down:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: prevValue.x,\n                  y: getClampedAxis('y', prevValue.y + delta_1)\n                };\n              });\n              break;\n            }\n\n          case KeyCodes.left:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: getClampedAxis('x', prevValue.x - delta_1),\n                  y: prevValue.y\n                };\n              });\n              break;\n            }\n\n          case KeyCodes.right:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: getClampedAxis('x', prevValue.x + delta_1),\n                  y: prevValue.y\n                };\n              });\n              break;\n            }\n\n          default:\n            {\n              handledEvent = false;\n            }\n        }\n\n        if (handledEvent) {\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n\n    internalState.lastSetCoordinates = coordinates;\n    setModalMenuClose();\n    internalState.isInKeyboardMoveMode = true;\n    internalState.events.on(win, 'keydown', handleKeyDown, true\n    /* useCapture */\n    );\n\n    internalState.disposeOnKeyDown = function () {\n      internalState.events.off(win, 'keydown', handleKeyDown, true\n      /* useCapture */\n      );\n      internalState.disposeOnKeyDown = undefined;\n    };\n  };\n\n  var handleExitKeyboardMoveMode = function () {\n    var _a;\n\n    internalState.lastSetCoordinates = ZERO;\n    internalState.isInKeyboardMoveMode = false;\n    (_a = internalState.disposeOnKeyDown) === null || _a === void 0 ? void 0 : _a.call(internalState);\n  };\n\n  var registerForKeyUp = function () {\n    var handleKeyUp = function (ev) {\n      // Needs to handle the CTRL + ALT + SPACE key during keyup due to FireFox bug:\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n      if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n        if (elementContains(internalState.scrollableContent, ev.target)) {\n          toggleModalMenuOpen();\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n\n    if (!internalState.disposeOnKeyUp) {\n      internalState.events.on(win, 'keyup', handleKeyUp, true\n      /* useCapture */\n      );\n\n      internalState.disposeOnKeyUp = function () {\n        internalState.events.off(win, 'keyup', handleKeyUp, true\n        /* useCapture */\n        );\n        internalState.disposeOnKeyUp = undefined;\n      };\n    }\n  };\n\n  React.useEffect(function () {\n    clearTimeout(internalState.onModalCloseTimer); // Opening the dialog\n\n    if (isOpen) {\n      // This must be done after the modal content has rendered\n      requestAnimationFrame(function () {\n        return setTimeout(registerInitialModalPosition, 0);\n      });\n      setIsModalOpen(true); // Add a keyUp handler for all key up events once the dialog is open.\n\n      if (dragOptions) {\n        registerForKeyUp();\n      }\n\n      internalState.hasBeenOpened = true;\n      setIsVisible(true);\n    } // Closing the dialog\n\n\n    if (!isOpen && isModalOpen) {\n      internalState.onModalCloseTimer = setTimeout(handleModalClose, parseFloat(animationDuration) * 1000);\n      setIsVisible(false);\n    } // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if isModalOpen or isOpen mutates.\n\n  }, [isModalOpen, isOpen]);\n  useUnmount(function () {\n    internalState.events.dispose();\n  });\n  useComponentRef(props, focusTrapZone);\n  useDebugWarnings(props);\n  var modalContent = React.createElement(FocusTrapZone, {\n    id: focusTrapZoneId,\n    ref: focusTrapZoneElm,\n    componentRef: focusTrapZone,\n    className: classNames.main,\n    elementToFocusOnDismiss: elementToFocusOnDismiss,\n    isClickableOutsideFocusTrap: isModeless || isClickableOutsideFocusTrap || !isBlocking,\n    ignoreExternalFocusing: ignoreExternalFocusing,\n    forceFocusInsideTrap: isModeless ? !isModeless : forceFocusInsideTrap,\n    firstFocusableSelector: firstFocusableSelector,\n    focusPreviouslyFocusedInnerElement: true,\n    onBlur: internalState.isInKeyboardMoveMode ? handleExitKeyboardMoveMode : undefined,\n    enableAriaHiddenSiblings: enableAriaHiddenSiblings\n  }, dragOptions && internalState.isInKeyboardMoveMode && React.createElement(\"div\", {\n    className: classNames.keyboardMoveIconContainer\n  }, dragOptions.keyboardMoveIconProps ? React.createElement(Icon, __assign({}, dragOptions.keyboardMoveIconProps)) : React.createElement(Icon, {\n    iconName: \"move\",\n    className: classNames.keyboardMoveIcon\n  })), React.createElement(\"div\", {\n    ref: allowScrollOnModal,\n    className: classNames.scrollableContent,\n    \"data-is-scrollable\": true\n  }, dragOptions && isModalMenuOpen && React.createElement(dragOptions.menu, {\n    items: [{\n      key: 'move',\n      text: dragOptions.moveMenuItemText,\n      onClick: handleEnterKeyboardMoveMode\n    }, {\n      key: 'close',\n      text: dragOptions.closeMenuItemText,\n      onClick: handleModalClose\n    }],\n    onDismiss: setModalMenuClose,\n    alignTargetEdge: true,\n    coverTarget: true,\n    directionalHint: DirectionalHint.topLeftEdge,\n    directionalHintFixed: true,\n    shouldFocusOnMount: true,\n    target: internalState.scrollableContent\n  }), children));\n  return isModalOpen && modalResponsiveMode >= (responsiveMode || ResponsiveMode.small) && React.createElement(Layer, __assign({\n    ref: mergedRef\n  }, mergedLayerProps), React.createElement(Popup, {\n    role: isModeless || !isBlocking ? 'dialog' : 'alertdialog',\n    \"aria-modal\": !isModeless,\n    ariaLabelledBy: titleAriaId,\n    ariaDescribedBy: subtitleAriaId,\n    onDismiss: onDismiss,\n    shouldRestoreFocus: !ignoreExternalFocusing\n  }, React.createElement(\"div\", {\n    className: classNames.root,\n    role: !isModeless ? 'document' : undefined\n  }, !isModeless && React.createElement(Overlay, __assign({\n    \"aria-hidden\": true,\n    isDarkThemed: isDarkOverlay,\n    onClick: isBlocking ? undefined : onDismiss,\n    allowTouchBodyScroll: allowTouchBodyScroll\n  }, overlay)), dragOptions ? React.createElement(DraggableZone, {\n    handleSelector: dragOptions.dragHandleSelector || \"#\" + focusTrapZoneId,\n    preventDragSelector: \"button\",\n    onStart: handleDragStart,\n    onDragChange: handleDrag,\n    onStop: handleDragStop,\n    position: coordinates\n  }, modalContent) : modalContent))) || null;\n});\nModalBase.displayName = 'Modal';\n\nfunction useDebugWarnings(props) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: 'Modal',\n      props: props,\n      deprecations: {\n        onLayerDidMount: 'layerProps.onLayerDidMount'\n      }\n    });\n  }\n}","map":{"version":3,"sources":["components/Modal/Modal.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  classNamesFunction,\n  allowScrollOnElement,\n  allowOverscrollOnElement,\n  getPropsWithDefaults,\n  KeyCodes,\n  elementContains,\n  EventGroup,\n} from '../../Utilities';\nimport { FocusTrapZone, IFocusTrapZone } from '../../FocusTrapZone';\nimport { animationDuration } from './Modal.styles';\nimport { IDragOptions, IModalProps, IModalStyleProps, IModalStyles } from './Modal.types';\nimport { Overlay } from '../../Overlay';\nimport { ILayerProps, Layer } from '../../Layer';\nimport { Popup } from '../../Popup';\nimport { ResponsiveMode, useResponsiveMode } from '../../ResponsiveMode';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { Icon } from '../../Icon';\nimport { DraggableZone, ICoordinates, IDragData } from '../../utilities/DraggableZone/index';\nimport { useWindow } from '@fluentui/react-window-provider';\nimport {\n  useBoolean,\n  useMergedRefs,\n  useWarnings,\n  useConst,\n  useSetTimeout,\n  useId,\n  useUnmount,\n} from '@fluentui/react-hooks';\n\n// @TODO - need to change this to a panel whenever the breakpoint is under medium (verify the spec)\n\ninterface IModalInternalState {\n  onModalCloseTimer: number;\n  allowTouchBodyScroll?: boolean;\n  scrollableContent: HTMLDivElement | null;\n  lastSetCoordinates: ICoordinates;\n  /** Minimum clamped position, if dragging and clamping (`dragOptions.keepInBounds`) are enabled */\n  minPosition?: ICoordinates;\n  /** Maximum clamped position, if dragging and clamping (`dragOptions.keepInBounds`) are enabled */\n  maxPosition?: ICoordinates;\n  events: EventGroup;\n  /** Ensures we dispose the same keydown callback as was registered */\n  disposeOnKeyDown?: () => void;\n  /** Ensures we dispose the same keyup callback as was registered (also tracks whether keyup has been registered) */\n  disposeOnKeyUp?: () => void;\n  isInKeyboardMoveMode?: boolean;\n  hasBeenOpened?: boolean;\n}\n\nconst ZERO: ICoordinates = { x: 0, y: 0 };\n\nconst DEFAULT_PROPS: Partial<IModalProps> = {\n  isOpen: false,\n  isDarkOverlay: true,\n  className: '',\n  containerClassName: '',\n};\n\nconst getClassNames = classNamesFunction<IModalStyleProps, IModalStyles>();\n\nconst getMoveDelta = (ev: React.KeyboardEvent<HTMLElement>): number => {\n  let delta = 10;\n  if (ev.shiftKey) {\n    if (!ev.ctrlKey) {\n      delta = 50;\n    }\n  } else if (ev.ctrlKey) {\n    delta = 1;\n  }\n\n  return delta;\n};\n\nconst useComponentRef = (props: IModalProps, focusTrapZone: React.RefObject<IFocusTrapZone>) => {\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      focus() {\n        if (focusTrapZone.current) {\n          focusTrapZone.current.focus();\n        }\n      },\n    }),\n    [focusTrapZone],\n  );\n};\n\nexport const ModalBase: React.FunctionComponent<IModalProps> = React.forwardRef<HTMLDivElement, IModalProps>(\n  (propsWithoutDefaults, ref) => {\n    const props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n    const {\n      allowTouchBodyScroll,\n      className,\n      children,\n      containerClassName,\n      scrollableContentClassName,\n      elementToFocusOnDismiss,\n      firstFocusableSelector,\n      forceFocusInsideTrap,\n      ignoreExternalFocusing,\n      isBlocking,\n      isClickableOutsideFocusTrap,\n      isDarkOverlay,\n      onDismiss,\n      layerProps,\n      overlay,\n      isOpen,\n      titleAriaId,\n      styles,\n      subtitleAriaId,\n      theme,\n      topOffsetFixed,\n      responsiveMode,\n      // eslint-disable-next-line deprecation/deprecation\n      onLayerDidMount,\n      isModeless,\n      dragOptions,\n      onDismissed,\n      enableAriaHiddenSiblings,\n    } = props;\n\n    const rootRef = React.useRef<HTMLDivElement>(null);\n    const focusTrapZone = React.useRef<IFocusTrapZone>(null);\n    const focusTrapZoneElm = React.useRef<HTMLDivElement>(null);\n    const mergedRef = useMergedRefs(rootRef, ref);\n\n    const modalResponsiveMode = useResponsiveMode(mergedRef);\n\n    const focusTrapZoneId = useId('ModalFocusTrapZone');\n\n    const win = useWindow();\n\n    const { setTimeout, clearTimeout } = useSetTimeout();\n\n    const [isModalOpen, setIsModalOpen] = React.useState(isOpen);\n    const [isVisible, setIsVisible] = React.useState(isOpen);\n    const [coordinates, setCoordinates] = React.useState<ICoordinates>(ZERO);\n    const [modalRectangleTop, setModalRectangleTop] = React.useState<number | undefined>();\n\n    const [isModalMenuOpen, { toggle: toggleModalMenuOpen, setFalse: setModalMenuClose }] = useBoolean(false);\n\n    const internalState = useConst<IModalInternalState>(() => ({\n      onModalCloseTimer: 0,\n      allowTouchBodyScroll,\n      scrollableContent: null,\n      lastSetCoordinates: ZERO,\n      events: new EventGroup({}),\n    }));\n\n    const { keepInBounds } = dragOptions || ({} as IDragOptions);\n\n    const layerClassName = layerProps === undefined ? '' : layerProps.className;\n    const classNames = getClassNames(styles, {\n      theme: theme!,\n      className,\n      containerClassName,\n      scrollableContentClassName,\n      isOpen,\n      isVisible,\n      hasBeenOpened: internalState.hasBeenOpened,\n      modalRectangleTop,\n      topOffsetFixed,\n      isModeless,\n      layerClassName,\n      windowInnerHeight: win?.innerHeight,\n      isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector,\n    });\n\n    const mergedLayerProps: ILayerProps = {\n      eventBubblingEnabled: false,\n      ...layerProps,\n      onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount,\n      insertFirst: isModeless,\n      className: classNames.layer,\n    };\n\n    // Allow the user to scroll within the modal but not on the body\n    const allowScrollOnModal = React.useCallback(\n      (elt: HTMLDivElement | null): void => {\n        if (elt) {\n          if (internalState.allowTouchBodyScroll) {\n            allowOverscrollOnElement(elt, internalState.events);\n          } else {\n            allowScrollOnElement(elt, internalState.events);\n          }\n        } else {\n          internalState.events.off(internalState.scrollableContent);\n        }\n        internalState.scrollableContent = elt;\n      },\n      [internalState],\n    );\n\n    const registerInitialModalPosition = (): void => {\n      const dialogMain = focusTrapZoneElm.current;\n      const modalRectangle = dialogMain?.getBoundingClientRect();\n\n      if (modalRectangle) {\n        if (topOffsetFixed) {\n          setModalRectangleTop(modalRectangle.top);\n        }\n\n        if (keepInBounds) {\n          // x/y are unavailable in IE, so use the equivalent left/top\n          internalState.minPosition = { x: -modalRectangle.left, y: -modalRectangle.top };\n          internalState.maxPosition = { x: modalRectangle.left, y: modalRectangle.top };\n        }\n      }\n    };\n\n    /**\n     * Clamps an axis to a specified min and max position.\n     *\n     * @param axis A string that represents the axis (x/y).\n     * @param position The position on the axis.\n     */\n    const getClampedAxis = React.useCallback(\n      (axis: keyof ICoordinates, position: number) => {\n        const { minPosition, maxPosition } = internalState;\n        if (keepInBounds && minPosition && maxPosition) {\n          position = Math.max(minPosition[axis], position);\n          position = Math.min(maxPosition[axis], position);\n        }\n        return position;\n      },\n      [keepInBounds, internalState],\n    );\n\n    const handleModalClose = (): void => {\n      internalState.lastSetCoordinates = ZERO;\n\n      setModalMenuClose();\n      internalState.isInKeyboardMoveMode = false;\n      setIsModalOpen(false);\n      setCoordinates(ZERO);\n\n      internalState.disposeOnKeyUp?.();\n\n      onDismissed?.();\n    };\n\n    const handleDragStart = React.useCallback((): void => {\n      setModalMenuClose();\n      internalState.isInKeyboardMoveMode = false;\n    }, [internalState, setModalMenuClose]);\n\n    const handleDrag = React.useCallback(\n      (ev: React.MouseEvent<HTMLElement> & React.TouchEvent<HTMLElement>, dragData: IDragData): void => {\n        setCoordinates(prevValue => ({\n          x: getClampedAxis('x', prevValue.x + dragData.delta.x),\n          y: getClampedAxis('y', prevValue.y + dragData.delta.y),\n        }));\n      },\n      [getClampedAxis],\n    );\n\n    const handleDragStop = React.useCallback((): void => {\n      if (focusTrapZone.current) {\n        focusTrapZone.current.focus();\n      }\n    }, []);\n\n    const handleEnterKeyboardMoveMode = () => {\n      // We need a global handleKeyDown event when we are in the move mode so that we can\n      // handle the key presses and the components inside the modal do not get the events\n      const handleKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n        if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n          // CTRL + ALT + SPACE is handled during keyUp\n          ev.preventDefault();\n          ev.stopPropagation();\n          return;\n        }\n\n        if (isModalMenuOpen && (ev.altKey || ev.keyCode === KeyCodes.escape)) {\n          setModalMenuClose();\n        }\n\n        if (internalState.isInKeyboardMoveMode && (ev.keyCode === KeyCodes.escape || ev.keyCode === KeyCodes.enter)) {\n          internalState.isInKeyboardMoveMode = false;\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n\n        if (internalState.isInKeyboardMoveMode) {\n          let handledEvent = true;\n          const delta = getMoveDelta(ev);\n\n          switch (ev.keyCode) {\n            /* eslint-disable no-fallthrough */\n            case KeyCodes.escape:\n              setCoordinates(internalState.lastSetCoordinates);\n            case KeyCodes.enter: {\n              // TODO: determine if fallthrough was intentional\n              /* eslint-enable no-fallthrough */\n              internalState.lastSetCoordinates = ZERO;\n              // setIsInKeyboardMoveMode(false);\n              break;\n            }\n            case KeyCodes.up: {\n              setCoordinates(prevValue => ({ x: prevValue.x, y: getClampedAxis('y', prevValue.y - delta) }));\n              break;\n            }\n            case KeyCodes.down: {\n              setCoordinates(prevValue => ({ x: prevValue.x, y: getClampedAxis('y', prevValue.y + delta) }));\n              break;\n            }\n            case KeyCodes.left: {\n              setCoordinates(prevValue => ({ x: getClampedAxis('x', prevValue.x - delta), y: prevValue.y }));\n              break;\n            }\n            case KeyCodes.right: {\n              setCoordinates(prevValue => ({ x: getClampedAxis('x', prevValue.x + delta), y: prevValue.y }));\n              break;\n            }\n            default: {\n              handledEvent = false;\n            }\n          }\n          if (handledEvent) {\n            ev.preventDefault();\n            ev.stopPropagation();\n          }\n        }\n      };\n\n      internalState.lastSetCoordinates = coordinates;\n      setModalMenuClose();\n      internalState.isInKeyboardMoveMode = true;\n\n      internalState.events.on(win, 'keydown', handleKeyDown, true /* useCapture */);\n      internalState.disposeOnKeyDown = () => {\n        internalState.events.off(win, 'keydown', handleKeyDown, true /* useCapture */);\n        internalState.disposeOnKeyDown = undefined;\n      };\n    };\n\n    const handleExitKeyboardMoveMode = () => {\n      internalState.lastSetCoordinates = ZERO;\n      internalState.isInKeyboardMoveMode = false;\n      internalState.disposeOnKeyDown?.();\n    };\n\n    const registerForKeyUp = (): void => {\n      const handleKeyUp = (ev: React.KeyboardEvent<HTMLElement>): void => {\n        // Needs to handle the CTRL + ALT + SPACE key during keyup due to FireFox bug:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n        if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n          if (elementContains(internalState.scrollableContent, ev.target as HTMLElement)) {\n            toggleModalMenuOpen();\n            ev.preventDefault();\n            ev.stopPropagation();\n          }\n        }\n      };\n\n      if (!internalState.disposeOnKeyUp) {\n        internalState.events.on(win, 'keyup', handleKeyUp, true /* useCapture */);\n        internalState.disposeOnKeyUp = () => {\n          internalState.events.off(win, 'keyup', handleKeyUp, true /* useCapture */);\n          internalState.disposeOnKeyUp = undefined;\n        };\n      }\n    };\n\n    React.useEffect(() => {\n      clearTimeout(internalState.onModalCloseTimer);\n      // Opening the dialog\n      if (isOpen) {\n        // This must be done after the modal content has rendered\n        requestAnimationFrame(() => setTimeout(registerInitialModalPosition, 0));\n\n        setIsModalOpen(true);\n\n        // Add a keyUp handler for all key up events once the dialog is open.\n        if (dragOptions) {\n          registerForKeyUp();\n        }\n\n        internalState.hasBeenOpened = true;\n        setIsVisible(true);\n      }\n\n      // Closing the dialog\n      if (!isOpen && isModalOpen) {\n        internalState.onModalCloseTimer = setTimeout(handleModalClose, parseFloat(animationDuration) * 1000);\n        setIsVisible(false);\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if isModalOpen or isOpen mutates.\n    }, [isModalOpen, isOpen]);\n\n    useUnmount(() => {\n      internalState.events.dispose();\n    });\n\n    useComponentRef(props, focusTrapZone);\n    useDebugWarnings(props);\n\n    const modalContent = (\n      <FocusTrapZone\n        id={focusTrapZoneId}\n        ref={focusTrapZoneElm}\n        componentRef={focusTrapZone}\n        className={classNames.main}\n        elementToFocusOnDismiss={elementToFocusOnDismiss}\n        isClickableOutsideFocusTrap={isModeless || isClickableOutsideFocusTrap || !isBlocking}\n        ignoreExternalFocusing={ignoreExternalFocusing}\n        forceFocusInsideTrap={isModeless ? !isModeless : forceFocusInsideTrap}\n        firstFocusableSelector={firstFocusableSelector}\n        focusPreviouslyFocusedInnerElement\n        onBlur={internalState.isInKeyboardMoveMode ? handleExitKeyboardMoveMode : undefined}\n        enableAriaHiddenSiblings={enableAriaHiddenSiblings}\n      >\n        {dragOptions && internalState.isInKeyboardMoveMode && (\n          <div className={classNames.keyboardMoveIconContainer}>\n            {dragOptions.keyboardMoveIconProps ? (\n              <Icon {...dragOptions.keyboardMoveIconProps} />\n            ) : (\n              <Icon iconName=\"move\" className={classNames.keyboardMoveIcon} />\n            )}\n          </div>\n        )}\n        <div ref={allowScrollOnModal} className={classNames.scrollableContent} data-is-scrollable>\n          {dragOptions && isModalMenuOpen && (\n            <dragOptions.menu\n              items={[\n                { key: 'move', text: dragOptions.moveMenuItemText, onClick: handleEnterKeyboardMoveMode },\n                { key: 'close', text: dragOptions.closeMenuItemText, onClick: handleModalClose },\n              ]}\n              onDismiss={setModalMenuClose}\n              alignTargetEdge\n              coverTarget\n              directionalHint={DirectionalHint.topLeftEdge}\n              directionalHintFixed\n              shouldFocusOnMount\n              target={internalState.scrollableContent}\n            />\n          )}\n          {children}\n        </div>\n      </FocusTrapZone>\n    );\n\n    return (\n      (isModalOpen && modalResponsiveMode! >= (responsiveMode || ResponsiveMode.small) && (\n        <Layer ref={mergedRef} {...mergedLayerProps}>\n          <Popup\n            role={isModeless || !isBlocking ? 'dialog' : 'alertdialog'}\n            aria-modal={!isModeless}\n            ariaLabelledBy={titleAriaId}\n            ariaDescribedBy={subtitleAriaId}\n            onDismiss={onDismiss}\n            shouldRestoreFocus={!ignoreExternalFocusing}\n          >\n            <div className={classNames.root} role={!isModeless ? 'document' : undefined}>\n              {!isModeless && (\n                <Overlay\n                  aria-hidden={true}\n                  isDarkThemed={isDarkOverlay}\n                  onClick={isBlocking ? undefined : onDismiss}\n                  allowTouchBodyScroll={allowTouchBodyScroll}\n                  {...overlay}\n                />\n              )}\n              {dragOptions ? (\n                <DraggableZone\n                  handleSelector={dragOptions.dragHandleSelector || `#${focusTrapZoneId}`}\n                  preventDragSelector=\"button\"\n                  onStart={handleDragStart}\n                  onDragChange={handleDrag}\n                  onStop={handleDragStop}\n                  position={coordinates}\n                >\n                  {modalContent}\n                </DraggableZone>\n              ) : (\n                modalContent\n              )}\n            </div>\n          </Popup>\n        </Layer>\n      )) ||\n      null\n    );\n  },\n);\nModalBase.displayName = 'Modal';\n\nfunction useDebugWarnings(props: IModalProps) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: 'Modal',\n      props,\n      deprecations: { onLayerDidMount: 'layerProps.onLayerDidMount' },\n    });\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}