{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { KeytipManager } from '../../utilities/keytips/KeytipManager';\nimport { useConst } from '@fluentui/react-hooks';\n\nvar useKeytipRegistrations = function (persistedKeytips, keytipManager) {\n  React.useEffect(function () {\n    Object.keys(persistedKeytips).forEach(function (keytipId) {\n      var keytip = persistedKeytips[keytipId];\n      var uniqueID = keytipManager.register(keytip, true); // Update map\n\n      persistedKeytips[uniqueID] = keytip;\n      delete persistedKeytips[keytipId];\n    });\n    return function () {\n      // Delete all persisted keytips saved\n      Object.keys(persistedKeytips).forEach(function (uniqueID) {\n        keytipManager.unregister(persistedKeytips[uniqueID], uniqueID, true);\n        delete persistedKeytips[uniqueID];\n      });\n    };\n  }, [persistedKeytips, keytipManager]);\n};\n\nexport var OverflowButton = function (props) {\n  var keytipManager = KeytipManager.getInstance();\n  var className = props.className,\n      overflowItems = props.overflowItems,\n      keytipSequences = props.keytipSequences,\n      itemSubMenuProvider = props.itemSubMenuProvider,\n      onRenderOverflowButton = props.onRenderOverflowButton;\n  var persistedKeytips = useConst({}); // Gets the subMenu for an overflow item\n\n  var getSubMenuForItem = React.useCallback(function (item) {\n    // Checks if itemSubMenuProvider has been defined, if not defaults to subMenuProps\n    if (itemSubMenuProvider) {\n      return itemSubMenuProvider(item);\n    }\n\n    if (item.subMenuProps) {\n      return item.subMenuProps.items;\n    }\n\n    return undefined;\n  }, [itemSubMenuProvider]);\n  var newOverflowItems = React.useMemo(function () {\n    var currentOverflowItems = [];\n\n    if (keytipSequences) {\n      overflowItems === null || overflowItems === void 0 ? void 0 : overflowItems.forEach(function (overflowItem) {\n        var _a;\n\n        var keytip = overflowItem.keytipProps;\n\n        if (keytip) {\n          // Create persisted keytip\n          var persistedKeytip = {\n            content: keytip.content,\n            keySequences: keytip.keySequences,\n            disabled: keytip.disabled || !!(overflowItem.disabled || overflowItem.isDisabled),\n            hasDynamicChildren: keytip.hasDynamicChildren,\n            hasMenu: keytip.hasMenu\n          };\n\n          if (keytip.hasDynamicChildren || getSubMenuForItem(overflowItem)) {\n            // If the keytip has a submenu or children nodes, change onExecute to persistedKeytipExecute\n            persistedKeytip.onExecute = keytipManager.menuExecute.bind(keytipManager, keytipSequences, (_a = overflowItem === null || overflowItem === void 0 ? void 0 : overflowItem.keytipProps) === null || _a === void 0 ? void 0 : _a.keySequences);\n          } else {\n            // If the keytip doesn't have a submenu, just execute the original function\n            persistedKeytip.onExecute = keytip.onExecute;\n          } // Add this persisted keytip to our internal list, use a temporary uniqueID (its content)\n          // uniqueID will get updated on register\n\n\n          persistedKeytips[persistedKeytip.content] = persistedKeytip; // Add the overflow sequence to this item\n\n          var newOverflowItem = __assign(__assign({}, overflowItem), {\n            keytipProps: __assign(__assign({}, keytip), {\n              overflowSetSequence: keytipSequences\n            })\n          });\n\n          currentOverflowItems === null || currentOverflowItems === void 0 ? void 0 : currentOverflowItems.push(newOverflowItem);\n        } else {\n          // Nothing to change, add overflowItem to list\n          currentOverflowItems === null || currentOverflowItems === void 0 ? void 0 : currentOverflowItems.push(overflowItem);\n        }\n      });\n    } else {\n      currentOverflowItems = overflowItems;\n    }\n\n    return currentOverflowItems;\n  }, [overflowItems, getSubMenuForItem, keytipManager, keytipSequences, persistedKeytips]);\n  useKeytipRegistrations(persistedKeytips, keytipManager);\n  return React.createElement(\"div\", {\n    className: className\n  }, onRenderOverflowButton(newOverflowItems));\n};","map":{"version":3,"sources":["components/OverflowSet/OverflowButton.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AACA,SAAS,aAAT,QAA8B,uCAA9B;AAGA,SAAS,QAAT,QAAyB,uBAAzB;;AAEA,IAAM,sBAAsB,GAAG,UAC7B,gBAD6B,EAE7B,aAF6B,EAED;AAE5B,EAAA,KAAK,CAAC,SAAN,CAAgB,YAAA;AACd,IAAA,MAAM,CAAC,IAAP,CAAY,gBAAZ,EAA8B,OAA9B,CAAsC,UAAC,QAAD,EAAiB;AACrD,UAAM,MAAM,GAAG,gBAAgB,CAAC,QAAD,CAA/B;AACA,UAAM,QAAQ,GAAG,aAAa,CAAC,QAAd,CAAuB,MAAvB,EAAgC,IAAhC,CAAjB,CAFqD,CAGrD;;AACA,MAAA,gBAAgB,CAAC,QAAD,CAAhB,GAA6B,MAA7B;AACA,aAAO,gBAAgB,CAAC,QAAD,CAAvB;AACD,KAND;AAOA,WAAO,YAAA;AACL;AACA,MAAA,MAAM,CAAC,IAAP,CAAY,gBAAZ,EAA8B,OAA9B,CAAsC,UAAC,QAAD,EAAiB;AACrD,QAAA,aAAa,CAAC,UAAd,CAAyB,gBAAgB,CAAC,QAAD,CAAzC,EAAsD,QAAtD,EAAgE,IAAhE;AACA,eAAO,gBAAgB,CAAC,QAAD,CAAvB;AACD,OAHD;AAID,KAND;AAOD,GAfD,EAeG,CAAC,gBAAD,EAAmB,aAAnB,CAfH;AAgBD,CApBD;;AAsBA,OAAO,IAAM,cAAc,GAAG,UAAC,KAAD,EAAyB;AACrD,MAAM,aAAa,GAAkB,aAAa,CAAC,WAAd,EAArC;AACQ,MAAA,SAAS,GAAkF,KAAK,CAAvF,SAAT;AAAA,MAAW,aAAa,GAAmE,KAAK,CAAxE,aAAxB;AAAA,MAA0B,eAAe,GAAkD,KAAK,CAAvD,eAAzC;AAAA,MAA2C,mBAAmB,GAA6B,KAAK,CAAlC,mBAA9D;AAAA,MAAgE,sBAAsB,GAAK,KAAK,CAAV,sBAAtF;AACR,MAAM,gBAAgB,GAAG,QAAQ,CAAuC,EAAvC,CAAjC,CAHqD,CAKrD;;AACA,MAAM,iBAAiB,GAAG,KAAK,CAAC,WAAN,CACxB,UAAC,IAAD,EAA4B;AAC1B;AACA,QAAI,mBAAJ,EAAyB;AACvB,aAAO,mBAAmB,CAAC,IAAD,CAA1B;AACD;;AACD,QAAI,IAAI,CAAC,YAAT,EAAuB;AACrB,aAAO,IAAI,CAAC,YAAL,CAAkB,KAAzB;AACD;;AACD,WAAO,SAAP;AACD,GAVuB,EAWxB,CAAC,mBAAD,CAXwB,CAA1B;AAcA,MAAM,gBAAgB,GAAG,KAAK,CAAC,OAAN,CAAc,YAAA;AACrC,QAAI,oBAAoB,GAAwC,EAAhE;;AAEA,QAAI,eAAJ,EAAqB;AACnB,MAAA,aAAa,KAAA,IAAb,IAAA,aAAa,KAAA,KAAA,CAAb,GAAa,KAAA,CAAb,GAAA,aAAa,CAAE,OAAf,CAAuB,UAAA,YAAA,EAAY;;;AACjC,YAAM,MAAM,GAAI,YAAsC,CAAC,WAAvD;;AAEA,YAAI,MAAJ,EAAY;AACV;AACA,cAAM,eAAe,GAAiB;AACpC,YAAA,OAAO,EAAE,MAAM,CAAC,OADoB;AAEpC,YAAA,YAAY,EAAE,MAAM,CAAC,YAFe;AAGpC,YAAA,QAAQ,EAAE,MAAM,CAAC,QAAP,IAAmB,CAAC,EAAE,YAAY,CAAC,QAAb,IAAyB,YAAY,CAAC,UAAxC,CAHM;AAIpC,YAAA,kBAAkB,EAAE,MAAM,CAAC,kBAJS;AAKpC,YAAA,OAAO,EAAE,MAAM,CAAC;AALoB,WAAtC;;AAQA,cAAI,MAAM,CAAC,kBAAP,IAA6B,iBAAiB,CAAC,YAAD,CAAlD,EAAkE;AAChE;AACA,YAAA,eAAe,CAAC,SAAhB,GAA4B,aAAa,CAAC,WAAd,CAA0B,IAA1B,CAC1B,aAD0B,EAE1B,eAF0B,EAEX,CAAA,EAAA,GACf,YAAY,KAAA,IAAZ,IAAA,YAAY,KAAA,KAAA,CAAZ,GAAY,KAAA,CAAZ,GAAA,YAAY,CAAE,WADC,MACU,IADV,IACU,EAAA,KAAA,KAAA,CADV,GACU,KAAA,CADV,GACU,EAAA,CAAE,YAHD,CAA5B;AAKD,WAPD,MAOO;AACL;AACA,YAAA,eAAe,CAAC,SAAhB,GAA4B,MAAM,CAAC,SAAnC;AACD,WApBS,CAsBV;AACA;;;AACA,UAAA,gBAAgB,CAAC,eAAe,CAAC,OAAjB,CAAhB,GAA4C,eAA5C,CAxBU,CA0BV;;AACA,cAAM,eAAe,GAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAChB,YADgB,CAAA,EACJ;AACf,YAAA,WAAW,EAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACN,MADM,CAAA,EACA;AACT,cAAA,mBAAmB,EAAE;AADZ,aADA;AADI,WADI,CAArB;;AAOA,UAAA,oBAAoB,KAAA,IAApB,IAAA,oBAAoB,KAAA,KAAA,CAApB,GAAoB,KAAA,CAApB,GAAA,oBAAoB,CAAE,IAAtB,CAA2B,eAA3B,CAAA;AACD,SAnCD,MAmCO;AACL;AACA,UAAA,oBAAoB,KAAA,IAApB,IAAA,oBAAoB,KAAA,KAAA,CAApB,GAAoB,KAAA,CAApB,GAAA,oBAAoB,CAAE,IAAtB,CAA2B,YAA3B,CAAA;AACD;AACF,OA1CD,CAAA;AA2CD,KA5CD,MA4CO;AACL,MAAA,oBAAoB,GAAG,aAAvB;AACD;;AACD,WAAO,oBAAP;AACD,GAnDwB,EAmDtB,CAAC,aAAD,EAAgB,iBAAhB,EAAmC,aAAnC,EAAkD,eAAlD,EAAmE,gBAAnE,CAnDsB,CAAzB;AAqDA,EAAA,sBAAsB,CAAC,gBAAD,EAAmB,aAAnB,CAAtB;AAEA,SAAO,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AAAK,IAAA,SAAS,EAAE;AAAhB,GAAA,EAA4B,sBAAsB,CAAC,gBAAD,CAAlD,CAAP;AACD,CA5EM","sourcesContent":["import * as React from 'react';\nimport { KeytipManager } from '../../utilities/keytips/KeytipManager';\nimport { IKeytipProps } from '../../Keytip';\nimport { IOverflowSetItemProps, IOverflowSetProps } from './OverflowSet.types';\nimport { useConst } from '@fluentui/react-hooks';\n\nconst useKeytipRegistrations = (\n  persistedKeytips: { [uniqueID: string]: IKeytipProps },\n  keytipManager: KeytipManager,\n) => {\n  React.useEffect(() => {\n    Object.keys(persistedKeytips).forEach((keytipId: string) => {\n      const keytip = persistedKeytips[keytipId];\n      const uniqueID = keytipManager.register(keytip!, true);\n      // Update map\n      persistedKeytips[uniqueID] = keytip;\n      delete persistedKeytips[keytipId];\n    });\n    return () => {\n      // Delete all persisted keytips saved\n      Object.keys(persistedKeytips).forEach((uniqueID: string) => {\n        keytipManager.unregister(persistedKeytips[uniqueID]!, uniqueID, true);\n        delete persistedKeytips[uniqueID];\n      });\n    };\n  }, [persistedKeytips, keytipManager]);\n};\n\nexport const OverflowButton = (props: IOverflowSetProps) => {\n  const keytipManager: KeytipManager = KeytipManager.getInstance();\n  const { className, overflowItems, keytipSequences, itemSubMenuProvider, onRenderOverflowButton } = props;\n  const persistedKeytips = useConst<{ [uniqueID: string]: IKeytipProps }>({});\n\n  // Gets the subMenu for an overflow item\n  const getSubMenuForItem = React.useCallback(\n    (item: IOverflowSetItemProps) => {\n      // Checks if itemSubMenuProvider has been defined, if not defaults to subMenuProps\n      if (itemSubMenuProvider) {\n        return itemSubMenuProvider(item);\n      }\n      if (item.subMenuProps) {\n        return item.subMenuProps.items;\n      }\n      return undefined;\n    },\n    [itemSubMenuProvider],\n  );\n\n  const newOverflowItems = React.useMemo(() => {\n    let currentOverflowItems: IOverflowSetItemProps[] | undefined = [];\n\n    if (keytipSequences) {\n      overflowItems?.forEach(overflowItem => {\n        const keytip = (overflowItem as IOverflowSetItemProps).keytipProps;\n\n        if (keytip) {\n          // Create persisted keytip\n          const persistedKeytip: IKeytipProps = {\n            content: keytip.content,\n            keySequences: keytip.keySequences,\n            disabled: keytip.disabled || !!(overflowItem.disabled || overflowItem.isDisabled),\n            hasDynamicChildren: keytip.hasDynamicChildren,\n            hasMenu: keytip.hasMenu,\n          };\n\n          if (keytip.hasDynamicChildren || getSubMenuForItem(overflowItem)) {\n            // If the keytip has a submenu or children nodes, change onExecute to persistedKeytipExecute\n            persistedKeytip.onExecute = keytipManager.menuExecute.bind(\n              keytipManager,\n              keytipSequences,\n              overflowItem?.keytipProps?.keySequences,\n            );\n          } else {\n            // If the keytip doesn't have a submenu, just execute the original function\n            persistedKeytip.onExecute = keytip.onExecute;\n          }\n\n          // Add this persisted keytip to our internal list, use a temporary uniqueID (its content)\n          // uniqueID will get updated on register\n          persistedKeytips[persistedKeytip.content] = persistedKeytip;\n\n          // Add the overflow sequence to this item\n          const newOverflowItem = {\n            ...overflowItem,\n            keytipProps: {\n              ...keytip,\n              overflowSetSequence: keytipSequences,\n            },\n          };\n          currentOverflowItems?.push(newOverflowItem);\n        } else {\n          // Nothing to change, add overflowItem to list\n          currentOverflowItems?.push(overflowItem);\n        }\n      });\n    } else {\n      currentOverflowItems = overflowItems!;\n    }\n    return currentOverflowItems;\n  }, [overflowItems, getSubMenuForItem, keytipManager, keytipSequences, persistedKeytips]);\n\n  useKeytipRegistrations(persistedKeytips, keytipManager);\n\n  return <div className={className}>{onRenderOverflowButton(newOverflowItems)}</div>;\n};\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}