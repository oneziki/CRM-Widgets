{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { elementContains, getNativeProps, divProperties, getFirstTabbable, getLastTabbable, getNextElement, focusAsync, modalize, on } from '../../Utilities';\nimport { useId, useConst, useMergedRefs } from '@fluentui/react-hooks';\nimport { useDocument } from '../../WindowProvider';\nvar COMPONENT_NAME = 'FocusTrapZone';\n\nvar useComponentRef = function (componentRef, previouslyFocusedElement, focus) {\n  React.useImperativeHandle(componentRef, function () {\n    return {\n      get previouslyFocusedElement() {\n        return previouslyFocusedElement;\n      },\n\n      focus: focus\n    };\n  }, [previouslyFocusedElement, focus]);\n};\n\nexport var FocusTrapZone = React.forwardRef(function (props, ref) {\n  var root = React.useRef(null);\n  var firstBumper = React.useRef(null);\n  var lastBumper = React.useRef(null);\n  var mergedRootRef = useMergedRefs(root, ref);\n  var id = useId(undefined, props.id);\n  var doc = useDocument();\n  var divProps = getNativeProps(props, divProperties);\n  var internalState = useConst(function () {\n    return {\n      previouslyFocusedElementOutsideTrapZone: undefined,\n      previouslyFocusedElementInTrapZone: undefined,\n      disposeFocusHandler: undefined,\n      disposeClickHandler: undefined,\n      hasFocus: false,\n      unmodalize: undefined\n    };\n  });\n  var ariaLabelledBy = props.ariaLabelledBy,\n      className = props.className,\n      children = props.children,\n      componentRef = props.componentRef,\n      disabled = props.disabled,\n      _a = props.disableFirstFocus,\n      disableFirstFocus = _a === void 0 ? false : _a,\n      _b = props.disabled,\n      currentDisabledValue = _b === void 0 ? false : _b,\n      elementToFocusOnDismiss = props.elementToFocusOnDismiss,\n      _c = props.forceFocusInsideTrap,\n      forceFocusInsideTrap = _c === void 0 ? true : _c,\n      focusPreviouslyFocusedInnerElement = props.focusPreviouslyFocusedInnerElement,\n      firstFocusableSelector = props.firstFocusableSelector,\n      ignoreExternalFocusing = props.ignoreExternalFocusing,\n      _d = props.isClickableOutsideFocusTrap,\n      isClickableOutsideFocusTrap = _d === void 0 ? false : _d,\n      onFocus = props.onFocus,\n      onBlur = props.onBlur,\n      onFocusCapture = props.onFocusCapture,\n      onBlurCapture = props.onBlurCapture,\n      enableAriaHiddenSiblings = props.enableAriaHiddenSiblings;\n  var bumperProps = {\n    'aria-hidden': true,\n    style: {\n      pointerEvents: 'none',\n      position: 'fixed'\n    },\n    tabIndex: disabled ? -1 : 0,\n    'data-is-visible': true\n  };\n  var focus = React.useCallback(function () {\n    if (focusPreviouslyFocusedInnerElement && internalState.previouslyFocusedElementInTrapZone && elementContains(root.current, internalState.previouslyFocusedElementInTrapZone)) {\n      // focus on the last item that had focus in the zone before we left the zone\n      focusAsync(internalState.previouslyFocusedElementInTrapZone);\n      return;\n    }\n\n    var focusSelector = typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector && firstFocusableSelector();\n    var firstFocusableChild = null;\n\n    if (root.current) {\n      if (focusSelector) {\n        firstFocusableChild = root.current.querySelector('.' + focusSelector);\n      } // Fall back to first element if query selector did not match any elements.\n\n\n      if (!firstFocusableChild) {\n        firstFocusableChild = getNextElement(root.current, root.current.firstChild, false, false, false, true);\n      }\n    }\n\n    if (firstFocusableChild) {\n      focusAsync(firstFocusableChild);\n    }\n  }, [firstFocusableSelector, focusPreviouslyFocusedInnerElement, internalState]);\n  var onBumperFocus = React.useCallback(function (isFirstBumper) {\n    if (disabled) {\n      return;\n    }\n\n    var currentBumper = isFirstBumper === internalState.hasFocus ? lastBumper.current : firstBumper.current;\n\n    if (root.current) {\n      var nextFocusable = isFirstBumper === internalState.hasFocus ? getLastTabbable(root.current, currentBumper, true, false) : getFirstTabbable(root.current, currentBumper, true, false);\n\n      if (nextFocusable) {\n        if (nextFocusable === firstBumper.current || nextFocusable === lastBumper.current) {\n          // This can happen when FTZ contains no tabbable elements.\n          // focus will take care of finding a focusable element in FTZ.\n          focus();\n        } else {\n          nextFocusable.focus();\n        }\n      }\n    }\n  }, [disabled, focus, internalState]);\n  var onRootBlurCapture = React.useCallback(function (ev) {\n    onBlurCapture === null || onBlurCapture === void 0 ? void 0 : onBlurCapture(ev);\n    var relatedTarget = ev.relatedTarget;\n\n    if (ev.relatedTarget === null) {\n      // In IE11, due to lack of support, event.relatedTarget is always\n      // null making every onBlur call to be \"outside\" of the ComboBox\n      // even when it's not. Using document.activeElement is another way\n      // for us to be able to get what the relatedTarget without relying\n      // on the event\n      relatedTarget = doc.activeElement;\n    }\n\n    if (!elementContains(root.current, relatedTarget)) {\n      internalState.hasFocus = false;\n    }\n  }, [doc, internalState, onBlurCapture]);\n  var onRootFocusCapture = React.useCallback(function (ev) {\n    onFocusCapture === null || onFocusCapture === void 0 ? void 0 : onFocusCapture(ev);\n\n    if (ev.target === firstBumper.current) {\n      onBumperFocus(true);\n    } else if (ev.target === lastBumper.current) {\n      onBumperFocus(false);\n    }\n\n    internalState.hasFocus = true;\n\n    if (ev.target !== ev.currentTarget && !(ev.target === firstBumper.current || ev.target === lastBumper.current)) {\n      // every time focus changes within the trap zone, remember the focused element so that\n      // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n      internalState.previouslyFocusedElementInTrapZone = ev.target;\n    }\n  }, [onFocusCapture, internalState, onBumperFocus]);\n  var returnFocusToInitiator = React.useCallback(function () {\n    FocusTrapZone.focusStack = FocusTrapZone.focusStack.filter(function (value) {\n      return id !== value;\n    });\n\n    if (doc) {\n      var activeElement = doc.activeElement;\n\n      if (!ignoreExternalFocusing && internalState.previouslyFocusedElementOutsideTrapZone && typeof internalState.previouslyFocusedElementOutsideTrapZone.focus === 'function' && (elementContains(root.current, activeElement) || activeElement === doc.body)) {\n        if (!(internalState.previouslyFocusedElementOutsideTrapZone === firstBumper.current || internalState.previouslyFocusedElementOutsideTrapZone === lastBumper.current)) {\n          focusAsync(internalState.previouslyFocusedElementOutsideTrapZone);\n        }\n      }\n    }\n  }, [doc, id, ignoreExternalFocusing, internalState]);\n  var forceFocusInTrap = React.useCallback(function (ev) {\n    if (disabled) {\n      return;\n    }\n\n    if (FocusTrapZone.focusStack.length && id === FocusTrapZone.focusStack[FocusTrapZone.focusStack.length - 1]) {\n      var focusedElement = ev.target;\n\n      if (!elementContains(root.current, focusedElement)) {\n        focus();\n        internalState.hasFocus = true; // set focus here since we stop event propagation\n\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  }, [disabled, id, focus, internalState]);\n  var forceClickInTrap = React.useCallback(function (ev) {\n    if (disabled) {\n      return;\n    }\n\n    if (FocusTrapZone.focusStack.length && id === FocusTrapZone.focusStack[FocusTrapZone.focusStack.length - 1]) {\n      var clickedElement = ev.target;\n\n      if (clickedElement && !elementContains(root.current, clickedElement)) {\n        focus();\n        internalState.hasFocus = true; // set focus here since we stop event propagation\n\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  }, [disabled, id, focus, internalState]);\n  var updateEventHandlers = React.useCallback(function () {\n    if (forceFocusInsideTrap && !internalState.disposeFocusHandler) {\n      internalState.disposeFocusHandler = on(window, 'focus', forceFocusInTrap, true);\n    } else if (!forceFocusInsideTrap && internalState.disposeFocusHandler) {\n      internalState.disposeFocusHandler();\n      internalState.disposeFocusHandler = undefined;\n    }\n\n    if (!isClickableOutsideFocusTrap && !internalState.disposeClickHandler) {\n      internalState.disposeClickHandler = on(window, 'click', forceClickInTrap, true);\n    } else if (isClickableOutsideFocusTrap && internalState.disposeClickHandler) {\n      internalState.disposeClickHandler();\n      internalState.disposeClickHandler = undefined;\n    }\n  }, [forceClickInTrap, forceFocusInTrap, forceFocusInsideTrap, isClickableOutsideFocusTrap, internalState]); // Updates eventHandlers and cleans up focusStack when the component unmounts.\n\n  React.useEffect(function () {\n    var parentRoot = root.current;\n    updateEventHandlers();\n    return function () {\n      // don't handle return focus unless forceFocusInsideTrap is true or focus is still within FocusTrapZone\n      if (!disabled || forceFocusInsideTrap || !elementContains(parentRoot, doc === null || doc === void 0 ? void 0 : doc.activeElement)) {\n        returnFocusToInitiator();\n      }\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps -- Should only run on mount.\n  }, [updateEventHandlers]); // Updates focusStack and the previouslyFocusedElementOutsideTrapZone on prop change.\n\n  React.useEffect(function () {\n    var newForceFocusInsideTrap = forceFocusInsideTrap !== undefined ? forceFocusInsideTrap : true;\n    var newDisabled = disabled !== undefined ? disabled : false; // Transition from forceFocusInsideTrap / FTZ disabled to enabled.\n\n    if (!newDisabled || newForceFocusInsideTrap) {\n      if (currentDisabledValue) {\n        return;\n      }\n\n      FocusTrapZone.focusStack.push(id);\n      internalState.previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss ? elementToFocusOnDismiss : doc.activeElement;\n\n      if (!disableFirstFocus && !elementContains(root.current, internalState.previouslyFocusedElementOutsideTrapZone)) {\n        focus();\n      }\n\n      if (!internalState.unmodalize && root.current && enableAriaHiddenSiblings) {\n        internalState.unmodalize = modalize(root.current);\n      }\n    } else if (!newForceFocusInsideTrap || newDisabled) {\n      // Transition from forceFocusInsideTrap / FTZ enabled to disabled.\n      returnFocusToInitiator();\n\n      if (internalState.unmodalize) {\n        internalState.unmodalize();\n      }\n    }\n\n    if (elementToFocusOnDismiss && internalState.previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {\n      internalState.previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [elementToFocusOnDismiss, forceFocusInsideTrap, disabled]); // Cleanup lifecyle method for internalState.\n\n  useUnmount(function () {\n    // Dispose of event handlers so their closures can be garbage-collected\n    if (internalState.disposeClickHandler) {\n      internalState.disposeClickHandler();\n      internalState.disposeClickHandler = undefined;\n    }\n\n    if (internalState.disposeFocusHandler) {\n      internalState.disposeFocusHandler();\n      internalState.disposeFocusHandler = undefined;\n    }\n\n    if (internalState.unmodalize) {\n      internalState.unmodalize();\n    } // Dispose of element references so the DOM Nodes can be garbage-collected\n\n\n    delete internalState.previouslyFocusedElementInTrapZone;\n    delete internalState.previouslyFocusedElementOutsideTrapZone;\n  });\n  useComponentRef(componentRef, internalState.previouslyFocusedElementInTrapZone, focus);\n  return React.createElement(\"div\", __assign({}, divProps, {\n    className: className,\n    ref: mergedRootRef,\n    \"aria-labelledby\": ariaLabelledBy,\n    onFocusCapture: onRootFocusCapture,\n    onFocus: onFocus,\n    onBlur: onBlur,\n    onBlurCapture: onRootBlurCapture\n  }), React.createElement(\"div\", __assign({}, bumperProps, {\n    ref: firstBumper\n  })), children, React.createElement(\"div\", __assign({}, bumperProps, {\n    ref: lastBumper\n  })));\n});\n\nvar useUnmount = function (unmountFunction) {\n  var unmountRef = React.useRef(unmountFunction);\n  unmountRef.current = unmountFunction;\n  React.useEffect(function () {\n    return function () {\n      if (unmountRef.current) {\n        unmountRef.current();\n      }\n    };\n  }, [unmountFunction]);\n};\n\nFocusTrapZone.displayName = COMPONENT_NAME;\nFocusTrapZone.focusStack = [];","map":{"version":3,"sources":["components/FocusTrapZone/FocusTrapZone.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  elementContains,\n  getNativeProps,\n  divProperties,\n  getFirstTabbable,\n  getLastTabbable,\n  getNextElement,\n  focusAsync,\n  IRefObject,\n  modalize,\n  on,\n} from '../../Utilities';\nimport { IFocusTrapZoneProps, IFocusTrapZone } from './FocusTrapZone.types';\nimport { useId, useConst, useMergedRefs } from '@fluentui/react-hooks';\nimport { useDocument } from '../../WindowProvider';\n\ninterface IFocusTrapZoneInternalState {\n  disposeFocusHandler: (() => void) | undefined;\n  disposeClickHandler: (() => void) | undefined;\n  previouslyFocusedElementOutsideTrapZone: HTMLElement | undefined;\n  previouslyFocusedElementInTrapZone: HTMLElement | undefined;\n  hasFocus: boolean;\n  unmodalize: (() => void) | undefined;\n}\n\nconst COMPONENT_NAME = 'FocusTrapZone';\n\nconst useComponentRef = (\n  componentRef: IRefObject<IFocusTrapZone> | undefined,\n  previouslyFocusedElement: HTMLElement | undefined,\n  focus: () => void,\n) => {\n  React.useImperativeHandle(\n    componentRef,\n    () => ({\n      get previouslyFocusedElement() {\n        return previouslyFocusedElement;\n      },\n      focus,\n    }),\n    [previouslyFocusedElement, focus],\n  );\n};\n\nexport const FocusTrapZone: React.FunctionComponent<IFocusTrapZoneProps> & {\n  focusStack: string[];\n} = React.forwardRef<HTMLElement, IFocusTrapZoneProps>((props, ref) => {\n  const root = React.useRef<HTMLDivElement>(null);\n  const firstBumper = React.useRef<HTMLDivElement>(null);\n  const lastBumper = React.useRef<HTMLDivElement>(null);\n  const mergedRootRef = useMergedRefs(root, ref) as React.Ref<HTMLDivElement>;\n  const id = useId(undefined, props.id);\n  const doc = useDocument();\n  const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(props, divProperties);\n\n  const internalState = useConst<IFocusTrapZoneInternalState>(() => ({\n    previouslyFocusedElementOutsideTrapZone: undefined,\n    previouslyFocusedElementInTrapZone: undefined,\n    disposeFocusHandler: undefined,\n    disposeClickHandler: undefined,\n    hasFocus: false,\n    unmodalize: undefined,\n  }));\n\n  const {\n    ariaLabelledBy,\n    className,\n    children,\n    componentRef,\n    disabled,\n    disableFirstFocus = false,\n    disabled: currentDisabledValue = false,\n    elementToFocusOnDismiss,\n    forceFocusInsideTrap = true,\n    focusPreviouslyFocusedInnerElement,\n    firstFocusableSelector,\n    ignoreExternalFocusing,\n    isClickableOutsideFocusTrap = false,\n    onFocus,\n    onBlur,\n    onFocusCapture,\n    onBlurCapture,\n    enableAriaHiddenSiblings,\n  } = props;\n\n  const bumperProps = {\n    'aria-hidden': true,\n    style: {\n      pointerEvents: 'none',\n      position: 'fixed', // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them\n    },\n    tabIndex: disabled ? -1 : 0, // make bumpers tabbable only when enabled\n    'data-is-visible': true,\n  } as React.HTMLAttributes<HTMLDivElement>;\n\n  const focus = React.useCallback(() => {\n    if (\n      focusPreviouslyFocusedInnerElement &&\n      internalState.previouslyFocusedElementInTrapZone &&\n      elementContains(root.current, internalState.previouslyFocusedElementInTrapZone)\n    ) {\n      // focus on the last item that had focus in the zone before we left the zone\n      focusAsync(internalState.previouslyFocusedElementInTrapZone);\n      return;\n    }\n\n    const focusSelector =\n      typeof firstFocusableSelector === 'string'\n        ? firstFocusableSelector\n        : firstFocusableSelector && firstFocusableSelector();\n\n    let firstFocusableChild: HTMLElement | null = null;\n\n    if (root.current) {\n      if (focusSelector) {\n        firstFocusableChild = root.current.querySelector('.' + focusSelector);\n      }\n\n      // Fall back to first element if query selector did not match any elements.\n      if (!firstFocusableChild) {\n        firstFocusableChild = getNextElement(\n          root.current,\n          root.current.firstChild as HTMLElement,\n          false,\n          false,\n          false,\n          true,\n        );\n      }\n    }\n    if (firstFocusableChild) {\n      focusAsync(firstFocusableChild);\n    }\n  }, [firstFocusableSelector, focusPreviouslyFocusedInnerElement, internalState]);\n\n  const onBumperFocus = React.useCallback(\n    (isFirstBumper: boolean) => {\n      if (disabled) {\n        return;\n      }\n\n      const currentBumper = (isFirstBumper === internalState.hasFocus\n        ? lastBumper.current\n        : firstBumper.current) as HTMLElement;\n\n      if (root.current) {\n        const nextFocusable =\n          isFirstBumper === internalState.hasFocus\n            ? getLastTabbable(root.current, currentBumper, true, false)\n            : getFirstTabbable(root.current, currentBumper, true, false);\n\n        if (nextFocusable) {\n          if (nextFocusable === firstBumper.current || nextFocusable === lastBumper.current) {\n            // This can happen when FTZ contains no tabbable elements.\n            // focus will take care of finding a focusable element in FTZ.\n            focus();\n          } else {\n            nextFocusable.focus();\n          }\n        }\n      }\n    },\n    [disabled, focus, internalState],\n  );\n\n  const onRootBlurCapture = React.useCallback(\n    (ev: React.FocusEvent<HTMLDivElement>) => {\n      onBlurCapture?.(ev);\n      let relatedTarget = ev.relatedTarget;\n      if (ev.relatedTarget === null) {\n        // In IE11, due to lack of support, event.relatedTarget is always\n        // null making every onBlur call to be \"outside\" of the ComboBox\n        // even when it's not. Using document.activeElement is another way\n        // for us to be able to get what the relatedTarget without relying\n        // on the event\n        relatedTarget = doc!.activeElement as Element;\n      }\n      if (!elementContains(root.current, relatedTarget as HTMLElement)) {\n        internalState.hasFocus = false;\n      }\n    },\n    [doc, internalState, onBlurCapture],\n  );\n\n  const onRootFocusCapture = React.useCallback(\n    (ev: React.FocusEvent<HTMLDivElement>) => {\n      onFocusCapture?.(ev);\n\n      if (ev.target === firstBumper.current) {\n        onBumperFocus(true);\n      } else if (ev.target === lastBumper.current) {\n        onBumperFocus(false);\n      }\n\n      internalState.hasFocus = true;\n\n      if (ev.target !== ev.currentTarget && !(ev.target === firstBumper.current || ev.target === lastBumper.current)) {\n        // every time focus changes within the trap zone, remember the focused element so that\n        // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n        internalState.previouslyFocusedElementInTrapZone = ev.target as HTMLElement;\n      }\n    },\n    [onFocusCapture, internalState, onBumperFocus],\n  );\n\n  const returnFocusToInitiator = React.useCallback((): void => {\n    FocusTrapZone.focusStack = FocusTrapZone.focusStack.filter((value: any) => {\n      return id !== value;\n    });\n\n    if (doc) {\n      const activeElement = doc.activeElement as HTMLElement;\n      if (\n        !ignoreExternalFocusing &&\n        internalState.previouslyFocusedElementOutsideTrapZone &&\n        typeof internalState.previouslyFocusedElementOutsideTrapZone.focus === 'function' &&\n        (elementContains(root.current, activeElement) || activeElement === doc.body)\n      ) {\n        if (\n          !(\n            internalState.previouslyFocusedElementOutsideTrapZone === firstBumper.current ||\n            internalState.previouslyFocusedElementOutsideTrapZone === lastBumper.current\n          )\n        ) {\n          focusAsync(internalState.previouslyFocusedElementOutsideTrapZone);\n        }\n      }\n    }\n  }, [doc, id, ignoreExternalFocusing, internalState]);\n\n  const forceFocusInTrap = React.useCallback(\n    (ev: FocusEvent): void => {\n      if (disabled) {\n        return;\n      }\n      if (FocusTrapZone.focusStack.length && id === FocusTrapZone.focusStack[FocusTrapZone.focusStack.length - 1]) {\n        const focusedElement = ev.target as HTMLElement;\n        if (!elementContains(root.current, focusedElement)) {\n          focus();\n          internalState.hasFocus = true; // set focus here since we stop event propagation\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    },\n    [disabled, id, focus, internalState],\n  );\n\n  const forceClickInTrap = React.useCallback(\n    (ev: MouseEvent): void => {\n      if (disabled) {\n        return;\n      }\n      if (FocusTrapZone.focusStack.length && id === FocusTrapZone.focusStack[FocusTrapZone.focusStack.length - 1]) {\n        const clickedElement = ev.target as HTMLElement;\n        if (clickedElement && !elementContains(root.current, clickedElement)) {\n          focus();\n          internalState.hasFocus = true; // set focus here since we stop event propagation\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    },\n    [disabled, id, focus, internalState],\n  );\n\n  const updateEventHandlers = React.useCallback((): void => {\n    if (forceFocusInsideTrap && !internalState.disposeFocusHandler) {\n      internalState.disposeFocusHandler = on(window, 'focus', forceFocusInTrap, true);\n    } else if (!forceFocusInsideTrap && internalState.disposeFocusHandler) {\n      internalState.disposeFocusHandler();\n      internalState.disposeFocusHandler = undefined;\n    }\n\n    if (!isClickableOutsideFocusTrap && !internalState.disposeClickHandler) {\n      internalState.disposeClickHandler = on(window, 'click', forceClickInTrap, true);\n    } else if (isClickableOutsideFocusTrap && internalState.disposeClickHandler) {\n      internalState.disposeClickHandler();\n      internalState.disposeClickHandler = undefined;\n    }\n  }, [forceClickInTrap, forceFocusInTrap, forceFocusInsideTrap, isClickableOutsideFocusTrap, internalState]);\n\n  // Updates eventHandlers and cleans up focusStack when the component unmounts.\n  React.useEffect(() => {\n    const parentRoot = root.current;\n    updateEventHandlers();\n    return () => {\n      // don't handle return focus unless forceFocusInsideTrap is true or focus is still within FocusTrapZone\n      if (!disabled || forceFocusInsideTrap || !elementContains(parentRoot, doc?.activeElement as HTMLElement)) {\n        returnFocusToInitiator();\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- Should only run on mount.\n  }, [updateEventHandlers]);\n\n  // Updates focusStack and the previouslyFocusedElementOutsideTrapZone on prop change.\n  React.useEffect(() => {\n    const newForceFocusInsideTrap = forceFocusInsideTrap !== undefined ? forceFocusInsideTrap : true;\n    const newDisabled = disabled !== undefined ? disabled : false;\n\n    // Transition from forceFocusInsideTrap / FTZ disabled to enabled.\n    if (!newDisabled || newForceFocusInsideTrap) {\n      if (currentDisabledValue) {\n        return;\n      }\n\n      FocusTrapZone.focusStack.push(id);\n\n      internalState.previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss\n        ? elementToFocusOnDismiss\n        : (doc!.activeElement as HTMLElement);\n      if (!disableFirstFocus && !elementContains(root.current, internalState.previouslyFocusedElementOutsideTrapZone)) {\n        focus();\n      }\n      if (!internalState.unmodalize && root.current && enableAriaHiddenSiblings) {\n        internalState.unmodalize = modalize(root.current);\n      }\n    } else if (!newForceFocusInsideTrap || newDisabled) {\n      // Transition from forceFocusInsideTrap / FTZ enabled to disabled.\n      returnFocusToInitiator();\n      if (internalState.unmodalize) {\n        internalState.unmodalize();\n      }\n    }\n\n    if (elementToFocusOnDismiss && internalState.previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {\n      internalState.previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [elementToFocusOnDismiss, forceFocusInsideTrap, disabled]);\n\n  // Cleanup lifecyle method for internalState.\n  useUnmount(() => {\n    // Dispose of event handlers so their closures can be garbage-collected\n    if (internalState.disposeClickHandler) {\n      internalState.disposeClickHandler();\n      internalState.disposeClickHandler = undefined;\n    }\n    if (internalState.disposeFocusHandler) {\n      internalState.disposeFocusHandler();\n      internalState.disposeFocusHandler = undefined;\n    }\n    if (internalState.unmodalize) {\n      internalState.unmodalize();\n    }\n    // Dispose of element references so the DOM Nodes can be garbage-collected\n    delete internalState.previouslyFocusedElementInTrapZone;\n    delete internalState.previouslyFocusedElementOutsideTrapZone;\n  });\n\n  useComponentRef(componentRef, internalState.previouslyFocusedElementInTrapZone, focus);\n\n  return (\n    <div\n      {...divProps}\n      className={className}\n      ref={mergedRootRef}\n      aria-labelledby={ariaLabelledBy}\n      onFocusCapture={onRootFocusCapture}\n      onFocus={onFocus}\n      onBlur={onBlur}\n      onBlurCapture={onRootBlurCapture}\n    >\n      <div {...bumperProps} ref={firstBumper} />\n      {children}\n      <div {...bumperProps} ref={lastBumper} />\n    </div>\n  );\n}) as any;\n\nconst useUnmount = (unmountFunction: () => void) => {\n  const unmountRef = React.useRef(unmountFunction);\n  unmountRef.current = unmountFunction;\n  React.useEffect(\n    () => () => {\n      if (unmountRef.current) {\n        unmountRef.current();\n      }\n    },\n    [unmountFunction],\n  );\n};\n\nFocusTrapZone.displayName = COMPONENT_NAME;\nFocusTrapZone.focusStack = [];\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}