{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { KeyCodes, divProperties, doesElementContainFocus, getDocument, getNativeProps, getWindow } from '../../Utilities';\nimport { useMergedRefs, useAsync, useOnEvent } from '@fluentui/react-hooks';\nimport { useWindow } from '@fluentui/react-window-provider';\n\nfunction useScrollbarAsync(props, root) {\n  var async = useAsync();\n\n  var _a = React.useState(false),\n      needsVerticalScrollBarState = _a[0],\n      setNeedsVerticalScrollBar = _a[1];\n\n  React.useEffect(function () {\n    async.requestAnimationFrame(function () {\n      var _a; // If overflowY is overridden, don't waste time calculating whether the scrollbar is necessary.\n\n\n      if (props.style && props.style.overflowY) {\n        return;\n      }\n\n      var needsVerticalScrollBar = false;\n\n      if (root && root.current && ((_a = root.current) === null || _a === void 0 ? void 0 : _a.firstElementChild)) {\n        // ClientHeight returns the client height of an element rounded to an\n        // integer. On some browsers at different zoom levels this rounding\n        // can generate different results for the root container and child even\n        // though they are the same height. This causes us to show a scroll bar\n        // when not needed. Ideally we would use BoundingClientRect().height\n        // instead however seems that the API is 90% slower than using ClientHeight.\n        // Therefore instead we will calculate the difference between heights and\n        // allow for a 1px difference to still be considered ok and not show the\n        // scroll bar.\n        var rootHeight = root.current.clientHeight;\n        var firstChildHeight = root.current.firstElementChild.clientHeight;\n\n        if (rootHeight > 0 && firstChildHeight > rootHeight) {\n          needsVerticalScrollBar = firstChildHeight - rootHeight > 1;\n        }\n      }\n\n      if (needsVerticalScrollBarState !== needsVerticalScrollBar) {\n        setNeedsVerticalScrollBar(needsVerticalScrollBar);\n      }\n    });\n    return function () {\n      return async.dispose();\n    };\n  });\n  return needsVerticalScrollBarState;\n}\n\nfunction defaultFocusRestorer(options) {\n  var originalElement = options.originalElement,\n      containsFocus = options.containsFocus;\n\n  if (originalElement && containsFocus && originalElement !== getWindow()) {\n    // Make sure that the focus method actually exists\n    // In some cases the object might exist but not be a real element.\n    // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n    // This is wrapped in a setTimeout because of a React 16 bug that is resolved in 17.\n    // Once we move to 17, the setTimeout should be removed (ref: https://github.com/facebook/react/issues/17894#issuecomment-656094405)\n    setTimeout(function () {\n      var _a, _b;\n\n      (_b = (_a = originalElement).focus) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }, 0);\n  }\n}\n\nfunction useRestoreFocus(props, root) {\n  var _a = props.onRestoreFocus,\n      onRestoreFocus = _a === void 0 ? defaultFocusRestorer : _a;\n  var originalFocusedElement = React.useRef();\n  var containsFocus = React.useRef(false);\n  React.useEffect(function () {\n    originalFocusedElement.current = getDocument().activeElement;\n\n    if (doesElementContainFocus(root.current)) {\n      containsFocus.current = true;\n    }\n\n    return function () {\n      var _a, _b;\n\n      (_a = onRestoreFocus) === null || _a === void 0 ? void 0 : _a({\n        originalElement: originalFocusedElement.current,\n        containsFocus: containsFocus.current,\n        documentContainsFocus: ((_b = getDocument()) === null || _b === void 0 ? void 0 : _b.hasFocus()) || false\n      }); // De-reference DOM Node to avoid retainment via transpiled closure of _onKeyDown\n\n      originalFocusedElement.current = undefined;\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on first render\n  }, []);\n  useOnEvent(root, 'focus', React.useCallback(function () {\n    containsFocus.current = true;\n  }, []), true);\n  useOnEvent(root, 'blur', React.useCallback(function (ev) {\n    /** The popup should update this._containsFocus when:\n     * relatedTarget exists AND\n     * the relatedTarget is not contained within the popup.\n     * If the relatedTarget is within the popup, that means the popup still has focus\n     * and focused moved from one element to another within the popup.\n     * If relatedTarget is undefined or null that usually means that a\n     * keyboard event occurred and focus didn't change\n     */\n    if (root.current && ev.relatedTarget && !root.current.contains(ev.relatedTarget)) {\n      containsFocus.current = false;\n    } // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on first render\n\n  }, []), true);\n}\n/**\n * This adds accessibility to Dialog and Panel controls\n */\n\n\nexport var Popup = React.forwardRef(function (props, forwardedRef) {\n  // Default props\n  // eslint-disable-next-line deprecation/deprecation\n  props = __assign({\n    shouldRestoreFocus: true\n  }, props);\n  var root = React.useRef();\n  var mergedRootRef = useMergedRefs(root, forwardedRef);\n  useRestoreFocus(props, root);\n  var role = props.role,\n      className = props.className,\n      ariaLabel = props.ariaLabel,\n      ariaLabelledBy = props.ariaLabelledBy,\n      ariaDescribedBy = props.ariaDescribedBy,\n      style = props.style,\n      children = props.children,\n      onDismiss = props.onDismiss;\n  var needsVerticalScrollBar = useScrollbarAsync(props, root);\n  var onKeyDown = React.useCallback(function (ev) {\n    // eslint-disable-next-line deprecation/deprecation\n    switch (ev.which) {\n      case KeyCodes.escape:\n        if (onDismiss) {\n          onDismiss(ev);\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n\n        break;\n    }\n  }, [onDismiss]);\n  var win = useWindow();\n  useOnEvent(win, 'keydown', onKeyDown);\n  return React.createElement(\"div\", __assign({\n    ref: mergedRootRef\n  }, getNativeProps(props, divProperties), {\n    className: className,\n    role: role,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-describedby\": ariaDescribedBy,\n    onKeyDown: onKeyDown,\n    style: __assign({\n      overflowY: needsVerticalScrollBar ? 'scroll' : undefined,\n      outline: 'none'\n    }, style)\n  }), children);\n});","map":{"version":3,"sources":["components/Popup/Popup.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  KeyCodes,\n  divProperties,\n  doesElementContainFocus,\n  getDocument,\n  getNativeProps,\n  getWindow,\n} from '../../Utilities';\nimport { IPopupProps, IPopupRestoreFocusParams } from './Popup.types';\nimport { useMergedRefs, useAsync, useOnEvent } from '@fluentui/react-hooks';\nimport { useWindow } from '@fluentui/react-window-provider';\n\nfunction useScrollbarAsync(props: IPopupProps, root: React.RefObject<HTMLDivElement | undefined>) {\n  const async = useAsync();\n  const [needsVerticalScrollBarState, setNeedsVerticalScrollBar] = React.useState(false);\n  React.useEffect(() => {\n    async.requestAnimationFrame(() => {\n      // If overflowY is overridden, don't waste time calculating whether the scrollbar is necessary.\n      if (props.style && props.style.overflowY) {\n        return;\n      }\n\n      let needsVerticalScrollBar = false;\n      if (root && root.current && root.current?.firstElementChild) {\n        // ClientHeight returns the client height of an element rounded to an\n        // integer. On some browsers at different zoom levels this rounding\n        // can generate different results for the root container and child even\n        // though they are the same height. This causes us to show a scroll bar\n        // when not needed. Ideally we would use BoundingClientRect().height\n        // instead however seems that the API is 90% slower than using ClientHeight.\n        // Therefore instead we will calculate the difference between heights and\n        // allow for a 1px difference to still be considered ok and not show the\n        // scroll bar.\n        const rootHeight = root.current.clientHeight;\n        const firstChildHeight = root.current.firstElementChild.clientHeight;\n        if (rootHeight > 0 && firstChildHeight > rootHeight) {\n          needsVerticalScrollBar = firstChildHeight - rootHeight > 1;\n        }\n      }\n      if (needsVerticalScrollBarState !== needsVerticalScrollBar) {\n        setNeedsVerticalScrollBar(needsVerticalScrollBar);\n      }\n    });\n\n    return () => async.dispose();\n  });\n\n  return needsVerticalScrollBarState;\n}\n\nfunction defaultFocusRestorer(options: IPopupRestoreFocusParams) {\n  const { originalElement, containsFocus } = options;\n\n  if (originalElement && containsFocus && originalElement !== getWindow()) {\n    // Make sure that the focus method actually exists\n    // In some cases the object might exist but not be a real element.\n    // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n    // This is wrapped in a setTimeout because of a React 16 bug that is resolved in 17.\n    // Once we move to 17, the setTimeout should be removed (ref: https://github.com/facebook/react/issues/17894#issuecomment-656094405)\n    setTimeout(() => {\n      originalElement.focus?.();\n    }, 0);\n  }\n}\n\nfunction useRestoreFocus(props: IPopupProps, root: React.RefObject<HTMLDivElement | undefined>) {\n  const { onRestoreFocus = defaultFocusRestorer } = props;\n  const originalFocusedElement = React.useRef<HTMLElement>();\n  const containsFocus = React.useRef(false);\n\n  React.useEffect(() => {\n    originalFocusedElement.current = getDocument()!.activeElement as HTMLElement;\n\n    if (doesElementContainFocus(root.current!)) {\n      containsFocus.current = true;\n    }\n\n    return () => {\n      onRestoreFocus?.({\n        originalElement: originalFocusedElement.current,\n        containsFocus: containsFocus.current,\n        documentContainsFocus: getDocument()?.hasFocus() || false,\n      });\n\n      // De-reference DOM Node to avoid retainment via transpiled closure of _onKeyDown\n      originalFocusedElement.current = undefined;\n    };\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on first render\n  }, []);\n\n  useOnEvent(\n    root,\n    'focus',\n    React.useCallback((): void => {\n      containsFocus.current = true;\n    }, []),\n    true,\n  );\n\n  useOnEvent(\n    root,\n    'blur',\n    React.useCallback((ev: FocusEvent): void => {\n      /** The popup should update this._containsFocus when:\n       * relatedTarget exists AND\n       * the relatedTarget is not contained within the popup.\n       * If the relatedTarget is within the popup, that means the popup still has focus\n       * and focused moved from one element to another within the popup.\n       * If relatedTarget is undefined or null that usually means that a\n       * keyboard event occurred and focus didn't change\n       */\n      if (root.current && ev.relatedTarget && !root.current.contains(ev.relatedTarget as HTMLElement)) {\n        containsFocus.current = false;\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on first render\n    }, []),\n    true,\n  );\n}\n\n/**\n * This adds accessibility to Dialog and Panel controls\n */\nexport const Popup: React.FunctionComponent<IPopupProps> = React.forwardRef<HTMLDivElement, IPopupProps>(\n  (props, forwardedRef) => {\n    // Default props\n    // eslint-disable-next-line deprecation/deprecation\n    props = { shouldRestoreFocus: true, ...props };\n\n    const root = React.useRef<HTMLDivElement>();\n    const mergedRootRef = useMergedRefs(root, forwardedRef) as React.Ref<HTMLDivElement>;\n\n    useRestoreFocus(props, root);\n\n    const { role, className, ariaLabel, ariaLabelledBy, ariaDescribedBy, style, children, onDismiss } = props;\n    const needsVerticalScrollBar = useScrollbarAsync(props, root);\n\n    const onKeyDown = React.useCallback(\n      (ev: React.KeyboardEvent<HTMLElement> | KeyboardEvent): void => {\n        // eslint-disable-next-line deprecation/deprecation\n        switch (ev.which) {\n          case KeyCodes.escape:\n            if (onDismiss) {\n              onDismiss(ev);\n\n              ev.preventDefault();\n              ev.stopPropagation();\n            }\n\n            break;\n        }\n      },\n      [onDismiss],\n    );\n\n    const win = useWindow();\n    useOnEvent(win, 'keydown', onKeyDown as (ev: Event) => void);\n\n    return (\n      <div\n        ref={mergedRootRef}\n        {...getNativeProps(props, divProperties)}\n        className={className}\n        role={role}\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        aria-describedby={ariaDescribedBy}\n        onKeyDown={onKeyDown}\n        style={{ overflowY: needsVerticalScrollBar ? 'scroll' : undefined, outline: 'none', ...style }}\n      >\n        {children}\n      </div>\n    );\n  },\n);\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}