{"ast":null,"code":"import * as React from 'react';\nimport { useRefEffect } from '@fluentui/react-hooks';\nimport { getWindow } from '@fluentui/utilities';\nimport { observeResize } from './observeResize';\n/**\n * Track whether any items don't fit within their container, and move them to the overflow menu.\n * Items are moved into the overflow menu from back to front, excluding pinned items.\n *\n * The overflow menu button must be the last sibling of all of the items that can be put into the overflow, and it\n * must be hooked up to the `setMenuButtonRef` setter function that's returned by `useOverflow`:\n * ```ts\n * const overflow = useOverflow(...);\n * ```\n * ```jsx\n * <Container>\n *  <Item /> // Index 0\n *  <Item /> // Index 1\n *  ...\n *  <Button ref={overflow.setMenuButtonRef} /> // Can be any React.Component or HTMLElement\n * </Container>\n * ```\n */\n\nexport var useOverflow = function (_a) {\n  var onOverflowItemsChanged = _a.onOverflowItemsChanged,\n      rtl = _a.rtl,\n      pinnedIndex = _a.pinnedIndex;\n  var updateOverflowRef = React.useRef();\n  var containerWidthRef = React.useRef(); // Attach a resize observer to the container\n\n  var containerRef = useRefEffect(function (container) {\n    var cleanupObserver = observeResize(container, function (entries) {\n      containerWidthRef.current = entries ? entries[0].contentRect.width : container.clientWidth;\n\n      if (updateOverflowRef.current) {\n        updateOverflowRef.current();\n      }\n    });\n    return function () {\n      cleanupObserver();\n      containerWidthRef.current = undefined;\n    };\n  });\n  var menuButtonRef = useRefEffect(function (menuButton) {\n    containerRef(menuButton.parentElement);\n    return function () {\n      return containerRef(null);\n    };\n  }); // eslint-disable-next-line no-restricted-properties\n\n  React.useLayoutEffect(function () {\n    var container = containerRef.current;\n    var menuButton = menuButtonRef.current;\n\n    if (!container || !menuButton) {\n      return;\n    } // items contains the container's children, excluding the overflow menu button itself\n\n\n    var items = [];\n\n    for (var i = 0; i < container.children.length; i++) {\n      var item = container.children[i];\n\n      if (item instanceof HTMLElement && item !== menuButton) {\n        items.push(item);\n      }\n    } // Keep track of the minimum width of the container to fit each child index.\n    // This cache is an integral part of the algorithm and not just a performance optimization: it allows us to\n    // recalculate the overflowIndex on subsequent resizes even if some items are already inside the overflow.\n\n\n    var minContainerWidth = [];\n    var extraWidth = 0; // The accumulated width of items that don't move into the overflow\n\n    updateOverflowRef.current = function () {\n      var containerWidth = containerWidthRef.current;\n\n      if (containerWidth === undefined) {\n        return;\n      } // Iterate the items in reverse order until we find one that fits within the bounds of the container\n\n\n      for (var i = items.length - 1; i >= 0; i--) {\n        // Calculate the min container width for this item if we haven't done so yet\n        if (minContainerWidth[i] === undefined) {\n          var itemOffsetEnd = rtl ? containerWidth - items[i].offsetLeft : items[i].offsetLeft + items[i].offsetWidth; // If the item after this one is pinned, reserve space for it\n\n          if (i + 1 < items.length && i + 1 === pinnedIndex) {\n            // Use distance between the end of the previous item and this one (rather than the\n            // pinned item's offsetWidth), to account for any margin between the items.\n            extraWidth = minContainerWidth[i + 1] - itemOffsetEnd;\n          } // Reserve space for the menu button after the first item was added to the overflow\n\n\n          if (i === items.length - 2) {\n            extraWidth += menuButton.offsetWidth;\n          }\n\n          minContainerWidth[i] = itemOffsetEnd + extraWidth;\n        }\n\n        if (containerWidth > minContainerWidth[i]) {\n          setOverflowIndex(i + 1);\n          return;\n        }\n      } // If we got here, nothing fits outside the overflow\n\n\n      setOverflowIndex(0);\n    };\n\n    var prevOverflowIndex = items.length;\n\n    var setOverflowIndex = function (overflowIndex) {\n      if (prevOverflowIndex !== overflowIndex) {\n        prevOverflowIndex = overflowIndex;\n        onOverflowItemsChanged(overflowIndex, items.map(function (ele, index) {\n          return {\n            ele: ele,\n            isOverflowing: index >= overflowIndex && index !== pinnedIndex\n          };\n        }));\n      }\n    };\n\n    var cancelAnimationFrame = undefined; // If the container width is already known from a previous render, update the overflow with its width.\n    // Do this in an animation frame to avoid forcing layout to happen early.\n\n    if (containerWidthRef.current !== undefined) {\n      var win_1 = getWindow(container);\n\n      if (win_1) {\n        var animationFrameId_1 = win_1.requestAnimationFrame(updateOverflowRef.current);\n\n        cancelAnimationFrame = function () {\n          return win_1.cancelAnimationFrame(animationFrameId_1);\n        };\n      }\n    }\n\n    return function () {\n      if (cancelAnimationFrame) {\n        cancelAnimationFrame();\n      } // On cleanup, need to remove all items from the overflow\n      // so they don't have stale properties on the next render\n\n\n      setOverflowIndex(items.length);\n      updateOverflowRef.current = undefined;\n    };\n  });\n  return {\n    menuButtonRef: menuButtonRef\n  };\n};","map":{"version":3,"sources":["utilities/useOverflow.ts"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { useRefEffect, RefCallback } from '@fluentui/react-hooks';\nimport { getWindow } from '@fluentui/utilities';\nimport { observeResize } from './observeResize';\n\n/**\n * Callback to notify the user that the items in the overflow have changed. This should ensure that the overflow menu\n * is visible, and contains all of the overflowing items.\n *\n * @param overflowIndex - The index of the first item in the overflow, or items.length if nothing is overflowing.\n * @param items - The list of all items in the container, and whether that particular item is in the overflow\n */\nexport type OverflowItemsChangedCallback = (\n  overflowIndex: number,\n  items: { ele: HTMLElement; isOverflowing: boolean }[],\n) => void;\n\n/** Parameters for {@see useOverflow} */\nexport type OverflowParams = {\n  /** Callback to notify the user that the items in the overflow have changed. */\n  onOverflowItemsChanged: OverflowItemsChangedCallback;\n\n  /** True if the element containing overflowMenuButtonRef is in right-to-left order */\n  rtl: boolean;\n\n  /** Optional: Index of item that should never go into the overflow menu. */\n  pinnedIndex?: number;\n};\n\n/** Return value for {@see useOverflow} */\nexport type OverflowRefs = {\n  /** Set the overflow menu button's ref to this ref callback */\n  menuButtonRef: RefCallback<HTMLElement>;\n};\n\n/**\n * Track whether any items don't fit within their container, and move them to the overflow menu.\n * Items are moved into the overflow menu from back to front, excluding pinned items.\n *\n * The overflow menu button must be the last sibling of all of the items that can be put into the overflow, and it\n * must be hooked up to the `setMenuButtonRef` setter function that's returned by `useOverflow`:\n * ```ts\n * const overflow = useOverflow(...);\n * ```\n * ```jsx\n * <Container>\n *  <Item /> // Index 0\n *  <Item /> // Index 1\n *  ...\n *  <Button ref={overflow.setMenuButtonRef} /> // Can be any React.Component or HTMLElement\n * </Container>\n * ```\n */\nexport const useOverflow = ({ onOverflowItemsChanged, rtl, pinnedIndex }: OverflowParams): OverflowRefs => {\n  const updateOverflowRef = React.useRef<() => void>();\n  const containerWidthRef = React.useRef<number>();\n\n  // Attach a resize observer to the container\n  const containerRef = useRefEffect<HTMLElement>(container => {\n    const cleanupObserver = observeResize(container, entries => {\n      containerWidthRef.current = entries ? entries[0].contentRect.width : container.clientWidth;\n      if (updateOverflowRef.current) {\n        updateOverflowRef.current();\n      }\n    });\n\n    return () => {\n      cleanupObserver();\n      containerWidthRef.current = undefined;\n    };\n  });\n\n  const menuButtonRef = useRefEffect<HTMLElement>(menuButton => {\n    containerRef(menuButton.parentElement);\n    return () => containerRef(null);\n  });\n\n  // eslint-disable-next-line no-restricted-properties\n  React.useLayoutEffect(() => {\n    const container = containerRef.current;\n    const menuButton = menuButtonRef.current;\n    if (!container || !menuButton) {\n      return;\n    }\n\n    // items contains the container's children, excluding the overflow menu button itself\n    const items: HTMLElement[] = [];\n    for (let i = 0; i < container.children.length; i++) {\n      const item = container.children[i];\n      if (item instanceof HTMLElement && item !== menuButton) {\n        items.push(item);\n      }\n    }\n\n    // Keep track of the minimum width of the container to fit each child index.\n    // This cache is an integral part of the algorithm and not just a performance optimization: it allows us to\n    // recalculate the overflowIndex on subsequent resizes even if some items are already inside the overflow.\n    const minContainerWidth: number[] = [];\n    let extraWidth = 0; // The accumulated width of items that don't move into the overflow\n\n    updateOverflowRef.current = () => {\n      const containerWidth = containerWidthRef.current;\n      if (containerWidth === undefined) {\n        return;\n      }\n\n      // Iterate the items in reverse order until we find one that fits within the bounds of the container\n      for (let i = items.length - 1; i >= 0; i--) {\n        // Calculate the min container width for this item if we haven't done so yet\n        if (minContainerWidth[i] === undefined) {\n          const itemOffsetEnd = rtl ? containerWidth - items[i].offsetLeft : items[i].offsetLeft + items[i].offsetWidth;\n\n          // If the item after this one is pinned, reserve space for it\n          if (i + 1 < items.length && i + 1 === pinnedIndex) {\n            // Use distance between the end of the previous item and this one (rather than the\n            // pinned item's offsetWidth), to account for any margin between the items.\n            extraWidth = minContainerWidth[i + 1] - itemOffsetEnd;\n          }\n\n          // Reserve space for the menu button after the first item was added to the overflow\n          if (i === items.length - 2) {\n            extraWidth += menuButton.offsetWidth;\n          }\n\n          minContainerWidth[i] = itemOffsetEnd + extraWidth;\n        }\n\n        if (containerWidth > minContainerWidth[i]) {\n          setOverflowIndex(i + 1);\n          return;\n        }\n      }\n\n      // If we got here, nothing fits outside the overflow\n      setOverflowIndex(0);\n    };\n\n    let prevOverflowIndex = items.length;\n    const setOverflowIndex = (overflowIndex: number) => {\n      if (prevOverflowIndex !== overflowIndex) {\n        prevOverflowIndex = overflowIndex;\n        onOverflowItemsChanged(\n          overflowIndex,\n          items.map((ele, index) => ({\n            ele,\n            isOverflowing: index >= overflowIndex && index !== pinnedIndex,\n          })),\n        );\n      }\n    };\n\n    let cancelAnimationFrame: (() => void) | undefined = undefined;\n\n    // If the container width is already known from a previous render, update the overflow with its width.\n    // Do this in an animation frame to avoid forcing layout to happen early.\n    if (containerWidthRef.current !== undefined) {\n      const win = getWindow(container);\n      if (win) {\n        const animationFrameId = win.requestAnimationFrame(updateOverflowRef.current);\n        cancelAnimationFrame = () => win.cancelAnimationFrame(animationFrameId);\n      }\n    }\n\n    return () => {\n      if (cancelAnimationFrame) {\n        cancelAnimationFrame();\n      }\n\n      // On cleanup, need to remove all items from the overflow\n      // so they don't have stale properties on the next render\n      setOverflowIndex(items.length);\n      updateOverflowRef.current = undefined;\n    };\n  });\n\n  return { menuButtonRef };\n};\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}