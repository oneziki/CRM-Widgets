{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { IconButton } from '../../Button';\nimport { Label } from '../../Label';\nimport { Icon } from '../../Icon';\nimport { KeyCodes, calculatePrecision, classNamesFunction, precisionRound, getNativeProps, getPropsWithDefaults, divProperties } from '../../Utilities';\nimport { getArrowButtonStyles } from './SpinButton.styles';\nimport { KeyboardSpinDirection } from './SpinButton.types';\nimport { Position } from '../../Positioning';\nimport { useAsync, useControllableValue, useWarnings, useId, usePrevious } from '@fluentui/react-hooks';\nvar getClassNames = classNamesFunction();\nvar COMPONENT_NAME = 'SpinButton';\nvar DEFAULT_PROPS = {\n  disabled: false,\n  label: '',\n  step: 1,\n  labelPosition: Position.start,\n  incrementButtonIcon: {\n    iconName: 'ChevronUpSmall'\n  },\n  decrementButtonIcon: {\n    iconName: 'ChevronDownSmall'\n  }\n};\nvar INITIAL_STEP_DELAY = 400;\nvar STEP_DELAY = 75;\n\nvar useComponentRef = function (props, input, value) {\n  React.useImperativeHandle(props.componentRef, function () {\n    return {\n      get value() {\n        return value;\n      },\n\n      focus: function () {\n        if (input.current) {\n          input.current.focus();\n        }\n      }\n    };\n  }, [input, value]);\n};\n\nvar noOp = function () {\n  /**\n   * A noop input change handler. Using onInput instead of onChange was meant to address an issue\n   * which apparently has been resolved in React 16 (https://github.com/facebook/react/issues/7027).\n   * The no-op onChange handler was still needed because React gives console errors if an input\n   * doesn't have onChange.\n   *\n   * TODO (Fabric 8?) - switch to just calling onChange (this is a breaking change for any tests,\n   * ours or 3rd-party, which simulate entering text in a SpinButton)\n   */\n};\n/** Clamp the value to the provided min and/or max */\n\n\nvar clampValue = function (value, _a) {\n  var min = _a.min,\n      max = _a.max;\n\n  if (typeof max === 'number') {\n    value = Math.min(value, max);\n  }\n\n  if (typeof min === 'number') {\n    value = Math.max(value, min);\n  }\n\n  return value;\n};\n\nexport var SpinButtonBase = React.forwardRef(function (propsWithoutDefaults, ref) {\n  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n  var disabled = props.disabled,\n      label = props.label,\n      min = props.min,\n      max = props.max,\n      step = props.step,\n      defaultValue = props.defaultValue,\n      valueFromProps = props.value,\n      precisionFromProps = props.precision,\n      labelPosition = props.labelPosition,\n      iconProps = props.iconProps,\n      incrementButtonIcon = props.incrementButtonIcon,\n      incrementButtonAriaLabel = props.incrementButtonAriaLabel,\n      decrementButtonIcon = props.decrementButtonIcon,\n      decrementButtonAriaLabel = props.decrementButtonAriaLabel,\n      ariaLabel = props.ariaLabel,\n      ariaDescribedBy = props.ariaDescribedBy,\n      customUpArrowButtonStyles = props.upArrowButtonStyles,\n      customDownArrowButtonStyles = props.downArrowButtonStyles,\n      theme = props.theme,\n      ariaPositionInSet = props.ariaPositionInSet,\n      ariaSetSize = props.ariaSetSize,\n      ariaValueNow = props.ariaValueNow,\n      ariaValueText = props.ariaValueText,\n      className = props.className,\n      inputProps = props.inputProps,\n      onDecrement = props.onDecrement,\n      onIncrement = props.onIncrement,\n      iconButtonProps = props.iconButtonProps,\n      onValidate = props.onValidate,\n      onChange = props.onChange,\n      styles = props.styles;\n  var input = React.useRef(null);\n  var inputId = useId('input');\n  var labelId = useId('Label');\n\n  var _a = React.useState(false),\n      isFocused = _a[0],\n      setIsFocused = _a[1];\n\n  var _b = React.useState(KeyboardSpinDirection.notSpinning),\n      keyboardSpinDirection = _b[0],\n      setKeyboardSpinDirection = _b[1];\n\n  var async = useAsync();\n  var precision = React.useMemo(function () {\n    return precisionFromProps !== null && precisionFromProps !== void 0 ? precisionFromProps : Math.max(calculatePrecision(step), 0);\n  }, [precisionFromProps, step]);\n  /**\n   * Actual current value. If `props.value` is provided (controlled), it will always be used.\n   * If not (uncontrolled), this tracks the current value based on user modifications.\n   * Note that while the user is editing text in the field, this will not be updated until \"commit\"\n   * (blur or press enter).\n   */\n\n  var _c = useControllableValue(valueFromProps, defaultValue !== null && defaultValue !== void 0 ? defaultValue : String(min || 0), onChange),\n      value = _c[0],\n      setValue = _c[1];\n  /**\n   * \"Uncommitted\" internal value while the user is editing text in the field. This lets us wait to\n   * call `onChange` (and possibly update the real value) until the user \"commits\" the value by\n   * pressing enter or blurring the field.\n   */\n\n\n  var _d = React.useState(),\n      intermediateValue = _d[0],\n      setIntermediateValue = _d[1];\n\n  var internalState = React.useRef({\n    stepTimeoutHandle: -1,\n    latestValue: undefined,\n    latestIntermediateValue: undefined\n  }).current; // On each render, update this saved value used by callbacks. (This should be safe even if render\n  // is called multiple times, because an event handler or timeout callback will only run once.)\n\n  internalState.latestValue = value;\n  internalState.latestIntermediateValue = intermediateValue;\n  var previousValueFromProps = usePrevious(valueFromProps);\n  React.useEffect(function () {\n    // If props.value changes while editing, clear the intermediate value\n    if (valueFromProps !== previousValueFromProps && intermediateValue !== undefined) {\n      setIntermediateValue(undefined);\n    }\n  }, [valueFromProps, previousValueFromProps, intermediateValue]);\n  var classNames = getClassNames(styles, {\n    theme: theme,\n    disabled: disabled,\n    isFocused: isFocused,\n    keyboardSpinDirection: keyboardSpinDirection,\n    labelPosition: labelPosition,\n    className: className\n  });\n  var nativeProps = getNativeProps(props, divProperties, ['onBlur', 'onFocus', 'className', 'onChange']);\n  /** Validate (commit) function called on blur or enter keypress. */\n\n  var validate = React.useCallback(function (ev) {\n    // Only run validation if the value changed\n    var enteredValue = internalState.latestIntermediateValue;\n\n    if (enteredValue !== undefined && enteredValue !== internalState.latestValue) {\n      var newValue = void 0;\n\n      if (onValidate) {\n        newValue = onValidate(enteredValue, ev);\n      } else if (enteredValue && enteredValue.trim().length && !isNaN(Number(enteredValue))) {\n        // default validation handling\n        newValue = String(clampValue(Number(enteredValue), {\n          min: min,\n          max: max\n        }));\n      }\n\n      if (newValue !== undefined && newValue !== internalState.latestValue) {\n        // Commit the value if it changed\n        setValue(newValue, ev);\n      }\n    } // Done validating, so clear the intermediate typed value (if any)\n\n\n    setIntermediateValue(undefined);\n  }, [internalState, max, min, onValidate, setValue]);\n  /**\n   * Stop spinning (clear any currently pending update and set spinning to false)\n   */\n\n  var stop = React.useCallback(function () {\n    if (internalState.stepTimeoutHandle >= 0) {\n      async.clearTimeout(internalState.stepTimeoutHandle);\n      internalState.stepTimeoutHandle = -1;\n    }\n\n    if (internalState.spinningByMouse || keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      internalState.spinningByMouse = false;\n      setKeyboardSpinDirection(KeyboardSpinDirection.notSpinning);\n    }\n  }, [internalState, keyboardSpinDirection, async]);\n  /**\n   * Update the value with the given stepFunction.\n   * Also starts spinning for mousedown events by scheduling another update with setTimeout.\n   * @param stepFunction - function to use to step by\n   * @param event - The event that triggered the updateValue\n   */\n\n  var updateValue = React.useCallback(function (stepFunction, ev) {\n    ev.persist();\n\n    if (internalState.latestIntermediateValue !== undefined) {\n      // Edge case: if intermediateValue is set, this means that the user was editing the input\n      // text and then started spinning (either with mouse or keyboard). We need to validate and\n      // call onChange before starting to spin.\n      if (ev.type === 'keydown') {\n        // For the arrow keys, we have to manually trigger validation.\n        // (For the buttons, validation will happen automatically since the input's onBlur will\n        // be triggered after mousedown on the button completes.)\n        validate(ev);\n      }\n\n      async.requestAnimationFrame(function () {\n        // After handling any value updates, do the spinning update\n        updateValue(stepFunction, ev);\n      });\n      return;\n    } // Call the step function and update the value.\n    // (Note: we access the latest value via internalState (not directly) to ensure we don't use\n    // a stale captured value. This is mainly important for spinning by mouse, where we trigger\n    // additional calls to the original updateValue function via setTimeout. It also lets us\n    // avoid useCallback deps on frequently changing values.)\n\n\n    var newValue = stepFunction(internalState.latestValue || '', ev);\n\n    if (newValue !== undefined && newValue !== internalState.latestValue) {\n      setValue(newValue, ev);\n    } // Schedule the next spin if applicable\n    // (will be canceled if there's a mouseup before the timeout runs)\n\n\n    var wasSpinning = internalState.spinningByMouse;\n    internalState.spinningByMouse = ev.type === 'mousedown';\n\n    if (internalState.spinningByMouse) {\n      internalState.stepTimeoutHandle = async.setTimeout(function () {\n        updateValue(stepFunction, ev);\n      }, wasSpinning ? STEP_DELAY : INITIAL_STEP_DELAY);\n    }\n  }, [internalState, async, validate, setValue]);\n  /** Composed increment handler (uses `props.onIncrement` or default) */\n\n  var handleIncrement = React.useCallback(function (newValue) {\n    if (onIncrement) {\n      return onIncrement(newValue);\n    } else {\n      var numericValue = clampValue(Number(newValue) + Number(step), {\n        max: max\n      });\n      numericValue = precisionRound(numericValue, precision);\n      return String(numericValue);\n    }\n  }, [precision, max, onIncrement, step]);\n  /** Composed decrement handler (uses `props.onDecrement` or default) */\n\n  var handleDecrement = React.useCallback(function (newValue) {\n    if (onDecrement) {\n      return onDecrement(newValue);\n    } else {\n      var numericValue = clampValue(Number(newValue) - Number(step), {\n        min: min\n      });\n      numericValue = precisionRound(numericValue, precision);\n      return String(numericValue);\n    }\n  }, [precision, min, onDecrement, step]);\n  /** Handles when the user types in the input */\n\n  var handleInputChange = function (ev) {\n    setIntermediateValue(ev.target.value);\n  };\n  /** Composed focus handler (does internal stuff and calls `props.onFocus`) */\n\n\n  var handleFocus = function (ev) {\n    var _a; // We can't set focus on a non-existing element\n\n\n    if (!input.current) {\n      return;\n    }\n\n    if (internalState.spinningByMouse || keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      stop();\n    }\n\n    input.current.select();\n    setIsFocused(true);\n    (_a = props.onFocus) === null || _a === void 0 ? void 0 : _a.call(props, ev);\n  };\n  /** Composed blur handler (does internal stuff and calls `props.onBlur`) */\n\n\n  var handleBlur = function (ev) {\n    var _a;\n\n    validate(ev);\n    setIsFocused(false);\n    (_a = props.onBlur) === null || _a === void 0 ? void 0 : _a.call(props, ev);\n  };\n  /** Update value when arrow keys are pressed, commit on enter, or revert on escape */\n\n\n  var handleKeyDown = function (ev) {\n    // eat the up and down arrow keys to keep focus in the spinButton\n    // (especially when a spinButton is inside of a FocusZone)\n    // eslint-disable-next-line deprecation/deprecation\n    if (ev.which === KeyCodes.up || ev.which === KeyCodes.down || ev.which === KeyCodes.enter) {\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n\n    if (disabled) {\n      stop();\n      return;\n    }\n\n    var spinDirection = KeyboardSpinDirection.notSpinning; // eslint-disable-next-line deprecation/deprecation\n\n    switch (ev.which) {\n      case KeyCodes.up:\n        spinDirection = KeyboardSpinDirection.up;\n        updateValue(handleIncrement, ev);\n        break;\n\n      case KeyCodes.down:\n        spinDirection = KeyboardSpinDirection.down;\n        updateValue(handleDecrement, ev);\n        break;\n\n      case KeyCodes.enter:\n        // Commit the edited value\n        validate(ev);\n        break;\n\n      case KeyCodes.escape:\n        // Revert to previous value\n        setIntermediateValue(undefined);\n        break;\n    } // style the increment/decrement button to look active\n    // when the corresponding up/down arrow keys trigger a step\n\n\n    if (keyboardSpinDirection !== spinDirection) {\n      setKeyboardSpinDirection(spinDirection);\n    }\n  };\n  /** Stop spinning on keyUp if the up or down arrow key fired this event */\n\n\n  var handleKeyUp = React.useCallback(function (ev) {\n    // eslint-disable-next-line deprecation/deprecation\n    if (disabled || ev.which === KeyCodes.up || ev.which === KeyCodes.down) {\n      stop();\n      return;\n    }\n  }, [disabled, stop]);\n  var handleIncrementMouseDown = React.useCallback(function (ev) {\n    updateValue(handleIncrement, ev);\n  }, [handleIncrement, updateValue]);\n  var handleDecrementMouseDown = React.useCallback(function (ev) {\n    updateValue(handleDecrement, ev);\n  }, [handleDecrement, updateValue]);\n  useComponentRef(props, input, value);\n  useDebugWarnings(props);\n  var valueIsNumber = !!value && !isNaN(Number(value)); // Number('') is 0 which may not be desirable\n\n  var labelContent = (iconProps || label) && React.createElement(\"div\", {\n    className: classNames.labelWrapper\n  }, iconProps && React.createElement(Icon, __assign({}, iconProps, {\n    className: classNames.icon,\n    \"aria-hidden\": \"true\"\n  })), label && React.createElement(Label, {\n    id: labelId,\n    htmlFor: inputId,\n    className: classNames.label,\n    disabled: disabled\n  }, label));\n  return React.createElement(\"div\", {\n    className: classNames.root,\n    ref: ref\n  }, labelPosition !== Position.bottom && labelContent, React.createElement(\"div\", __assign({}, nativeProps, {\n    className: classNames.spinButtonWrapper,\n    \"aria-label\": ariaLabel && ariaLabel,\n    \"aria-posinset\": ariaPositionInSet,\n    \"aria-setsize\": ariaSetSize,\n    \"data-ktp-target\": true\n  }), React.createElement(\"input\", __assign({\n    // Display intermediateValue while editing the text (before commit)\n    value: intermediateValue !== null && intermediateValue !== void 0 ? intermediateValue : value,\n    id: inputId,\n    onChange: noOp,\n    onInput: handleInputChange,\n    className: classNames.input,\n    type: \"text\",\n    autoComplete: \"off\",\n    role: \"spinbutton\",\n    \"aria-labelledby\": label && labelId,\n    \"aria-valuenow\": ariaValueNow !== null && ariaValueNow !== void 0 ? ariaValueNow : valueIsNumber ? Number(value) : undefined,\n    \"aria-valuetext\": ariaValueText !== null && ariaValueText !== void 0 ? ariaValueText : valueIsNumber ? undefined : value,\n    \"aria-valuemin\": min,\n    \"aria-valuemax\": max,\n    \"aria-describedby\": ariaDescribedBy,\n    onBlur: handleBlur,\n    ref: input,\n    onFocus: handleFocus,\n    onKeyDown: handleKeyDown,\n    onKeyUp: handleKeyUp,\n    disabled: disabled,\n    \"aria-disabled\": disabled,\n    \"data-lpignore\": true,\n    \"data-ktp-execute-target\": true\n  }, inputProps)), React.createElement(\"span\", {\n    className: classNames.arrowButtonsContainer\n  }, React.createElement(IconButton, __assign({\n    styles: getArrowButtonStyles(theme, true, customUpArrowButtonStyles),\n    className: 'ms-UpButton',\n    checked: keyboardSpinDirection === KeyboardSpinDirection.up,\n    disabled: disabled,\n    iconProps: incrementButtonIcon,\n    onMouseDown: handleIncrementMouseDown,\n    onMouseLeave: stop,\n    onMouseUp: stop,\n    tabIndex: -1,\n    ariaLabel: incrementButtonAriaLabel,\n    \"data-is-focusable\": false\n  }, iconButtonProps)), React.createElement(IconButton, __assign({\n    styles: getArrowButtonStyles(theme, false, customDownArrowButtonStyles),\n    className: 'ms-DownButton',\n    checked: keyboardSpinDirection === KeyboardSpinDirection.down,\n    disabled: disabled,\n    iconProps: decrementButtonIcon,\n    onMouseDown: handleDecrementMouseDown,\n    onMouseLeave: stop,\n    onMouseUp: stop,\n    tabIndex: -1,\n    ariaLabel: decrementButtonAriaLabel,\n    \"data-is-focusable\": false\n  }, iconButtonProps)))), labelPosition === Position.bottom && labelContent);\n});\nSpinButtonBase.displayName = COMPONENT_NAME;\n\nvar useDebugWarnings = function (props) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props: props,\n      mutuallyExclusive: {\n        value: 'defaultValue'\n      }\n    });\n  }\n};","map":{"version":3,"sources":["components/SpinButton/SpinButton.base.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AACA,SAAS,UAAT,QAA2B,cAA3B;AACA,SAAS,KAAT,QAAsB,aAAtB;AACA,SAAS,IAAT,QAAqB,YAArB;AACA,SACE,QADF,EAEE,kBAFF,EAGE,kBAHF,EAIE,cAJF,EAKE,cALF,EAME,oBANF,EAOE,aAPF,QAQO,iBARP;AASA,SAAS,oBAAT,QAAqC,qBAArC;AACA,SAAqE,qBAArE,QAAkG,oBAAlG;AACA,SAAS,QAAT,QAAyB,mBAAzB;AACA,SAAS,QAAT,EAAmB,oBAAnB,EAAyC,WAAzC,EAAsD,KAAtD,EAA6D,WAA7D,QAAgF,uBAAhF;AAWA,IAAM,aAAa,GAAG,kBAAkB,EAAxC;AAEA,IAAM,cAAc,GAAG,YAAvB;AACA,IAAM,aAAa,GAOf;AACF,EAAA,QAAQ,EAAE,KADR;AAEF,EAAA,KAAK,EAAE,EAFL;AAGF,EAAA,IAAI,EAAE,CAHJ;AAIF,EAAA,aAAa,EAAE,QAAQ,CAAC,KAJtB;AAKF,EAAA,mBAAmB,EAAE;AAAE,IAAA,QAAQ,EAAE;AAAZ,GALnB;AAMF,EAAA,mBAAmB,EAAE;AAAE,IAAA,QAAQ,EAAE;AAAZ;AANnB,CAPJ;AAiBA,IAAM,kBAAkB,GAAG,GAA3B;AACA,IAAM,UAAU,GAAG,EAAnB;;AAEA,IAAM,eAAe,GAAG,UACtB,KADsB,EAEtB,KAFsB,EAGtB,KAHsB,EAGG;AAEzB,EAAA,KAAK,CAAC,mBAAN,CACE,KAAK,CAAC,YADR,EAEE,YAAA;AAAM,WAAC;AACL,UAAI,KAAJ,GAAS;AACP,eAAO,KAAP;AACD,OAHI;;AAIL,MAAA,KAAK,EAAA,YAAA;AACH,YAAI,KAAK,CAAC,OAAV,EAAmB;AACjB,UAAA,KAAK,CAAC,OAAN,CAAc,KAAd;AACD;AACF;AARI,KAAD;AASJ,GAXJ,EAYE,CAAC,KAAD,EAAQ,KAAR,CAZF;AAcD,CAnBD;;AAqBA,IAAM,IAAI,GAAG,YAAA;AACX;;;;;;;;AAQG;AACJ,CAVD;AAYA;;;AACA,IAAM,UAAU,GAAG,UAAC,KAAD,EAAgB,EAAhB,EAA4D;MAA1C,GAAG,GAAA,EAAA,CAAA,G;MAAE,GAAG,GAAA,EAAA,CAAA,G;;AAC3C,MAAI,OAAO,GAAP,KAAe,QAAnB,EAA6B;AAC3B,IAAA,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,EAAgB,GAAhB,CAAR;AACD;;AACD,MAAI,OAAO,GAAP,KAAe,QAAnB,EAA6B;AAC3B,IAAA,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,EAAgB,GAAhB,CAAR;AACD;;AACD,SAAO,KAAP;AACD,CARD;;AAUA,OAAO,IAAM,cAAc,GAA8C,KAAK,CAAC,UAAN,CAGvE,UAAC,oBAAD,EAAuB,GAAvB,EAA0B;AAC1B,MAAM,KAAK,GAAG,oBAAoB,CAAC,aAAD,EAAgB,oBAAhB,CAAlC;AAEE,MAAA,QAAQ,GA+BN,KAAK,CA/BC,QAAR;AAAA,MACA,KAAK,GA8BH,KAAK,CA9BF,KADL;AAAA,MAEA,GAAG,GA6BD,KAAK,CA7BJ,GAFH;AAAA,MAGA,GAAG,GA4BD,KAAK,CA5BJ,GAHH;AAAA,MAIA,IAAI,GA2BF,KAAK,CA3BH,IAJJ;AAAA,MAKA,YAAY,GA0BV,KAAK,CA1BK,YALZ;AAAA,MAMO,cAAc,GAyBnB,KAAK,CAzBc,KANrB;AAAA,MAOW,kBAAkB,GAwB3B,KAAK,CAxBsB,SAP7B;AAAA,MAQA,aAAa,GAuBX,KAAK,CAvBM,aARb;AAAA,MASA,SAAS,GAsBP,KAAK,CAtBE,SATT;AAAA,MAUA,mBAAmB,GAqBjB,KAAK,CArBY,mBAVnB;AAAA,MAWA,wBAAwB,GAoBtB,KAAK,CApBiB,wBAXxB;AAAA,MAYA,mBAAmB,GAmBjB,KAAK,CAnBY,mBAZnB;AAAA,MAaA,wBAAwB,GAkBtB,KAAK,CAlBiB,wBAbxB;AAAA,MAcA,SAAS,GAiBP,KAAK,CAjBE,SAdT;AAAA,MAeA,eAAe,GAgBb,KAAK,CAhBQ,eAff;AAAA,MAgBqB,yBAAyB,GAe5C,KAAK,CAfuC,mBAhB9C;AAAA,MAiBuB,2BAA2B,GAchD,KAAK,CAd2C,qBAjBlD;AAAA,MAkBA,KAAK,GAaH,KAAK,CAbF,KAlBL;AAAA,MAmBA,iBAAiB,GAYf,KAAK,CAZU,iBAnBjB;AAAA,MAoBA,WAAW,GAWT,KAAK,CAXI,WApBX;AAAA,MAqBA,YAAY,GAUV,KAAK,CAVK,YArBZ;AAAA,MAsBA,aAAa,GASX,KAAK,CATM,aAtBb;AAAA,MAuBA,SAAS,GAQP,KAAK,CARE,SAvBT;AAAA,MAwBA,UAAU,GAOR,KAAK,CAPG,UAxBV;AAAA,MAyBA,WAAW,GAMT,KAAK,CANI,WAzBX;AAAA,MA0BA,WAAW,GAKT,KAAK,CALI,WA1BX;AAAA,MA2BA,eAAe,GAIb,KAAK,CAJQ,eA3Bf;AAAA,MA4BA,UAAU,GAGR,KAAK,CAHG,UA5BV;AAAA,MA6BA,QAAQ,GAEN,KAAK,CAFC,QA7BR;AAAA,MA8BA,MAAM,GACJ,KAAK,CADD,MA9BN;AAiCF,MAAM,KAAK,GAAG,KAAK,CAAC,MAAN,CAA+B,IAA/B,CAAd;AACA,MAAM,OAAO,GAAG,KAAK,CAAC,OAAD,CAArB;AACA,MAAM,OAAO,GAAG,KAAK,CAAC,OAAD,CAArB;;AAEM,MAAA,EAAA,GAA4B,KAAK,CAAC,QAAN,CAAe,KAAf,CAA5B;AAAA,MAAC,SAAS,GAAA,EAAA,CAAA,CAAA,CAAV;AAAA,MAAY,YAAY,GAAA,EAAA,CAAA,CAAA,CAAxB;;AACA,MAAA,EAAA,GAAoD,KAAK,CAAC,QAAN,CAAe,qBAAqB,CAAC,WAArC,CAApD;AAAA,MAAC,qBAAqB,GAAA,EAAA,CAAA,CAAA,CAAtB;AAAA,MAAwB,wBAAwB,GAAA,EAAA,CAAA,CAAA,CAAhD;;AACN,MAAM,KAAK,GAAG,QAAQ,EAAtB;AAEA,MAAM,SAAS,GAAG,KAAK,CAAC,OAAN,CAAc,YAAA;AAC9B,WAAO,kBAAkB,KAAA,IAAlB,IAAA,kBAAkB,KAAA,KAAA,CAAlB,GAAA,kBAAA,GAAsB,IAAI,CAAC,GAAL,CAAS,kBAAkB,CAAC,IAAD,CAA3B,EAAmC,CAAnC,CAA7B;AACD,GAFiB,EAEf,CAAC,kBAAD,EAAqB,IAArB,CAFe,CAAlB;AAIA;;;;;AAKG;;AACG,MAAA,EAAA,GAAoB,oBAAoB,CAAC,cAAD,EAAiB,YAAY,KAAA,IAAZ,IAAA,YAAY,KAAA,KAAA,CAAZ,GAAA,YAAA,GAAgB,MAAM,CAAC,GAAG,IAAI,CAAR,CAAvC,EAAmD,QAAnD,CAAxC;AAAA,MAAC,KAAK,GAAA,EAAA,CAAA,CAAA,CAAN;AAAA,MAAQ,QAAQ,GAAA,EAAA,CAAA,CAAA,CAAhB;AACN;;;;AAIG;;;AACG,MAAA,EAAA,GAA4C,KAAK,CAAC,QAAN,EAA5C;AAAA,MAAC,iBAAiB,GAAA,EAAA,CAAA,CAAA,CAAlB;AAAA,MAAoB,oBAAoB,GAAA,EAAA,CAAA,CAAA,CAAxC;;AAEE,MAAS,aAAa,GAAK,KAAK,CAAC,MAAN,CAAuC;AACxE,IAAA,iBAAiB,EAAE,CAAC,CADoD;AAExE,IAAA,WAAW,EAAE,SAF2D;AAGxE,IAAA,uBAAuB,EAAE;AAH+C,GAAvC,EAAL,OAAtB,CA9DkB,CAmE1B;AACA;;AACA,EAAA,aAAa,CAAC,WAAd,GAA4B,KAA5B;AACA,EAAA,aAAa,CAAC,uBAAd,GAAwC,iBAAxC;AAEA,MAAM,sBAAsB,GAAG,WAAW,CAAC,cAAD,CAA1C;AACA,EAAA,KAAK,CAAC,SAAN,CAAgB,YAAA;AACd;AACA,QAAI,cAAc,KAAK,sBAAnB,IAA6C,iBAAiB,KAAK,SAAvE,EAAkF;AAChF,MAAA,oBAAoB,CAAC,SAAD,CAApB;AACD;AACF,GALD,EAKG,CAAC,cAAD,EAAiB,sBAAjB,EAAyC,iBAAzC,CALH;AAOA,MAAM,UAAU,GAAG,aAAa,CAAC,MAAD,EAAS;AACvC,IAAA,KAAK,EAAE,KADgC;AAEvC,IAAA,QAAQ,EAAA,QAF+B;AAGvC,IAAA,SAAS,EAAA,SAH8B;AAIvC,IAAA,qBAAqB,EAAA,qBAJkB;AAKvC,IAAA,aAAa,EAAA,aAL0B;AAMvC,IAAA,SAAS,EAAA;AAN8B,GAAT,CAAhC;AASA,MAAM,WAAW,GAAG,cAAc,CAAuC,KAAvC,EAA8C,aAA9C,EAA6D,CAC7F,QAD6F,EAE7F,SAF6F,EAG7F,WAH6F,EAI7F,UAJ6F,CAA7D,CAAlC;AAOA;;AACA,MAAM,QAAQ,GAAG,KAAK,CAAC,WAAN,CACf,UAAC,EAAD,EAAsC;AACpC;AACA,QAAM,YAAY,GAAG,aAAa,CAAC,uBAAnC;;AACA,QAAI,YAAY,KAAK,SAAjB,IAA8B,YAAY,KAAK,aAAa,CAAC,WAAjE,EAA8E;AAC5E,UAAI,QAAQ,GAAA,KAAA,CAAZ;;AACA,UAAI,UAAJ,EAAgB;AACd,QAAA,QAAQ,GAAG,UAAU,CAAC,YAAD,EAAe,EAAf,CAArB;AACD,OAFD,MAEO,IAAI,YAAY,IAAI,YAAY,CAAC,IAAb,GAAoB,MAApC,IAA8C,CAAC,KAAK,CAAC,MAAM,CAAC,YAAD,CAAP,CAAxD,EAAgF;AACrF;AACA,QAAA,QAAQ,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,YAAD,CAAP,EAAuB;AAAE,UAAA,GAAG,EAAA,GAAL;AAAO,UAAA,GAAG,EAAA;AAAV,SAAvB,CAAX,CAAjB;AACD;;AACD,UAAI,QAAQ,KAAK,SAAb,IAA0B,QAAQ,KAAK,aAAa,CAAC,WAAzD,EAAsE;AACpE;AACA,QAAA,QAAQ,CAAC,QAAD,EAAW,EAAX,CAAR;AACD;AACF,KAfmC,CAiBpC;;;AACA,IAAA,oBAAoB,CAAC,SAAD,CAApB;AACD,GApBc,EAqBf,CAAC,aAAD,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,UAA1B,EAAsC,QAAtC,CArBe,CAAjB;AAwBA;;AAEG;;AACH,MAAM,IAAI,GAAG,KAAK,CAAC,WAAN,CAAkB,YAAA;AAC7B,QAAI,aAAa,CAAC,iBAAd,IAAmC,CAAvC,EAA0C;AACxC,MAAA,KAAK,CAAC,YAAN,CAAmB,aAAa,CAAC,iBAAjC;AACA,MAAA,aAAa,CAAC,iBAAd,GAAkC,CAAC,CAAnC;AACD;;AACD,QAAI,aAAa,CAAC,eAAd,IAAiC,qBAAqB,KAAK,qBAAqB,CAAC,WAArF,EAAkG;AAChG,MAAA,aAAa,CAAC,eAAd,GAAgC,KAAhC;AACA,MAAA,wBAAwB,CAAC,qBAAqB,CAAC,WAAvB,CAAxB;AACD;AACF,GATY,EASV,CAAC,aAAD,EAAgB,qBAAhB,EAAuC,KAAvC,CATU,CAAb;AAWA;;;;;AAKG;;AACH,MAAM,WAAW,GAAG,KAAK,CAAC,WAAN,CAClB,UACE,YADF,EAEE,EAFF,EAE2E;AAEzE,IAAA,EAAE,CAAC,OAAH;;AAEA,QAAI,aAAa,CAAC,uBAAd,KAA0C,SAA9C,EAAyD;AACvD;AACA;AACA;AACA,UAAI,EAAE,CAAC,IAAH,KAAY,SAAhB,EAA2B;AACzB;AACA;AACA;AACA,QAAA,QAAQ,CAAC,EAAD,CAAR;AACD;;AACD,MAAA,KAAK,CAAC,qBAAN,CAA4B,YAAA;AAC1B;AACA,QAAA,WAAW,CAAC,YAAD,EAAe,EAAf,CAAX;AACD,OAHD;AAIA;AACD,KAnBwE,CAqBzE;AACA;AACA;AACA;AACA;;;AACA,QAAM,QAAQ,GAAG,YAAY,CAAC,aAAa,CAAC,WAAd,IAA6B,EAA9B,EAAkC,EAAlC,CAA7B;;AACA,QAAI,QAAQ,KAAK,SAAb,IAA0B,QAAQ,KAAK,aAAa,CAAC,WAAzD,EAAsE;AACpE,MAAA,QAAQ,CAAC,QAAD,EAAW,EAAX,CAAR;AACD,KA7BwE,CA+BzE;AACA;;;AACA,QAAM,WAAW,GAAG,aAAa,CAAC,eAAlC;AACA,IAAA,aAAa,CAAC,eAAd,GAAgC,EAAE,CAAC,IAAH,KAAY,WAA5C;;AACA,QAAI,aAAa,CAAC,eAAlB,EAAmC;AACjC,MAAA,aAAa,CAAC,iBAAd,GAAkC,KAAK,CAAC,UAAN,CAChC,YAAA;AACE,QAAA,WAAW,CAAC,YAAD,EAAe,EAAf,CAAX;AACD,OAH+B,EAIhC,WAAW,GAAG,UAAH,GAAgB,kBAJK,CAAlC;AAMD;AACF,GA9CiB,EA+ClB,CAAC,aAAD,EAAgB,KAAhB,EAAuB,QAAvB,EAAiC,QAAjC,CA/CkB,CAApB;AAkDA;;AACA,MAAM,eAAe,GAAG,KAAK,CAAC,WAAN,CACtB,UAAC,QAAD,EAAiB;AACf,QAAI,WAAJ,EAAiB;AACf,aAAO,WAAW,CAAC,QAAD,CAAlB;AACD,KAFD,MAEO;AACL,UAAI,YAAY,GAAG,UAAU,CAAC,MAAM,CAAC,QAAD,CAAN,GAAmB,MAAM,CAAC,IAAD,CAA1B,EAAkC;AAAE,QAAA,GAAG,EAAA;AAAL,OAAlC,CAA7B;AACA,MAAA,YAAY,GAAG,cAAc,CAAC,YAAD,EAAe,SAAf,CAA7B;AACA,aAAO,MAAM,CAAC,YAAD,CAAb;AACD;AACF,GATqB,EAUtB,CAAC,SAAD,EAAY,GAAZ,EAAiB,WAAjB,EAA8B,IAA9B,CAVsB,CAAxB;AAaA;;AACA,MAAM,eAAe,GAAG,KAAK,CAAC,WAAN,CACtB,UAAC,QAAD,EAAiB;AACf,QAAI,WAAJ,EAAiB;AACf,aAAO,WAAW,CAAC,QAAD,CAAlB;AACD,KAFD,MAEO;AACL,UAAI,YAAY,GAAG,UAAU,CAAC,MAAM,CAAC,QAAD,CAAN,GAAmB,MAAM,CAAC,IAAD,CAA1B,EAAkC;AAAE,QAAA,GAAG,EAAA;AAAL,OAAlC,CAA7B;AACA,MAAA,YAAY,GAAG,cAAc,CAAC,YAAD,EAAe,SAAf,CAA7B;AACA,aAAO,MAAM,CAAC,YAAD,CAAb;AACD;AACF,GATqB,EAUtB,CAAC,SAAD,EAAY,GAAZ,EAAiB,WAAjB,EAA8B,IAA9B,CAVsB,CAAxB;AAaA;;AACA,MAAM,iBAAiB,GAAG,UAAC,EAAD,EAAsC;AAC9D,IAAA,oBAAoB,CAAE,EAAE,CAAC,MAAH,CAA+B,KAAjC,CAApB;AACD,GAFD;AAIA;;;AACA,MAAM,WAAW,GAAG,UAAC,EAAD,EAAuC;WAAA,CACzD;;;AACA,QAAI,CAAC,KAAK,CAAC,OAAX,EAAoB;AAClB;AACD;;AACD,QAAI,aAAa,CAAC,eAAd,IAAiC,qBAAqB,KAAK,qBAAqB,CAAC,WAArF,EAAkG;AAChG,MAAA,IAAI;AACL;;AACD,IAAA,KAAK,CAAC,OAAN,CAAc,MAAd;AACA,IAAA,YAAY,CAAC,IAAD,CAAZ;AACA,KAAA,EAAA,GAAA,KAAK,CAAC,OAAN,MAAa,IAAb,IAAa,EAAA,KAAA,KAAA,CAAb,GAAa,KAAA,CAAb,GAAa,EAAA,CAAA,IAAA,CAAb,KAAa,EAAG,EAAH,CAAb;AACD,GAXD;AAaA;;;AACA,MAAM,UAAU,GAAG,UAAC,EAAD,EAAuC;;;AACxD,IAAA,QAAQ,CAAC,EAAD,CAAR;AACA,IAAA,YAAY,CAAC,KAAD,CAAZ;AACA,KAAA,EAAA,GAAA,KAAK,CAAC,MAAN,MAAY,IAAZ,IAAY,EAAA,KAAA,KAAA,CAAZ,GAAY,KAAA,CAAZ,GAAY,EAAA,CAAA,IAAA,CAAZ,KAAY,EAAG,EAAH,CAAZ;AACD,GAJD;AAMA;;;AACA,MAAM,aAAa,GAAG,UAAC,EAAD,EAA0C;AAC9D;AACA;AACA;AACA,QAAI,EAAE,CAAC,KAAH,KAAa,QAAQ,CAAC,EAAtB,IAA4B,EAAE,CAAC,KAAH,KAAa,QAAQ,CAAC,IAAlD,IAA0D,EAAE,CAAC,KAAH,KAAa,QAAQ,CAAC,KAApF,EAA2F;AACzF,MAAA,EAAE,CAAC,cAAH;AACA,MAAA,EAAE,CAAC,eAAH;AACD;;AACD,QAAI,QAAJ,EAAc;AACZ,MAAA,IAAI;AACJ;AACD;;AAED,QAAI,aAAa,GAAG,qBAAqB,CAAC,WAA1C,CAb8D,CAe9D;;AACA,YAAQ,EAAE,CAAC,KAAX;AACE,WAAK,QAAQ,CAAC,EAAd;AACE,QAAA,aAAa,GAAG,qBAAqB,CAAC,EAAtC;AACA,QAAA,WAAW,CAAC,eAAD,EAAkB,EAAlB,CAAX;AACA;;AACF,WAAK,QAAQ,CAAC,IAAd;AACE,QAAA,aAAa,GAAG,qBAAqB,CAAC,IAAtC;AACA,QAAA,WAAW,CAAC,eAAD,EAAkB,EAAlB,CAAX;AACA;;AACF,WAAK,QAAQ,CAAC,KAAd;AACE;AACA,QAAA,QAAQ,CAAC,EAAD,CAAR;AACA;;AACF,WAAK,QAAQ,CAAC,MAAd;AACE;AACA,QAAA,oBAAoB,CAAC,SAAD,CAApB;AACA;AAhBJ,KAhB8D,CAkC9D;AACA;;;AACA,QAAI,qBAAqB,KAAK,aAA9B,EAA6C;AAC3C,MAAA,wBAAwB,CAAC,aAAD,CAAxB;AACD;AACF,GAvCD;AAyCA;;;AACA,MAAM,WAAW,GAAG,KAAK,CAAC,WAAN,CAClB,UAAC,EAAD,EAAqC;AACnC;AACA,QAAI,QAAQ,IAAI,EAAE,CAAC,KAAH,KAAa,QAAQ,CAAC,EAAlC,IAAwC,EAAE,CAAC,KAAH,KAAa,QAAQ,CAAC,IAAlE,EAAwE;AACtE,MAAA,IAAI;AACJ;AACD;AACF,GAPiB,EAQlB,CAAC,QAAD,EAAW,IAAX,CARkB,CAApB;AAWA,MAAM,wBAAwB,GAAG,KAAK,CAAC,WAAN,CAC/B,UAAC,EAAD,EAAkC;AAChC,IAAA,WAAW,CAAC,eAAD,EAAkB,EAAlB,CAAX;AACD,GAH8B,EAI/B,CAAC,eAAD,EAAkB,WAAlB,CAJ+B,CAAjC;AAOA,MAAM,wBAAwB,GAAG,KAAK,CAAC,WAAN,CAC/B,UAAC,EAAD,EAAkC;AAChC,IAAA,WAAW,CAAC,eAAD,EAAkB,EAAlB,CAAX;AACD,GAH8B,EAI/B,CAAC,eAAD,EAAkB,WAAlB,CAJ+B,CAAjC;AAOA,EAAA,eAAe,CAAC,KAAD,EAAQ,KAAR,EAAe,KAAf,CAAf;AACA,EAAA,gBAAgB,CAAC,KAAD,CAAhB;AAEA,MAAM,aAAa,GAAG,CAAC,CAAC,KAAF,IAAW,CAAC,KAAK,CAAC,MAAM,CAAC,KAAD,CAAP,CAAvC,CA5T0B,CA4T8B;;AAExD,MAAM,YAAY,GAAG,CAAC,SAAS,IAAI,KAAd,KACnB,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AAAK,IAAA,SAAS,EAAE,UAAU,CAAC;AAA3B,GAAA,EACG,SAAS,IAAI,KAAA,CAAA,aAAA,CAAC,IAAD,EAAK,QAAA,CAAA,EAAA,EAAK,SAAL,EAAc;AAAE,IAAA,SAAS,EAAE,UAAU,CAAC,IAAxB;AAA4B,mBAAc;AAA1C,GAAd,CAAL,CADhB,EAEG,KAAK,IACJ,KAAA,CAAA,aAAA,CAAC,KAAD,EAAM;AAAC,IAAA,EAAE,EAAE,OAAL;AAAc,IAAA,OAAO,EAAE,OAAvB;AAAgC,IAAA,SAAS,EAAE,UAAU,CAAC,KAAtD;AAA6D,IAAA,QAAQ,EAAE;AAAvE,GAAN,EACG,KADH,CAHJ,CADF;AAWA,SACE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AAAK,IAAA,SAAS,EAAE,UAAU,CAAC,IAA3B;AAAiC,IAAA,GAAG,EAAE;AAAtC,GAAA,EACG,aAAa,KAAK,QAAQ,CAAC,MAA3B,IAAqC,YADxC,EAEE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA,QAAA,CAAA,EAAA,EACM,WADN,EACiB;AACf,IAAA,SAAS,EAAE,UAAU,CAAC,iBADP;AACwB,kBAC3B,SAAS,IAAI,SAFV;AAEmB,qBACnB,iBAHA;AAGiB,oBAClB,WAJC;AAIU,uBACR;AALF,GADjB,CAAA,EAQE,KAAA,CAAA,aAAA,CAAA,OAAA,EAAA,QAAA,CAAA;AACE;AACA,IAAA,KAAK,EAAE,iBAAiB,KAAA,IAAjB,IAAA,iBAAiB,KAAA,KAAA,CAAjB,GAAA,iBAAA,GAAqB,KAF9B;AAGE,IAAA,EAAE,EAAE,OAHN;AAIE,IAAA,QAAQ,EAAE,IAJZ;AAKE,IAAA,OAAO,EAAE,iBALX;AAME,IAAA,SAAS,EAAE,UAAU,CAAC,KANxB;AAOE,IAAA,IAAI,EAAC,MAPP;AAQE,IAAA,YAAY,EAAC,KARf;AASE,IAAA,IAAI,EAAC,YATP;AASmB,uBACA,KAAK,IAAI,OAV5B;AAUmC,qBAElB,YAAY,KAAA,IAAZ,IAAA,YAAY,KAAA,KAAA,CAAZ,GAAA,YAAA,GAAiB,aAAa,GAAG,MAAM,CAAC,KAAD,CAAT,GAAmB,SAZlE;AAY4E,sBAC1D,aAAa,KAAA,IAAb,IAAA,aAAa,KAAA,KAAA,CAAb,GAAA,aAAA,GAAkB,aAAa,GAAG,SAAH,GAAe,KAbhE;AAasE,qBACrD,GAdjB;AAcoB,qBACH,GAfjB;AAeoB,wBACA,eAhBpB;AAiBE,IAAA,MAAM,EAAE,UAjBV;AAkBE,IAAA,GAAG,EAAE,KAlBP;AAmBE,IAAA,OAAO,EAAE,WAnBX;AAoBE,IAAA,SAAS,EAAE,aApBb;AAqBE,IAAA,OAAO,EAAE,WArBX;AAsBE,IAAA,QAAQ,EAAE,QAtBZ;AAsBoB,qBACH,QAvBjB;AAuByB,qBAAA,IAvBzB;AAuByB,+BAEE;AAzB3B,GAAA,EA0BM,UA1BN,CAAA,CARF,EAoCE,KAAA,CAAA,aAAA,CAAA,MAAA,EAAA;AAAM,IAAA,SAAS,EAAE,UAAU,CAAC;AAA5B,GAAA,EACE,KAAA,CAAA,aAAA,CAAC,UAAD,EAAW,QAAA,CAAA;AACT,IAAA,MAAM,EAAE,oBAAoB,CAAC,KAAD,EAAS,IAAT,EAAe,yBAAf,CADnB;AAET,IAAA,SAAS,EAAE,aAFF;AAGT,IAAA,OAAO,EAAE,qBAAqB,KAAK,qBAAqB,CAAC,EAHhD;AAIT,IAAA,QAAQ,EAAE,QAJD;AAKT,IAAA,SAAS,EAAE,mBALF;AAMT,IAAA,WAAW,EAAE,wBANJ;AAOT,IAAA,YAAY,EAAE,IAPL;AAQT,IAAA,SAAS,EAAE,IARF;AAST,IAAA,QAAQ,EAAE,CAAC,CATF;AAUT,IAAA,SAAS,EAAE,wBAVF;AAU0B,yBAChB;AAXV,GAAA,EAYL,eAZK,CAAX,CADF,EAeE,KAAA,CAAA,aAAA,CAAC,UAAD,EAAW,QAAA,CAAA;AACT,IAAA,MAAM,EAAE,oBAAoB,CAAC,KAAD,EAAS,KAAT,EAAgB,2BAAhB,CADnB;AAET,IAAA,SAAS,EAAE,eAFF;AAGT,IAAA,OAAO,EAAE,qBAAqB,KAAK,qBAAqB,CAAC,IAHhD;AAIT,IAAA,QAAQ,EAAE,QAJD;AAKT,IAAA,SAAS,EAAE,mBALF;AAMT,IAAA,WAAW,EAAE,wBANJ;AAOT,IAAA,YAAY,EAAE,IAPL;AAQT,IAAA,SAAS,EAAE,IARF;AAST,IAAA,QAAQ,EAAE,CAAC,CATF;AAUT,IAAA,SAAS,EAAE,wBAVF;AAU0B,yBAChB;AAXV,GAAA,EAYL,eAZK,CAAX,CAfF,CApCF,CAFF,EAqEG,aAAa,KAAK,QAAQ,CAAC,MAA3B,IAAqC,YArExC,CADF;AAyED,CArZwE,CAAlE;AAsZP,cAAc,CAAC,WAAf,GAA6B,cAA7B;;AAEA,IAAM,gBAAgB,GAAG,UAAC,KAAD,EAAwB;AAC/C,MAAI,OAAO,CAAC,GAAR,CAAY,QAAZ,KAAyB,YAA7B,EAA2C;AACzC;AACA,IAAA,WAAW,CAAC;AACV,MAAA,IAAI,EAAE,cADI;AAEV,MAAA,KAAK,EAAA,KAFK;AAGV,MAAA,iBAAiB,EAAE;AAAE,QAAA,KAAK,EAAE;AAAT;AAHT,KAAD,CAAX;AAKD;AACF,CATD","sourcesContent":["import * as React from 'react';\nimport { IconButton } from '../../Button';\nimport { Label } from '../../Label';\nimport { Icon } from '../../Icon';\nimport {\n  KeyCodes,\n  calculatePrecision,\n  classNamesFunction,\n  precisionRound,\n  getNativeProps,\n  getPropsWithDefaults,\n  divProperties,\n} from '../../Utilities';\nimport { getArrowButtonStyles } from './SpinButton.styles';\nimport { ISpinButtonProps, ISpinButtonStyleProps, ISpinButtonStyles, KeyboardSpinDirection } from './SpinButton.types';\nimport { Position } from '../../Positioning';\nimport { useAsync, useControllableValue, useWarnings, useId, usePrevious } from '@fluentui/react-hooks';\n\ninterface ISpinButtonInternalState {\n  spinningByMouse?: boolean;\n  stepTimeoutHandle: number;\n  /** Allows access to the latest `value` inside reused callbacks (to avoid stale capture issues) */\n  latestValue: string | undefined;\n  /** Allows access to the latest `intermediateValue` inside reused callbacks (to avoid stale capture issues) */\n  latestIntermediateValue: string | undefined;\n}\n\nconst getClassNames = classNamesFunction<ISpinButtonStyleProps, ISpinButtonStyles>();\n\nconst COMPONENT_NAME = 'SpinButton';\nconst DEFAULT_PROPS: Required<\n  Pick<\n    ISpinButtonProps,\n    // These are explicitly specified so that only the things which actually have defaults\n    // get marked as required in ISpinButtonPropsWithDefaults below\n    'disabled' | 'label' | 'step' | 'labelPosition' | 'incrementButtonIcon' | 'decrementButtonIcon'\n  >\n> = {\n  disabled: false,\n  label: '',\n  step: 1,\n  labelPosition: Position.start,\n  incrementButtonIcon: { iconName: 'ChevronUpSmall' },\n  decrementButtonIcon: { iconName: 'ChevronDownSmall' },\n};\ntype ISpinButtonPropsWithDefaults = ISpinButtonProps & typeof DEFAULT_PROPS;\n\nconst INITIAL_STEP_DELAY = 400;\nconst STEP_DELAY = 75;\n\nconst useComponentRef = (\n  props: ISpinButtonProps,\n  input: React.RefObject<HTMLDivElement>,\n  value: string | undefined,\n) => {\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      get value() {\n        return value;\n      },\n      focus() {\n        if (input.current) {\n          input.current.focus();\n        }\n      },\n    }),\n    [input, value],\n  );\n};\n\nconst noOp = (): void => {\n  /**\n   * A noop input change handler. Using onInput instead of onChange was meant to address an issue\n   * which apparently has been resolved in React 16 (https://github.com/facebook/react/issues/7027).\n   * The no-op onChange handler was still needed because React gives console errors if an input\n   * doesn't have onChange.\n   *\n   * TODO (Fabric 8?) - switch to just calling onChange (this is a breaking change for any tests,\n   * ours or 3rd-party, which simulate entering text in a SpinButton)\n   */\n};\n\n/** Clamp the value to the provided min and/or max */\nconst clampValue = (value: number, { min, max }: { max?: number; min?: number }) => {\n  if (typeof max === 'number') {\n    value = Math.min(value, max);\n  }\n  if (typeof min === 'number') {\n    value = Math.max(value, min);\n  }\n  return value;\n};\n\nexport const SpinButtonBase: React.FunctionComponent<ISpinButtonProps> = React.forwardRef<\n  HTMLDivElement,\n  ISpinButtonProps\n>((propsWithoutDefaults, ref) => {\n  const props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults) as ISpinButtonPropsWithDefaults;\n  const {\n    disabled,\n    label,\n    min,\n    max,\n    step,\n    defaultValue,\n    value: valueFromProps,\n    precision: precisionFromProps,\n    labelPosition,\n    iconProps,\n    incrementButtonIcon,\n    incrementButtonAriaLabel,\n    decrementButtonIcon,\n    decrementButtonAriaLabel,\n    ariaLabel,\n    ariaDescribedBy,\n    upArrowButtonStyles: customUpArrowButtonStyles,\n    downArrowButtonStyles: customDownArrowButtonStyles,\n    theme,\n    ariaPositionInSet,\n    ariaSetSize,\n    ariaValueNow,\n    ariaValueText,\n    className,\n    inputProps,\n    onDecrement,\n    onIncrement,\n    iconButtonProps,\n    onValidate,\n    onChange,\n    styles,\n  } = props;\n\n  const input = React.useRef<HTMLInputElement>(null);\n  const inputId = useId('input');\n  const labelId = useId('Label');\n\n  const [isFocused, setIsFocused] = React.useState(false);\n  const [keyboardSpinDirection, setKeyboardSpinDirection] = React.useState(KeyboardSpinDirection.notSpinning);\n  const async = useAsync();\n\n  const precision = React.useMemo(() => {\n    return precisionFromProps ?? Math.max(calculatePrecision(step), 0);\n  }, [precisionFromProps, step]);\n\n  /**\n   * Actual current value. If `props.value` is provided (controlled), it will always be used.\n   * If not (uncontrolled), this tracks the current value based on user modifications.\n   * Note that while the user is editing text in the field, this will not be updated until \"commit\"\n   * (blur or press enter).\n   */\n  const [value, setValue] = useControllableValue(valueFromProps, defaultValue ?? String(min || 0), onChange);\n  /**\n   * \"Uncommitted\" internal value while the user is editing text in the field. This lets us wait to\n   * call `onChange` (and possibly update the real value) until the user \"commits\" the value by\n   * pressing enter or blurring the field.\n   */\n  const [intermediateValue, setIntermediateValue] = React.useState<string>();\n\n  const { current: internalState } = React.useRef<ISpinButtonInternalState>({\n    stepTimeoutHandle: -1,\n    latestValue: undefined,\n    latestIntermediateValue: undefined,\n  });\n  // On each render, update this saved value used by callbacks. (This should be safe even if render\n  // is called multiple times, because an event handler or timeout callback will only run once.)\n  internalState.latestValue = value;\n  internalState.latestIntermediateValue = intermediateValue;\n\n  const previousValueFromProps = usePrevious(valueFromProps);\n  React.useEffect(() => {\n    // If props.value changes while editing, clear the intermediate value\n    if (valueFromProps !== previousValueFromProps && intermediateValue !== undefined) {\n      setIntermediateValue(undefined);\n    }\n  }, [valueFromProps, previousValueFromProps, intermediateValue]);\n\n  const classNames = getClassNames(styles, {\n    theme: theme!,\n    disabled,\n    isFocused,\n    keyboardSpinDirection,\n    labelPosition,\n    className,\n  });\n\n  const nativeProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(props, divProperties, [\n    'onBlur',\n    'onFocus',\n    'className',\n    'onChange',\n  ]);\n\n  /** Validate (commit) function called on blur or enter keypress. */\n  const validate = React.useCallback(\n    (ev: React.SyntheticEvent<HTMLElement>): void => {\n      // Only run validation if the value changed\n      const enteredValue = internalState.latestIntermediateValue;\n      if (enteredValue !== undefined && enteredValue !== internalState.latestValue) {\n        let newValue: string | undefined;\n        if (onValidate) {\n          newValue = onValidate(enteredValue, ev) as string | undefined;\n        } else if (enteredValue && enteredValue.trim().length && !isNaN(Number(enteredValue))) {\n          // default validation handling\n          newValue = String(clampValue(Number(enteredValue), { min, max }));\n        }\n        if (newValue !== undefined && newValue !== internalState.latestValue) {\n          // Commit the value if it changed\n          setValue(newValue, ev);\n        }\n      }\n\n      // Done validating, so clear the intermediate typed value (if any)\n      setIntermediateValue(undefined);\n    },\n    [internalState, max, min, onValidate, setValue],\n  );\n\n  /**\n   * Stop spinning (clear any currently pending update and set spinning to false)\n   */\n  const stop = React.useCallback((): void => {\n    if (internalState.stepTimeoutHandle >= 0) {\n      async.clearTimeout(internalState.stepTimeoutHandle);\n      internalState.stepTimeoutHandle = -1;\n    }\n    if (internalState.spinningByMouse || keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      internalState.spinningByMouse = false;\n      setKeyboardSpinDirection(KeyboardSpinDirection.notSpinning);\n    }\n  }, [internalState, keyboardSpinDirection, async]);\n\n  /**\n   * Update the value with the given stepFunction.\n   * Also starts spinning for mousedown events by scheduling another update with setTimeout.\n   * @param stepFunction - function to use to step by\n   * @param event - The event that triggered the updateValue\n   */\n  const updateValue = React.useCallback(\n    (\n      stepFunction: Required<ISpinButtonProps>['onIncrement'],\n      ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLInputElement>,\n    ): void => {\n      ev.persist();\n\n      if (internalState.latestIntermediateValue !== undefined) {\n        // Edge case: if intermediateValue is set, this means that the user was editing the input\n        // text and then started spinning (either with mouse or keyboard). We need to validate and\n        // call onChange before starting to spin.\n        if (ev.type === 'keydown') {\n          // For the arrow keys, we have to manually trigger validation.\n          // (For the buttons, validation will happen automatically since the input's onBlur will\n          // be triggered after mousedown on the button completes.)\n          validate(ev);\n        }\n        async.requestAnimationFrame(() => {\n          // After handling any value updates, do the spinning update\n          updateValue(stepFunction, ev);\n        });\n        return;\n      }\n\n      // Call the step function and update the value.\n      // (Note: we access the latest value via internalState (not directly) to ensure we don't use\n      // a stale captured value. This is mainly important for spinning by mouse, where we trigger\n      // additional calls to the original updateValue function via setTimeout. It also lets us\n      // avoid useCallback deps on frequently changing values.)\n      const newValue = stepFunction(internalState.latestValue || '', ev) as string | undefined;\n      if (newValue !== undefined && newValue !== internalState.latestValue) {\n        setValue(newValue, ev);\n      }\n\n      // Schedule the next spin if applicable\n      // (will be canceled if there's a mouseup before the timeout runs)\n      const wasSpinning = internalState.spinningByMouse;\n      internalState.spinningByMouse = ev.type === 'mousedown';\n      if (internalState.spinningByMouse) {\n        internalState.stepTimeoutHandle = async.setTimeout(\n          () => {\n            updateValue(stepFunction, ev);\n          },\n          wasSpinning ? STEP_DELAY : INITIAL_STEP_DELAY, // the first step is slower\n        );\n      }\n    },\n    [internalState, async, validate, setValue],\n  );\n\n  /** Composed increment handler (uses `props.onIncrement` or default) */\n  const handleIncrement = React.useCallback(\n    (newValue: string): string | void => {\n      if (onIncrement) {\n        return onIncrement(newValue);\n      } else {\n        let numericValue = clampValue(Number(newValue) + Number(step), { max });\n        numericValue = precisionRound(numericValue, precision);\n        return String(numericValue);\n      }\n    },\n    [precision, max, onIncrement, step],\n  );\n\n  /** Composed decrement handler (uses `props.onDecrement` or default) */\n  const handleDecrement = React.useCallback(\n    (newValue: string): string | void => {\n      if (onDecrement) {\n        return onDecrement(newValue);\n      } else {\n        let numericValue = clampValue(Number(newValue) - Number(step), { min });\n        numericValue = precisionRound(numericValue, precision);\n        return String(numericValue);\n      }\n    },\n    [precision, min, onDecrement, step],\n  );\n\n  /** Handles when the user types in the input */\n  const handleInputChange = (ev: React.FormEvent<HTMLInputElement>): void => {\n    setIntermediateValue((ev.target as HTMLInputElement).value);\n  };\n\n  /** Composed focus handler (does internal stuff and calls `props.onFocus`) */\n  const handleFocus = (ev: React.FocusEvent<HTMLInputElement>): void => {\n    // We can't set focus on a non-existing element\n    if (!input.current) {\n      return;\n    }\n    if (internalState.spinningByMouse || keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      stop();\n    }\n    input.current.select();\n    setIsFocused(true);\n    props.onFocus?.(ev);\n  };\n\n  /** Composed blur handler (does internal stuff and calls `props.onBlur`) */\n  const handleBlur = (ev: React.FocusEvent<HTMLInputElement>): void => {\n    validate(ev);\n    setIsFocused(false);\n    props.onBlur?.(ev);\n  };\n\n  /** Update value when arrow keys are pressed, commit on enter, or revert on escape */\n  const handleKeyDown = (ev: React.KeyboardEvent<HTMLInputElement>): void => {\n    // eat the up and down arrow keys to keep focus in the spinButton\n    // (especially when a spinButton is inside of a FocusZone)\n    // eslint-disable-next-line deprecation/deprecation\n    if (ev.which === KeyCodes.up || ev.which === KeyCodes.down || ev.which === KeyCodes.enter) {\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n    if (disabled) {\n      stop();\n      return;\n    }\n\n    let spinDirection = KeyboardSpinDirection.notSpinning;\n\n    // eslint-disable-next-line deprecation/deprecation\n    switch (ev.which) {\n      case KeyCodes.up:\n        spinDirection = KeyboardSpinDirection.up;\n        updateValue(handleIncrement, ev);\n        break;\n      case KeyCodes.down:\n        spinDirection = KeyboardSpinDirection.down;\n        updateValue(handleDecrement, ev);\n        break;\n      case KeyCodes.enter:\n        // Commit the edited value\n        validate(ev);\n        break;\n      case KeyCodes.escape:\n        // Revert to previous value\n        setIntermediateValue(undefined);\n        break;\n    }\n    // style the increment/decrement button to look active\n    // when the corresponding up/down arrow keys trigger a step\n    if (keyboardSpinDirection !== spinDirection) {\n      setKeyboardSpinDirection(spinDirection);\n    }\n  };\n\n  /** Stop spinning on keyUp if the up or down arrow key fired this event */\n  const handleKeyUp = React.useCallback(\n    (ev: React.KeyboardEvent<HTMLElement>): void => {\n      // eslint-disable-next-line deprecation/deprecation\n      if (disabled || ev.which === KeyCodes.up || ev.which === KeyCodes.down) {\n        stop();\n        return;\n      }\n    },\n    [disabled, stop],\n  );\n\n  const handleIncrementMouseDown = React.useCallback(\n    (ev: React.MouseEvent<HTMLElement>): void => {\n      updateValue(handleIncrement, ev);\n    },\n    [handleIncrement, updateValue],\n  );\n\n  const handleDecrementMouseDown = React.useCallback(\n    (ev: React.MouseEvent<HTMLElement>): void => {\n      updateValue(handleDecrement, ev);\n    },\n    [handleDecrement, updateValue],\n  );\n\n  useComponentRef(props, input, value);\n  useDebugWarnings(props);\n\n  const valueIsNumber = !!value && !isNaN(Number(value)); // Number('') is 0 which may not be desirable\n\n  const labelContent = (iconProps || label) && (\n    <div className={classNames.labelWrapper}>\n      {iconProps && <Icon {...iconProps} className={classNames.icon} aria-hidden=\"true\" />}\n      {label && (\n        <Label id={labelId} htmlFor={inputId} className={classNames.label} disabled={disabled}>\n          {label}\n        </Label>\n      )}\n    </div>\n  );\n\n  return (\n    <div className={classNames.root} ref={ref}>\n      {labelPosition !== Position.bottom && labelContent}\n      <div\n        {...nativeProps}\n        className={classNames.spinButtonWrapper}\n        aria-label={ariaLabel && ariaLabel}\n        aria-posinset={ariaPositionInSet}\n        aria-setsize={ariaSetSize}\n        data-ktp-target={true}\n      >\n        <input\n          // Display intermediateValue while editing the text (before commit)\n          value={intermediateValue ?? value}\n          id={inputId}\n          onChange={noOp}\n          onInput={handleInputChange}\n          className={classNames.input}\n          type=\"text\"\n          autoComplete=\"off\"\n          role=\"spinbutton\"\n          aria-labelledby={label && labelId}\n          // TODO: test what happens while editing\n          aria-valuenow={ariaValueNow ?? (valueIsNumber ? Number(value) : undefined)}\n          aria-valuetext={ariaValueText ?? (valueIsNumber ? undefined : value)}\n          aria-valuemin={min}\n          aria-valuemax={max}\n          aria-describedby={ariaDescribedBy}\n          onBlur={handleBlur}\n          ref={input}\n          onFocus={handleFocus}\n          onKeyDown={handleKeyDown}\n          onKeyUp={handleKeyUp}\n          disabled={disabled}\n          aria-disabled={disabled}\n          data-lpignore\n          data-ktp-execute-target={true}\n          {...inputProps}\n        />\n        <span className={classNames.arrowButtonsContainer}>\n          <IconButton\n            styles={getArrowButtonStyles(theme!, true, customUpArrowButtonStyles)}\n            className={'ms-UpButton'}\n            checked={keyboardSpinDirection === KeyboardSpinDirection.up}\n            disabled={disabled}\n            iconProps={incrementButtonIcon}\n            onMouseDown={handleIncrementMouseDown}\n            onMouseLeave={stop}\n            onMouseUp={stop}\n            tabIndex={-1}\n            ariaLabel={incrementButtonAriaLabel}\n            data-is-focusable={false}\n            {...iconButtonProps}\n          />\n          <IconButton\n            styles={getArrowButtonStyles(theme!, false, customDownArrowButtonStyles)}\n            className={'ms-DownButton'}\n            checked={keyboardSpinDirection === KeyboardSpinDirection.down}\n            disabled={disabled}\n            iconProps={decrementButtonIcon}\n            onMouseDown={handleDecrementMouseDown}\n            onMouseLeave={stop}\n            onMouseUp={stop}\n            tabIndex={-1}\n            ariaLabel={decrementButtonAriaLabel}\n            data-is-focusable={false}\n            {...iconButtonProps}\n          />\n        </span>\n      </div>\n      {labelPosition === Position.bottom && labelContent}\n    </div>\n  );\n});\nSpinButtonBase.displayName = COMPONENT_NAME;\n\nconst useDebugWarnings = (props: ISpinButtonProps) => {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props,\n      mutuallyExclusive: { value: 'defaultValue' },\n    });\n  }\n};\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}