{"ast":null,"code":"import { __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, classNamesFunction } from '../../Utilities';\nimport { initializeComponentRef } from '@fluentui/utilities';\nvar getClassNames = classNamesFunction();\nvar TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD = 5;\n/**\n * {@docCategory DocumentCard}\n */\n\nvar DocumentCardTitleBase =\n/** @class */\nfunction (_super) {\n  __extends(DocumentCardTitleBase, _super);\n\n  function DocumentCardTitleBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._titleElement = React.createRef(); // Truncate logic here way can't handle the case that chars with different widths are mixed very well.\n    // Let _shrinkTitle take care of that.\n\n    _this._truncateTitle = function () {\n      if (!_this._needMeasurement) {\n        return;\n      }\n\n      _this._async.requestAnimationFrame(_this._truncateWhenInAnimation);\n    };\n\n    _this._truncateWhenInAnimation = function () {\n      var originalTitle = _this.props.title;\n      var element = _this._titleElement.current;\n\n      if (element) {\n        var style = getComputedStyle(element);\n\n        if (style.width && style.lineHeight && style.height) {\n          var clientWidth = element.clientWidth,\n              scrollWidth = element.scrollWidth;\n          _this._clientWidth = clientWidth;\n          var lines = Math.floor((parseInt(style.height, 10) + TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD) / parseInt(style.lineHeight, 10));\n          element.style.whiteSpace = ''; // Use overflow to predict truncated length.\n          // Take an example.The text is: A text with A very long text that need to be truncated.ppt\n          // if container is like\n          // |A text with A very| long text that need to be truncated.ppt\n          // The scroll width is 58, (take two | out of length)\n          // The client width is 18\n          // the overflow rate is scrollWidth/clientWidth which should be close to length(overflowText)/length(visualText)\n          // And the length of remaining text should be truncated is (original Length)/(58/18) -3 = 15.\n          // So that the logic can predict truncated text well.\n          // first piece will be `A text `, * second piece will be `ated.ppt`\n          // |A text ...ated.ppt|\n\n          var overFlowRate = scrollWidth / (parseInt(style.width, 10) * lines);\n\n          if (overFlowRate > 1) {\n            var truncatedLength = originalTitle.length / overFlowRate - 3;\n            /** Saved for separator */\n\n            return _this.setState({\n              truncatedTitleFirstPiece: originalTitle.slice(0, truncatedLength / 2),\n              truncatedTitleSecondPiece: originalTitle.slice(originalTitle.length - truncatedLength / 2)\n            });\n          }\n        }\n      }\n    };\n\n    _this._shrinkTitle = function () {\n      var _a = _this.state,\n          truncatedTitleFirstPiece = _a.truncatedTitleFirstPiece,\n          truncatedTitleSecondPiece = _a.truncatedTitleSecondPiece;\n\n      if (truncatedTitleFirstPiece && truncatedTitleSecondPiece) {\n        var titleElement = _this._titleElement.current;\n\n        if (!titleElement) {\n          return;\n        }\n\n        if (titleElement.scrollHeight > titleElement.clientHeight + TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD || titleElement.scrollWidth > titleElement.clientWidth) {\n          _this.setState({\n            truncatedTitleFirstPiece: truncatedTitleFirstPiece.slice(0, truncatedTitleFirstPiece.length - 1),\n            truncatedTitleSecondPiece: truncatedTitleSecondPiece.slice(1)\n          });\n        }\n      }\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    _this._clientWidth = undefined;\n    _this.state = {\n      truncatedTitleFirstPiece: undefined,\n      truncatedTitleSecondPiece: undefined\n    };\n    return _this;\n  }\n\n  DocumentCardTitleBase.prototype.componentDidUpdate = function (prevProps) {\n    var _this = this;\n\n    if (this.props.title !== prevProps.title) {\n      this.setState({\n        truncatedTitleFirstPiece: undefined,\n        truncatedTitleSecondPiece: undefined\n      });\n    }\n\n    if (prevProps.shouldTruncate !== this.props.shouldTruncate) {\n      if (this.props.shouldTruncate) {\n        this._truncateTitle();\n\n        this._async.requestAnimationFrame(this._shrinkTitle);\n\n        this._events.on(window, 'resize', this._updateTruncation);\n      } else {\n        this._events.off(window, 'resize', this._updateTruncation);\n      }\n    } else if (this._needMeasurement) {\n      this._async.requestAnimationFrame(function () {\n        _this._truncateWhenInAnimation();\n\n        _this._shrinkTitle();\n      });\n    }\n  };\n\n  DocumentCardTitleBase.prototype.componentDidMount = function () {\n    if (this.props.shouldTruncate) {\n      this._truncateTitle();\n\n      this._events.on(window, 'resize', this._updateTruncation);\n    }\n  };\n\n  DocumentCardTitleBase.prototype.componentWillUnmount = function () {\n    this._events.dispose();\n\n    this._async.dispose();\n  };\n\n  DocumentCardTitleBase.prototype.render = function () {\n    var _a = this.props,\n        title = _a.title,\n        shouldTruncate = _a.shouldTruncate,\n        showAsSecondaryTitle = _a.showAsSecondaryTitle,\n        styles = _a.styles,\n        theme = _a.theme,\n        className = _a.className;\n    var _b = this.state,\n        truncatedTitleFirstPiece = _b.truncatedTitleFirstPiece,\n        truncatedTitleSecondPiece = _b.truncatedTitleSecondPiece;\n    this._classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      showAsSecondaryTitle: showAsSecondaryTitle\n    });\n\n    if (shouldTruncate && truncatedTitleFirstPiece && truncatedTitleSecondPiece) {\n      return React.createElement(\"div\", {\n        className: this._classNames.root,\n        ref: this._titleElement,\n        title: title\n      }, truncatedTitleFirstPiece, \"\\u2026\", truncatedTitleSecondPiece);\n    } else {\n      return React.createElement(\"div\", {\n        className: this._classNames.root,\n        ref: this._titleElement,\n        title: title,\n        style: this._needMeasurement ? {\n          whiteSpace: 'nowrap'\n        } : undefined\n      }, title);\n    }\n  };\n\n  Object.defineProperty(DocumentCardTitleBase.prototype, \"_needMeasurement\", {\n    /**\n     * In measuring, it will render a same style text with whiteSpace: 'nowrap', to get overflow rate.\n     * So that the logic can predict truncated text well.\n     */\n    get: function () {\n      return !!this.props.shouldTruncate && this._clientWidth === undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  DocumentCardTitleBase.prototype._updateTruncation = function () {\n    var _this = this;\n\n    if (this._timerId) {\n      return;\n    }\n\n    this._timerId = this._async.setTimeout(function () {\n      delete _this._timerId;\n      _this._clientWidth = undefined;\n\n      _this.setState({\n        truncatedTitleFirstPiece: undefined,\n        truncatedTitleSecondPiece: undefined\n      });\n    }, 250);\n  };\n\n  return DocumentCardTitleBase;\n}(React.Component);\n\nexport { DocumentCardTitleBase };","map":{"version":3,"sources":["components/DocumentCard/DocumentCardTitle.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\n\nimport { Async, EventGroup, classNamesFunction } from '../../Utilities';\nimport {\n  IDocumentCardTitleProps,\n  IDocumentCardTitleStyleProps,\n  IDocumentCardTitleStyles,\n} from './DocumentCardTitle.types';\nimport { IProcessedStyleSet } from '../../Styling';\nimport { initializeComponentRef } from '@fluentui/utilities';\n\nconst getClassNames = classNamesFunction<IDocumentCardTitleStyleProps, IDocumentCardTitleStyles>();\n\nexport interface IDocumentCardTitleState {\n  truncatedTitleFirstPiece?: string;\n  truncatedTitleSecondPiece?: string;\n}\n\nconst TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD = 5;\n\n/**\n * {@docCategory DocumentCard}\n */\nexport class DocumentCardTitleBase extends React.Component<IDocumentCardTitleProps, IDocumentCardTitleState> {\n  private _titleElement = React.createRef<HTMLDivElement>();\n  private _classNames: IProcessedStyleSet<IDocumentCardTitleStyles>;\n  private _async: Async;\n  private _events: EventGroup;\n  private _clientWidth: number | undefined;\n  private _timerId: number | undefined;\n\n  constructor(props: IDocumentCardTitleProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n    this._clientWidth = undefined;\n\n    this.state = {\n      truncatedTitleFirstPiece: undefined,\n      truncatedTitleSecondPiece: undefined,\n    };\n  }\n\n  public componentDidUpdate(prevProps: IDocumentCardTitleProps): void {\n    if (this.props.title !== prevProps.title) {\n      this.setState({\n        truncatedTitleFirstPiece: undefined,\n        truncatedTitleSecondPiece: undefined,\n      });\n    }\n\n    if (prevProps.shouldTruncate !== this.props.shouldTruncate) {\n      if (this.props.shouldTruncate) {\n        this._truncateTitle();\n        this._async.requestAnimationFrame(this._shrinkTitle);\n        this._events.on(window, 'resize', this._updateTruncation);\n      } else {\n        this._events.off(window, 'resize', this._updateTruncation);\n      }\n    } else if (this._needMeasurement) {\n      this._async.requestAnimationFrame(() => {\n        this._truncateWhenInAnimation();\n        this._shrinkTitle();\n      });\n    }\n  }\n\n  public componentDidMount(): void {\n    if (this.props.shouldTruncate) {\n      this._truncateTitle();\n      this._events.on(window, 'resize', this._updateTruncation);\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._events.dispose();\n    this._async.dispose();\n  }\n\n  public render(): JSX.Element {\n    const { title, shouldTruncate, showAsSecondaryTitle, styles, theme, className } = this.props;\n    const { truncatedTitleFirstPiece, truncatedTitleSecondPiece } = this.state;\n\n    this._classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n      showAsSecondaryTitle,\n    });\n\n    if (shouldTruncate && truncatedTitleFirstPiece && truncatedTitleSecondPiece) {\n      return (\n        <div className={this._classNames.root} ref={this._titleElement} title={title}>\n          {truncatedTitleFirstPiece}\n          &hellip;\n          {truncatedTitleSecondPiece}\n        </div>\n      );\n    } else {\n      return (\n        <div\n          className={this._classNames.root}\n          ref={this._titleElement}\n          title={title}\n          style={this._needMeasurement ? { whiteSpace: 'nowrap' } : undefined}\n        >\n          {title}\n        </div>\n      );\n    }\n  }\n\n  /**\n   * In measuring, it will render a same style text with whiteSpace: 'nowrap', to get overflow rate.\n   * So that the logic can predict truncated text well.\n   */\n  private get _needMeasurement(): boolean {\n    return !!this.props.shouldTruncate && this._clientWidth === undefined;\n  }\n\n  // Truncate logic here way can't handle the case that chars with different widths are mixed very well.\n  // Let _shrinkTitle take care of that.\n  private _truncateTitle = (): void => {\n    if (!this._needMeasurement) {\n      return;\n    }\n\n    this._async.requestAnimationFrame(this._truncateWhenInAnimation);\n  };\n\n  private _truncateWhenInAnimation: () => void = () => {\n    const originalTitle = this.props.title;\n    const element: HTMLDivElement | null = this._titleElement.current;\n\n    if (element) {\n      const style: CSSStyleDeclaration = getComputedStyle(element);\n      if (style.width && style.lineHeight && style.height) {\n        const { clientWidth, scrollWidth } = element;\n\n        this._clientWidth = clientWidth;\n\n        const lines: number = Math.floor(\n          (parseInt(style.height, 10) + TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD) / parseInt(style.lineHeight, 10),\n        );\n\n        element.style.whiteSpace = '';\n\n        // Use overflow to predict truncated length.\n        // Take an example.The text is: A text with A very long text that need to be truncated.ppt\n        // if container is like\n        // |A text with A very| long text that need to be truncated.ppt\n        // The scroll width is 58, (take two | out of length)\n        // The client width is 18\n        // the overflow rate is scrollWidth/clientWidth which should be close to length(overflowText)/length(visualText)\n        // And the length of remaining text should be truncated is (original Length)/(58/18) -3 = 15.\n        // So that the logic can predict truncated text well.\n        // first piece will be `A text `, * second piece will be `ated.ppt`\n        // |A text ...ated.ppt|\n        const overFlowRate: number = scrollWidth / (parseInt(style.width, 10) * lines);\n\n        if (overFlowRate > 1) {\n          const truncatedLength: number = originalTitle.length / overFlowRate - 3; /** Saved for separator */\n          return this.setState({\n            truncatedTitleFirstPiece: originalTitle.slice(0, truncatedLength / 2),\n            truncatedTitleSecondPiece: originalTitle.slice(originalTitle.length - truncatedLength / 2),\n          });\n        }\n      }\n    }\n  };\n\n  private _shrinkTitle: () => void = () => {\n    const { truncatedTitleFirstPiece, truncatedTitleSecondPiece } = this.state;\n    if (truncatedTitleFirstPiece && truncatedTitleSecondPiece) {\n      const titleElement = this._titleElement.current;\n\n      if (!titleElement) {\n        return;\n      }\n\n      if (\n        titleElement.scrollHeight > titleElement.clientHeight + TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD ||\n        titleElement.scrollWidth > titleElement.clientWidth\n      ) {\n        this.setState({\n          truncatedTitleFirstPiece: truncatedTitleFirstPiece.slice(0, truncatedTitleFirstPiece.length - 1),\n          truncatedTitleSecondPiece: truncatedTitleSecondPiece.slice(1),\n        });\n      }\n    }\n  };\n\n  private _updateTruncation(): void {\n    if (this._timerId) {\n      return;\n    }\n\n    this._timerId = this._async.setTimeout(() => {\n      delete this._timerId;\n      this._clientWidth = undefined;\n      this.setState({\n        truncatedTitleFirstPiece: undefined,\n        truncatedTitleSecondPiece: undefined,\n      });\n    }, 250);\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}