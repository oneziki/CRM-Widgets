{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, getNativeProps, initializeComponentRef, inputProperties, isIE11, KeyCodes } from '../../Utilities';\nvar SELECTION_FORWARD = 'forward';\nvar SELECTION_BACKWARD = 'backward';\n/**\n * {@docCategory Autofill}\n */\n\nvar Autofill =\n/** @class */\nfunction (_super) {\n  __extends(Autofill, _super);\n\n  function Autofill(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._inputElement = React.createRef();\n    _this._autoFillEnabled = true;\n    _this._isComposing = false; // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n\n    _this._onCompositionStart = function (ev) {\n      _this._isComposing = true;\n      _this._autoFillEnabled = false;\n    }; // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n\n\n    _this._onCompositionUpdate = function () {\n      if (isIE11()) {\n        _this._updateValue(_this._getCurrentInputValue(), true);\n      }\n    }; // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n\n\n    _this._onCompositionEnd = function (ev) {\n      var inputValue = _this._getCurrentInputValue();\n\n      _this._tryEnableAutofill(inputValue, _this.value, false, true);\n\n      _this._isComposing = false; // Due to timing, this needs to be async, otherwise no text will be selected.\n\n      _this._async.setTimeout(function () {\n        // it's technically possible that the value of _isComposing is reset during this timeout,\n        // so explicitly trigger this with composing=true here, since it is supposed to be the\n        // update for composition end\n        _this._updateValue(_this._getCurrentInputValue(), false);\n      }, 0);\n    };\n\n    _this._onClick = function () {\n      if (_this.value && _this.value !== '' && _this._autoFillEnabled) {\n        _this._autoFillEnabled = false;\n      }\n    };\n\n    _this._onKeyDown = function (ev) {\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(ev);\n      } // If the event is actively being composed, then don't alert autofill.\n      // Right now typing does not have isComposing, once that has been fixed any should be removed.\n\n\n      if (!ev.nativeEvent.isComposing) {\n        // eslint-disable-next-line deprecation/deprecation\n        switch (ev.which) {\n          case KeyCodes.backspace:\n            _this._autoFillEnabled = false;\n            break;\n\n          case KeyCodes.left:\n          case KeyCodes.right:\n            if (_this._autoFillEnabled) {\n              _this.setState({\n                inputValue: _this.props.suggestedDisplayValue || ''\n              });\n\n              _this._autoFillEnabled = false;\n            }\n\n            break;\n\n          default:\n            if (!_this._autoFillEnabled) {\n              // eslint-disable-next-line deprecation/deprecation\n              if (_this.props.enableAutofillOnKeyPress.indexOf(ev.which) !== -1) {\n                _this._autoFillEnabled = true;\n              }\n            }\n\n            break;\n        }\n      }\n    };\n\n    _this._onInputChanged = function (ev) {\n      var value = _this._getCurrentInputValue(ev);\n\n      if (!_this._isComposing) {\n        _this._tryEnableAutofill(value, _this.value, ev.nativeEvent.isComposing);\n      } // If it is not IE11 and currently composing, update the value\n\n\n      if (!(isIE11() && _this._isComposing)) {\n        var nativeEventComposing = ev.nativeEvent.isComposing;\n        var isComposing = nativeEventComposing === undefined ? _this._isComposing : nativeEventComposing;\n\n        _this._updateValue(value, isComposing);\n      }\n    };\n\n    _this._onChanged = function () {\n      // Swallow this event, we don't care about it\n      // We must provide it because React PropTypes marks it as required, but onInput serves the correct purpose\n      return;\n    };\n    /**\n     * Updates the current input value as well as getting a new display value.\n     * @param newValue - The new value from the input\n     */\n\n\n    _this._updateValue = function (newValue, composing) {\n      // Only proceed if the value is nonempty and is different from the old value\n      // This is to work around the fact that, in IE 11, inputs with a placeholder fire an onInput event on focus\n      if (!newValue && newValue === _this.value) {\n        return;\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      var _a = _this.props,\n          onInputChange = _a.onInputChange,\n          onInputValueChange = _a.onInputValueChange;\n\n      if (onInputChange) {\n        newValue = (onInputChange === null || onInputChange === void 0 ? void 0 : onInputChange(newValue, composing)) || '';\n      }\n\n      _this.setState({\n        inputValue: newValue\n      }, function () {\n        return onInputValueChange === null || onInputValueChange === void 0 ? void 0 : onInputValueChange(newValue, composing);\n      });\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this.state = {\n      inputValue: props.defaultVisibleValue || ''\n    };\n    return _this;\n  }\n\n  Autofill.getDerivedStateFromProps = function (props, state) {\n    // eslint-disable-next-line deprecation/deprecation\n    if (props.updateValueInWillReceiveProps) {\n      // eslint-disable-next-line deprecation/deprecation\n      var updatedInputValue = props.updateValueInWillReceiveProps(); // Don't update if we have a null value or the value isn't changing\n      // the value should still update if an empty string is passed in\n\n      if (updatedInputValue !== null && updatedInputValue !== state.inputValue) {\n        return {\n          inputValue: updatedInputValue\n        };\n      }\n    }\n\n    return null;\n  };\n\n  Object.defineProperty(Autofill.prototype, \"cursorLocation\", {\n    get: function () {\n      if (this._inputElement.current) {\n        var inputElement = this._inputElement.current;\n\n        if (inputElement.selectionDirection !== SELECTION_FORWARD) {\n          return inputElement.selectionEnd;\n        } else {\n          return inputElement.selectionStart;\n        }\n      } else {\n        return -1;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"isValueSelected\", {\n    get: function () {\n      return Boolean(this.inputElement && this.inputElement.selectionStart !== this.inputElement.selectionEnd);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"value\", {\n    get: function () {\n      return this._getControlledValue() || this.state.inputValue || '';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"selectionStart\", {\n    get: function () {\n      return this._inputElement.current ? this._inputElement.current.selectionStart : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"selectionEnd\", {\n    get: function () {\n      return this._inputElement.current ? this._inputElement.current.selectionEnd : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"inputElement\", {\n    get: function () {\n      return this._inputElement.current;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Autofill.prototype.componentDidUpdate = function (_, _1, cursor) {\n    var _a = this.props,\n        suggestedDisplayValue = _a.suggestedDisplayValue,\n        shouldSelectFullInputValueInComponentDidUpdate = _a.shouldSelectFullInputValueInComponentDidUpdate,\n        preventValueSelection = _a.preventValueSelection;\n    var differenceIndex = 0;\n\n    if (preventValueSelection) {\n      return;\n    }\n\n    if (this._autoFillEnabled && this.value && suggestedDisplayValue && _doesTextStartWith(suggestedDisplayValue, this.value)) {\n      var shouldSelectFullRange = false;\n\n      if (shouldSelectFullInputValueInComponentDidUpdate) {\n        shouldSelectFullRange = shouldSelectFullInputValueInComponentDidUpdate();\n      }\n\n      if (shouldSelectFullRange && this._inputElement.current) {\n        this._inputElement.current.setSelectionRange(0, suggestedDisplayValue.length, SELECTION_BACKWARD);\n      } else {\n        while (differenceIndex < this.value.length && this.value[differenceIndex].toLocaleLowerCase() === suggestedDisplayValue[differenceIndex].toLocaleLowerCase()) {\n          differenceIndex++;\n        }\n\n        if (differenceIndex > 0 && this._inputElement.current) {\n          this._inputElement.current.setSelectionRange(differenceIndex, suggestedDisplayValue.length, SELECTION_BACKWARD);\n        }\n      }\n    } else if (this._inputElement.current) {\n      if (cursor !== null && !this._autoFillEnabled) {\n        this._inputElement.current.setSelectionRange(cursor.start, cursor.end, cursor.dir);\n      }\n    }\n  };\n\n  Autofill.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n  };\n\n  Autofill.prototype.render = function () {\n    var nativeProps = getNativeProps(this.props, inputProperties);\n\n    var style = __assign(__assign({}, this.props.style), {\n      fontFamily: 'inherit'\n    });\n\n    return React.createElement(\"input\", __assign({\n      autoCapitalize: \"off\",\n      autoComplete: \"off\",\n      \"aria-autocomplete\": 'both'\n    }, nativeProps, {\n      style: style,\n      ref: this._inputElement,\n      value: this._getDisplayValue(),\n      onCompositionStart: this._onCompositionStart,\n      onCompositionUpdate: this._onCompositionUpdate,\n      onCompositionEnd: this._onCompositionEnd,\n      // TODO (Fabric 8?) - switch to calling only onChange. See notes in TextField._onInputChange.\n      onChange: this._onChanged,\n      onInput: this._onInputChanged,\n      onKeyDown: this._onKeyDown,\n      onClick: this.props.onClick ? this.props.onClick : this._onClick,\n      \"data-lpignore\": true\n    }));\n  };\n\n  Autofill.prototype.focus = function () {\n    this._inputElement.current && this._inputElement.current.focus();\n  };\n\n  Autofill.prototype.clear = function () {\n    this._autoFillEnabled = true;\n\n    this._updateValue('', false);\n\n    this._inputElement.current && this._inputElement.current.setSelectionRange(0, 0);\n  };\n\n  Autofill.prototype.getSnapshotBeforeUpdate = function () {\n    var inel = this._inputElement.current;\n\n    if (inel && inel.selectionStart !== this.value.length) {\n      return {\n        start: inel.selectionStart || inel.value.length,\n        end: inel.selectionEnd || inel.value.length,\n        dir: inel.selectionDirection || 'backward' || 'none'\n      };\n    }\n\n    return null;\n  };\n\n  Autofill.prototype._getCurrentInputValue = function (ev) {\n    if (ev && ev.target && ev.target.value) {\n      return ev.target.value;\n    } else if (this.inputElement && this.inputElement.value) {\n      return this.inputElement.value;\n    } else {\n      return '';\n    }\n  };\n  /**\n   * Attempts to enable autofill. Whether or not autofill is enabled depends on the input value,\n   * whether or not any text is selected, and only if the new input value is longer than the old input value.\n   * Autofill should never be set to true if the value is composing. Once compositionEnd is called, then\n   * it should be completed.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent for more information on composition.\n   * @param newValue - new input value\n   * @param oldValue - old input value\n   * @param isComposing - if true then the text is actively being composed and it has not completed.\n   * @param isComposed - if the text is a composed text value.\n   */\n\n\n  Autofill.prototype._tryEnableAutofill = function (newValue, oldValue, isComposing, isComposed) {\n    if (!isComposing && newValue && this._inputElement.current && this._inputElement.current.selectionStart === newValue.length && !this._autoFillEnabled && (newValue.length > oldValue.length || isComposed)) {\n      this._autoFillEnabled = true;\n    }\n  };\n\n  Autofill.prototype._getDisplayValue = function () {\n    if (this._autoFillEnabled) {\n      return _getDisplayValue(this.value, this.props.suggestedDisplayValue);\n    }\n\n    return this.value;\n  };\n\n  Autofill.prototype._getControlledValue = function () {\n    var value = this.props.value;\n\n    if (value === undefined || typeof value === 'string') {\n      return value;\n    } // eslint-disable-next-line no-console\n\n\n    console.warn(\"props.value of Autofill should be a string, but it is \" + value + \" with type of \" + typeof value);\n    return value.toString();\n  };\n\n  Autofill.defaultProps = {\n    enableAutofillOnKeyPress: [KeyCodes.down, KeyCodes.up]\n  };\n  return Autofill;\n}(React.Component);\n\nexport { Autofill };\n/**\n * Returns a string that should be used as the display value.\n * It evaluates this based on whether or not the suggested value starts with the input value\n * and whether or not autofill is enabled.\n * @param inputValue - the value that the input currently has.\n * @param suggestedDisplayValue - the possible full value\n */\n\nfunction _getDisplayValue(inputValue, suggestedDisplayValue) {\n  var displayValue = inputValue;\n\n  if (suggestedDisplayValue && inputValue && _doesTextStartWith(suggestedDisplayValue, displayValue)) {\n    displayValue = suggestedDisplayValue;\n  }\n\n  return displayValue;\n}\n\nfunction _doesTextStartWith(text, startWith) {\n  if (!text || !startWith) {\n    return false;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    for (var _i = 0, _a = [text, startWith]; _i < _a.length; _i++) {\n      var val = _a[_i];\n\n      if (typeof val !== 'string') {\n        throw new Error(Autofill.name + \" received non-string value \\\"\" + val + \"\\\" of type \" + typeof val + \" from either input's value or suggestedDisplayValue\");\n      }\n    }\n  }\n\n  return text.toLocaleLowerCase().indexOf(startWith.toLocaleLowerCase()) === 0;\n}","map":{"version":3,"sources":["components/Autofill/Autofill.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { Async, getNativeProps, initializeComponentRef, inputProperties, isIE11, KeyCodes } from '../../Utilities';\nimport { IAutofill, IAutofillProps } from './Autofill.types';\n\nexport interface IAutofillState {\n  inputValue: string;\n}\n\ninterface ICursorLocation {\n  start: number;\n  end: number;\n  dir: 'forward' | 'backward' | 'none' | undefined;\n}\n\nconst SELECTION_FORWARD = 'forward';\nconst SELECTION_BACKWARD = 'backward';\n\n/**\n * {@docCategory Autofill}\n */\nexport class Autofill extends React.Component<IAutofillProps, IAutofillState> implements IAutofill {\n  public static defaultProps = {\n    enableAutofillOnKeyPress: [KeyCodes.down, KeyCodes.up] as KeyCodes[],\n  };\n\n  private _inputElement = React.createRef<HTMLInputElement>();\n  private _autoFillEnabled = true;\n  private _isComposing: boolean = false;\n  private _async: Async;\n\n  public static getDerivedStateFromProps(props: IAutofillProps, state: IAutofillState): IAutofillState | null {\n    // eslint-disable-next-line deprecation/deprecation\n    if (props.updateValueInWillReceiveProps) {\n      // eslint-disable-next-line deprecation/deprecation\n      const updatedInputValue = props.updateValueInWillReceiveProps();\n      // Don't update if we have a null value or the value isn't changing\n      // the value should still update if an empty string is passed in\n      if (updatedInputValue !== null && updatedInputValue !== state.inputValue) {\n        return { inputValue: updatedInputValue };\n      }\n    }\n    return null;\n  }\n\n  constructor(props: IAutofillProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n\n    this.state = {\n      inputValue: props.defaultVisibleValue || '',\n    };\n  }\n\n  public get cursorLocation(): number | null {\n    if (this._inputElement.current) {\n      const inputElement = this._inputElement.current;\n      if (inputElement.selectionDirection !== SELECTION_FORWARD) {\n        return inputElement.selectionEnd;\n      } else {\n        return inputElement.selectionStart;\n      }\n    } else {\n      return -1;\n    }\n  }\n\n  public get isValueSelected(): boolean {\n    return Boolean(this.inputElement && this.inputElement.selectionStart !== this.inputElement.selectionEnd);\n  }\n\n  public get value(): string {\n    return this._getControlledValue() || this.state.inputValue || '';\n  }\n\n  public get selectionStart(): number | null {\n    return this._inputElement.current ? this._inputElement.current.selectionStart : -1;\n  }\n\n  public get selectionEnd(): number | null {\n    return this._inputElement.current ? this._inputElement.current.selectionEnd : -1;\n  }\n\n  public get inputElement(): HTMLInputElement | null {\n    return this._inputElement.current;\n  }\n\n  public componentDidUpdate(_: any, _1: any, cursor: ICursorLocation | null) {\n    const { suggestedDisplayValue, shouldSelectFullInputValueInComponentDidUpdate, preventValueSelection } = this.props;\n    let differenceIndex = 0;\n\n    if (preventValueSelection) {\n      return;\n    }\n\n    if (\n      this._autoFillEnabled &&\n      this.value &&\n      suggestedDisplayValue &&\n      _doesTextStartWith(suggestedDisplayValue, this.value)\n    ) {\n      let shouldSelectFullRange = false;\n\n      if (shouldSelectFullInputValueInComponentDidUpdate) {\n        shouldSelectFullRange = shouldSelectFullInputValueInComponentDidUpdate();\n      }\n\n      if (shouldSelectFullRange && this._inputElement.current) {\n        this._inputElement.current.setSelectionRange(0, suggestedDisplayValue.length, SELECTION_BACKWARD);\n      } else {\n        while (\n          differenceIndex < this.value.length &&\n          this.value[differenceIndex].toLocaleLowerCase() === suggestedDisplayValue[differenceIndex].toLocaleLowerCase()\n        ) {\n          differenceIndex++;\n        }\n        if (differenceIndex > 0 && this._inputElement.current) {\n          this._inputElement.current.setSelectionRange(\n            differenceIndex,\n            suggestedDisplayValue.length,\n            SELECTION_BACKWARD,\n          );\n        }\n      }\n    } else if (this._inputElement.current) {\n      if (cursor !== null && !this._autoFillEnabled) {\n        this._inputElement.current.setSelectionRange(cursor.start, cursor.end, cursor.dir);\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n  }\n\n  public render(): JSX.Element {\n    const nativeProps = getNativeProps<React.InputHTMLAttributes<HTMLInputElement>>(this.props, inputProperties);\n    const style = { ...this.props.style, fontFamily: 'inherit' };\n    return (\n      <input\n        autoCapitalize=\"off\"\n        autoComplete=\"off\"\n        aria-autocomplete={'both'}\n        {...nativeProps}\n        style={style}\n        ref={this._inputElement}\n        value={this._getDisplayValue()}\n        onCompositionStart={this._onCompositionStart}\n        onCompositionUpdate={this._onCompositionUpdate}\n        onCompositionEnd={this._onCompositionEnd}\n        // TODO (Fabric 8?) - switch to calling only onChange. See notes in TextField._onInputChange.\n        onChange={this._onChanged}\n        onInput={this._onInputChanged}\n        onKeyDown={this._onKeyDown}\n        onClick={this.props.onClick ? this.props.onClick : this._onClick}\n        data-lpignore={true}\n      />\n    );\n  }\n\n  public focus() {\n    this._inputElement.current && this._inputElement.current.focus();\n  }\n\n  public clear() {\n    this._autoFillEnabled = true;\n    this._updateValue('', false);\n    this._inputElement.current && this._inputElement.current.setSelectionRange(0, 0);\n  }\n\n  public getSnapshotBeforeUpdate(): ICursorLocation | null {\n    const inel = this._inputElement.current;\n\n    if (inel && inel.selectionStart !== this.value.length) {\n      return {\n        start: inel.selectionStart || inel.value.length,\n        end: inel.selectionEnd || inel.value.length,\n        dir: (inel.selectionDirection as 'forward') || 'backward' || 'none',\n      };\n    }\n    return null;\n  }\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionStart = (ev: React.CompositionEvent<HTMLInputElement>) => {\n    this._isComposing = true;\n    this._autoFillEnabled = false;\n  };\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionUpdate = () => {\n    if (isIE11()) {\n      this._updateValue(this._getCurrentInputValue(), true);\n    }\n  };\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionEnd = (ev: React.CompositionEvent<HTMLInputElement>) => {\n    const inputValue = this._getCurrentInputValue();\n    this._tryEnableAutofill(inputValue, this.value, false, true);\n    this._isComposing = false;\n    // Due to timing, this needs to be async, otherwise no text will be selected.\n    this._async.setTimeout(() => {\n      // it's technically possible that the value of _isComposing is reset during this timeout,\n      // so explicitly trigger this with composing=true here, since it is supposed to be the\n      // update for composition end\n      this._updateValue(this._getCurrentInputValue(), false);\n    }, 0);\n  };\n\n  private _onClick = () => {\n    if (this.value && this.value !== '' && this._autoFillEnabled) {\n      this._autoFillEnabled = false;\n    }\n  };\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLInputElement>) => {\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    // If the event is actively being composed, then don't alert autofill.\n    // Right now typing does not have isComposing, once that has been fixed any should be removed.\n\n    if (!(ev.nativeEvent as any).isComposing) {\n      // eslint-disable-next-line deprecation/deprecation\n      switch (ev.which) {\n        case KeyCodes.backspace:\n          this._autoFillEnabled = false;\n          break;\n        case KeyCodes.left:\n        case KeyCodes.right:\n          if (this._autoFillEnabled) {\n            this.setState({ inputValue: this.props.suggestedDisplayValue || '' });\n            this._autoFillEnabled = false;\n          }\n          break;\n        default:\n          if (!this._autoFillEnabled) {\n            // eslint-disable-next-line deprecation/deprecation\n            if (this.props.enableAutofillOnKeyPress!.indexOf(ev.which) !== -1) {\n              this._autoFillEnabled = true;\n            }\n          }\n          break;\n      }\n    }\n  };\n\n  private _onInputChanged = (ev: React.FormEvent<HTMLElement>) => {\n    const value: string = this._getCurrentInputValue(ev);\n\n    if (!this._isComposing) {\n      this._tryEnableAutofill(value, this.value, (ev.nativeEvent as any).isComposing);\n    }\n\n    // If it is not IE11 and currently composing, update the value\n    if (!(isIE11() && this._isComposing)) {\n      const nativeEventComposing = (ev.nativeEvent as any).isComposing;\n      const isComposing = nativeEventComposing === undefined ? this._isComposing : nativeEventComposing;\n      this._updateValue(value, isComposing);\n    }\n  };\n\n  private _onChanged = (): void => {\n    // Swallow this event, we don't care about it\n    // We must provide it because React PropTypes marks it as required, but onInput serves the correct purpose\n    return;\n  };\n\n  private _getCurrentInputValue(ev?: React.FormEvent<HTMLElement>): string {\n    if (ev && ev.target && (ev.target as HTMLInputElement).value) {\n      return (ev.target as HTMLInputElement).value;\n    } else if (this.inputElement && this.inputElement.value) {\n      return this.inputElement.value;\n    } else {\n      return '';\n    }\n  }\n\n  /**\n   * Attempts to enable autofill. Whether or not autofill is enabled depends on the input value,\n   * whether or not any text is selected, and only if the new input value is longer than the old input value.\n   * Autofill should never be set to true if the value is composing. Once compositionEnd is called, then\n   * it should be completed.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent for more information on composition.\n   * @param newValue - new input value\n   * @param oldValue - old input value\n   * @param isComposing - if true then the text is actively being composed and it has not completed.\n   * @param isComposed - if the text is a composed text value.\n   */\n  private _tryEnableAutofill(newValue: string, oldValue: string, isComposing?: boolean, isComposed?: boolean): void {\n    if (\n      !isComposing &&\n      newValue &&\n      this._inputElement.current &&\n      this._inputElement.current.selectionStart === newValue.length &&\n      !this._autoFillEnabled &&\n      (newValue.length > oldValue.length || isComposed)\n    ) {\n      this._autoFillEnabled = true;\n    }\n  }\n\n  /**\n   * Updates the current input value as well as getting a new display value.\n   * @param newValue - The new value from the input\n   */\n  private _updateValue = (newValue: string, composing: boolean) => {\n    // Only proceed if the value is nonempty and is different from the old value\n    // This is to work around the fact that, in IE 11, inputs with a placeholder fire an onInput event on focus\n    if (!newValue && newValue === this.value) {\n      return;\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    const { onInputChange, onInputValueChange } = this.props;\n    if (onInputChange) {\n      newValue = onInputChange?.(newValue, composing) || '';\n    }\n\n    this.setState({ inputValue: newValue }, () => onInputValueChange?.(newValue, composing));\n  };\n\n  private _getDisplayValue(): string {\n    if (this._autoFillEnabled) {\n      return _getDisplayValue(this.value, this.props.suggestedDisplayValue);\n    }\n\n    return this.value;\n  }\n\n  private _getControlledValue(): string | undefined {\n    const { value } = this.props;\n    if (value === undefined || typeof value === 'string') {\n      return value;\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn(`props.value of Autofill should be a string, but it is ${value} with type of ${typeof value}`);\n\n    return value.toString();\n  }\n}\n/**\n * Returns a string that should be used as the display value.\n * It evaluates this based on whether or not the suggested value starts with the input value\n * and whether or not autofill is enabled.\n * @param inputValue - the value that the input currently has.\n * @param suggestedDisplayValue - the possible full value\n */\nfunction _getDisplayValue(inputValue: string, suggestedDisplayValue?: string): string {\n  let displayValue = inputValue;\n  if (suggestedDisplayValue && inputValue && _doesTextStartWith(suggestedDisplayValue, displayValue)) {\n    displayValue = suggestedDisplayValue;\n  }\n  return displayValue;\n}\n\nfunction _doesTextStartWith(text: string, startWith: string): boolean {\n  if (!text || !startWith) {\n    return false;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    for (const val of [text, startWith]) {\n      if (typeof val !== 'string') {\n        throw new Error(\n          `${\n            Autofill.name\n            // eslint-disable-next-line @fluentui/max-len\n          } received non-string value \"${val}\" of type ${typeof val} from either input's value or suggestedDisplayValue`,\n        );\n      }\n    }\n  }\n\n  return text.toLocaleLowerCase().indexOf(startWith.toLocaleLowerCase()) === 0;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}