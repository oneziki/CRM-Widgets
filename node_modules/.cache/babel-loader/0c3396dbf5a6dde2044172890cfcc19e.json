{"ast":null,"code":"var _a;\n\nimport { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { css, divProperties, elementContains, focusFirstChild, getNativeProps, on, shallowCompare, getPropsWithDefaults } from '../../Utilities';\nimport { positionCallout, getMaxHeight, RectangleEdge, positionCard, getBoundsFromTargetWindow } from '../../Positioning';\nimport { Popup } from '../../Popup';\nimport { classNamesFunction } from '../../Utilities';\nimport { AnimationClassNames } from '../../Styling';\nimport { useMergedRefs, useAsync, useConst, useTarget } from '@fluentui/react-hooks';\nvar ANIMATIONS = (_a = {}, _a[RectangleEdge.top] = AnimationClassNames.slideUpIn10, _a[RectangleEdge.bottom] = AnimationClassNames.slideDownIn10, _a[RectangleEdge.left] = AnimationClassNames.slideLeftIn10, _a[RectangleEdge.right] = AnimationClassNames.slideRightIn10, _a);\nvar getClassNames = classNamesFunction({\n  disableCaching: true\n});\nvar BEAK_ORIGIN_POSITION = {\n  top: 0,\n  left: 0\n}; // Microsoft Edge will overwrite inline styles if there is an animation pertaining to that style.\n// To help ensure that edge will respect the offscreen style opacity\n// filter needs to be added as an additional way to set opacity.\n// Also set pointer-events: none so that the callout will not occlude the element it is\n// going to be positioned against\n\nvar OFF_SCREEN_STYLE = {\n  opacity: 0,\n  filter: 'opacity(0)',\n  pointerEvents: 'none'\n}; // role and role description go hand-in-hand. Both would be included by spreading getNativeProps for a basic element\n// This constant array can be used to filter these out of native props spread on callout root and apply them together on\n// calloutMain (the Popup component within the callout)\n\nvar ARIA_ROLE_ATTRIBUTES = ['role', 'aria-roledescription'];\nvar DEFAULT_PROPS = {\n  preventDismissOnLostFocus: false,\n  preventDismissOnScroll: false,\n  preventDismissOnResize: false,\n  isBeakVisible: true,\n  beakWidth: 16,\n  gapSpace: 0,\n  minPagePadding: 8,\n  directionalHint: DirectionalHint.bottomAutoEdge\n};\n/**\n * Returns a function to lazily fetch the bounds of the target element for the callout\n */\n\nfunction useBounds(_a, targetRef, targetWindow) {\n  var bounds = _a.bounds,\n      _b = _a.minPagePadding,\n      minPagePadding = _b === void 0 ? DEFAULT_PROPS.minPagePadding : _b,\n      target = _a.target;\n  var cachedBounds = React.useRef();\n  var getBounds = React.useCallback(function () {\n    if (!cachedBounds.current) {\n      var currentBounds = typeof bounds === 'function' ? targetWindow ? bounds(target, targetWindow) : undefined : bounds;\n\n      if (!currentBounds && targetWindow) {\n        currentBounds = getBoundsFromTargetWindow(targetRef.current, targetWindow);\n        currentBounds = {\n          top: currentBounds.top + minPagePadding,\n          left: currentBounds.left + minPagePadding,\n          right: currentBounds.right - minPagePadding,\n          bottom: currentBounds.bottom - minPagePadding,\n          width: currentBounds.width - minPagePadding * 2,\n          height: currentBounds.height - minPagePadding * 2\n        };\n      }\n\n      cachedBounds.current = currentBounds;\n    }\n\n    return cachedBounds.current;\n  }, [bounds, minPagePadding, target, targetRef, targetWindow]);\n  return getBounds;\n}\n/**\n * Returns the maximum available height for the Callout to render into\n */\n\n\nfunction useMaxHeight(_a, targetRef, getBounds) {\n  var beakWidth = _a.beakWidth,\n      coverTarget = _a.coverTarget,\n      directionalHint = _a.directionalHint,\n      directionalHintFixed = _a.directionalHintFixed,\n      gapSpace = _a.gapSpace,\n      isBeakVisible = _a.isBeakVisible,\n      hidden = _a.hidden;\n\n  var _b = React.useState(),\n      maxHeight = _b[0],\n      setMaxHeight = _b[1];\n\n  var async = useAsync(); // Updating targetRef won't re-render the component, but it's recalculated (if needed) with every render\n  // If it mutates, we want to re-run the effect\n\n  var currentTarget = targetRef.current;\n  React.useEffect(function () {\n    var _a;\n\n    if (!maxHeight && !hidden) {\n      if (directionalHintFixed && currentTarget) {\n        // Since the callout cannot measure it's border size it must be taken into account here. Otherwise it will\n        // overlap with the target.\n        var totalGap_1 = (gapSpace !== null && gapSpace !== void 0 ? gapSpace : 0) + (isBeakVisible && beakWidth ? beakWidth : 0);\n        async.requestAnimationFrame(function () {\n          if (targetRef.current) {\n            setMaxHeight(getMaxHeight(targetRef.current, directionalHint, totalGap_1, getBounds(), coverTarget));\n          }\n        });\n      } else {\n        setMaxHeight((_a = getBounds()) === null || _a === void 0 ? void 0 : _a.height);\n      }\n    } else if (hidden) {\n      setMaxHeight(undefined);\n    }\n  }, [targetRef, currentTarget, gapSpace, beakWidth, getBounds, hidden, async, coverTarget, directionalHint, directionalHintFixed, isBeakVisible, maxHeight]);\n  return maxHeight;\n}\n/**\n * Returns the height offset of the callout element and updates it each frame to approach the configured finalHeight\n */\n\n\nfunction useHeightOffset(_a, calloutElement) {\n  var finalHeight = _a.finalHeight,\n      hidden = _a.hidden;\n\n  var _b = React.useState(0),\n      heightOffset = _b[0],\n      setHeightOffset = _b[1];\n\n  var async = useAsync();\n  var setHeightOffsetTimer = React.useRef();\n  var setHeightOffsetEveryFrame = React.useCallback(function () {\n    if (calloutElement.current && finalHeight) {\n      setHeightOffsetTimer.current = async.requestAnimationFrame(function () {\n        var _a;\n\n        var calloutMainElem = (_a = calloutElement.current) === null || _a === void 0 ? void 0 : _a.lastChild;\n\n        if (!calloutMainElem) {\n          return;\n        }\n\n        var cardScrollHeight = calloutMainElem.scrollHeight;\n        var cardCurrHeight = calloutMainElem.offsetHeight;\n        var scrollDiff = cardScrollHeight - cardCurrHeight;\n        setHeightOffset(function (currentHeightOffset) {\n          return currentHeightOffset + scrollDiff;\n        });\n\n        if (calloutMainElem.offsetHeight < finalHeight) {\n          setHeightOffsetEveryFrame();\n        } else {\n          async.cancelAnimationFrame(setHeightOffsetTimer.current, calloutElement.current);\n        }\n      }, calloutElement.current);\n    }\n  }, [async, calloutElement, finalHeight]);\n  React.useEffect(function () {\n    if (!hidden) {\n      setHeightOffsetEveryFrame();\n    }\n  }, [finalHeight, hidden, setHeightOffsetEveryFrame]);\n  return heightOffset;\n}\n/**\n * Get the position information for the callout. If the callout does not fit in the given orientation,\n * a new position is calculated for the next frame, up to 5 attempts\n */\n\n\nfunction usePositions(props, hostElement, calloutElement, targetRef, getBounds) {\n  var _a = React.useState(),\n      positions = _a[0],\n      setPositions = _a[1];\n\n  var positionAttempts = React.useRef(0);\n  var async = useAsync();\n  var hidden = props.hidden,\n      target = props.target,\n      finalHeight = props.finalHeight,\n      onPositioned = props.onPositioned,\n      directionalHint = props.directionalHint;\n  React.useEffect(function () {\n    if (!hidden) {\n      var timerId_1 = async.requestAnimationFrame(function () {\n        // If we expect a target element to position against, we need to wait until `targetRef.current`\n        // is resolved. Otherwise we can try to position.\n        var expectsTarget = !!target;\n\n        if (hostElement.current && calloutElement.current && (!expectsTarget || targetRef.current)) {\n          var currentProps = __assign(__assign({}, props), {\n            target: targetRef.current,\n            bounds: getBounds()\n          }); // If there is a finalHeight given then we assume that the user knows and will handle\n          // additional positioning adjustments so we should call positionCard\n\n\n          var newPositions = finalHeight ? positionCard(currentProps, hostElement.current, calloutElement.current, positions) : positionCallout(currentProps, hostElement.current, calloutElement.current, positions); // Set the new position only when the positions are not exists or one of the new callout positions\n          // are different. The position should not change if the position is within 2 decimal places.\n\n          if (!positions && newPositions || positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5) {\n            // We should not reposition the callout more than a few times, if it is then the content is likely resizing\n            // and we should stop trying to reposition to prevent a stack overflow.\n            positionAttempts.current++;\n            setPositions(newPositions);\n          } else if (positionAttempts.current > 0) {\n            // Only call the onPositioned callback if the callout has been re-positioned at least once.\n            positionAttempts.current = 0;\n            onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned(positions);\n          }\n        }\n      }, calloutElement.current);\n      return function () {\n        return async.cancelAnimationFrame(timerId_1);\n      };\n    }\n  }, [hidden, directionalHint, async, calloutElement, hostElement, targetRef, finalHeight, getBounds, onPositioned, positions, props, target]);\n  return positions;\n}\n/**\n * Hook to set up behavior to automatically focus the callout when it appears, if indicated by props.\n */\n\n\nfunction useAutoFocus(_a, positions, calloutElement) {\n  var hidden = _a.hidden,\n      setInitialFocus = _a.setInitialFocus;\n  var async = useAsync();\n  var hasPositions = !!positions;\n  React.useEffect(function () {\n    if (!hidden && setInitialFocus && hasPositions && calloutElement.current) {\n      var timerId_2 = async.requestAnimationFrame(function () {\n        return focusFirstChild(calloutElement.current);\n      }, calloutElement.current);\n      return function () {\n        return async.cancelAnimationFrame(timerId_2);\n      };\n    }\n  }, [hidden, hasPositions, async, calloutElement, setInitialFocus]);\n}\n/**\n * Hook to set up various handlers to dismiss the popup when it loses focus or the window scrolls or similar cases.\n */\n\n\nfunction useDismissHandlers(_a, positions, hostElement, targetRef, targetWindow) {\n  var hidden = _a.hidden,\n      onDismiss = _a.onDismiss,\n      // eslint-disable-next-line deprecation/deprecation\n  preventDismissOnScroll = _a.preventDismissOnScroll,\n      // eslint-disable-next-line deprecation/deprecation\n  preventDismissOnResize = _a.preventDismissOnResize,\n      // eslint-disable-next-line deprecation/deprecation\n  preventDismissOnLostFocus = _a.preventDismissOnLostFocus,\n      shouldDismissOnWindowFocus = _a.shouldDismissOnWindowFocus,\n      preventDismissOnEvent = _a.preventDismissOnEvent;\n  var isMouseDownOnPopup = React.useRef(false);\n  var async = useAsync();\n  var mouseDownHandlers = useConst([function () {\n    isMouseDownOnPopup.current = true;\n  }, function () {\n    isMouseDownOnPopup.current = false;\n  }]);\n  var positionsExists = !!positions;\n  React.useEffect(function () {\n    var dismissOnScroll = function (ev) {\n      if (positionsExists && !preventDismissOnScroll) {\n        dismissOnClickOrScroll(ev);\n      }\n    };\n\n    var dismissOnResize = function (ev) {\n      if (!preventDismissOnResize) {\n        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);\n      }\n    };\n\n    var dismissOnLostFocus = function (ev) {\n      if (!preventDismissOnLostFocus) {\n        dismissOnClickOrScroll(ev);\n      }\n    };\n\n    var dismissOnClickOrScroll = function (ev) {\n      var target = ev.target;\n      var isEventTargetOutsideCallout = hostElement.current && !elementContains(hostElement.current, target); // If mouse is pressed down on callout but moved outside then released, don't dismiss the callout.\n\n      if (isEventTargetOutsideCallout && isMouseDownOnPopup.current) {\n        isMouseDownOnPopup.current = false;\n        return;\n      }\n\n      if (!targetRef.current && isEventTargetOutsideCallout || ev.target !== targetWindow && isEventTargetOutsideCallout && (!targetRef.current || 'stopPropagation' in targetRef.current || target !== targetRef.current && !elementContains(targetRef.current, target))) {\n        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);\n      }\n    };\n\n    var dismissOnTargetWindowBlur = function (ev) {\n      // Do nothing\n      if (!shouldDismissOnWindowFocus) {\n        return;\n      }\n\n      if ((preventDismissOnEvent && !preventDismissOnEvent(ev) || !preventDismissOnEvent && !preventDismissOnLostFocus) && !(targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.hasFocus()) && ev.relatedTarget === null) {\n        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);\n      }\n    }; // This is added so the callout will dismiss when the window is scrolled\n    // but not when something inside the callout is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the callout.\n\n\n    var disposablesPromise = new Promise(function (resolve) {\n      async.setTimeout(function () {\n        if (!hidden && targetWindow) {\n          var disposables_1 = [on(targetWindow, 'scroll', dismissOnScroll, true), on(targetWindow, 'resize', dismissOnResize, true), on(targetWindow.document.documentElement, 'focus', dismissOnLostFocus, true), on(targetWindow.document.documentElement, 'click', dismissOnLostFocus, true), on(targetWindow, 'blur', dismissOnTargetWindowBlur, true)];\n          resolve(function () {\n            disposables_1.forEach(function (dispose) {\n              return dispose();\n            });\n          });\n        }\n      }, 0);\n    });\n    return function () {\n      disposablesPromise.then(function (dispose) {\n        return dispose();\n      });\n    };\n  }, [hidden, async, hostElement, targetRef, targetWindow, onDismiss, shouldDismissOnWindowFocus, preventDismissOnLostFocus, preventDismissOnResize, preventDismissOnScroll, positionsExists, preventDismissOnEvent]);\n  return mouseDownHandlers;\n}\n\nvar COMPONENT_NAME = 'CalloutContentBase';\nexport var CalloutContentBase = React.memo(React.forwardRef(function (propsWithoutDefaults, forwardedRef) {\n  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n  var styles = props.styles,\n      style = props.style,\n      ariaLabel = props.ariaLabel,\n      ariaDescribedBy = props.ariaDescribedBy,\n      ariaLabelledBy = props.ariaLabelledBy,\n      className = props.className,\n      isBeakVisible = props.isBeakVisible,\n      children = props.children,\n      beakWidth = props.beakWidth,\n      calloutWidth = props.calloutWidth,\n      calloutMaxWidth = props.calloutMaxWidth,\n      calloutMinWidth = props.calloutMinWidth,\n      finalHeight = props.finalHeight,\n      _a = props.hideOverflow,\n      hideOverflow = _a === void 0 ? !!finalHeight : _a,\n      backgroundColor = props.backgroundColor,\n      calloutMaxHeight = props.calloutMaxHeight,\n      onScroll = props.onScroll,\n      // eslint-disable-next-line deprecation/deprecation\n  _b = props.shouldRestoreFocus,\n      // eslint-disable-next-line deprecation/deprecation\n  shouldRestoreFocus = _b === void 0 ? true : _b,\n      target = props.target,\n      hidden = props.hidden,\n      onLayerMounted = props.onLayerMounted;\n  var hostElement = React.useRef(null);\n  var calloutElement = React.useRef(null);\n  var rootRef = useMergedRefs(hostElement, forwardedRef);\n\n  var _c = useTarget(props.target, calloutElement),\n      targetRef = _c[0],\n      targetWindow = _c[1];\n\n  var getBounds = useBounds(props, targetRef, targetWindow);\n  var maxHeight = useMaxHeight(props, targetRef, getBounds);\n  var heightOffset = useHeightOffset(props, calloutElement);\n  var positions = usePositions(props, hostElement, calloutElement, targetRef, getBounds);\n\n  var _d = useDismissHandlers(props, positions, hostElement, targetRef, targetWindow),\n      mouseDownOnPopup = _d[0],\n      mouseUpOnPopup = _d[1];\n\n  useAutoFocus(props, positions, calloutElement);\n  React.useEffect(function () {\n    if (!hidden) {\n      onLayerMounted === null || onLayerMounted === void 0 ? void 0 : onLayerMounted();\n    } // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if hidden changes\n\n  }, [hidden]); // If there is no target window then we are likely in server side rendering and we should not render anything.\n\n  if (!targetWindow) {\n    return null;\n  }\n\n  var getContentMaxHeight = maxHeight ? maxHeight + heightOffset : undefined;\n  var contentMaxHeight = calloutMaxHeight && getContentMaxHeight && calloutMaxHeight < getContentMaxHeight ? calloutMaxHeight : getContentMaxHeight;\n  var overflowYHidden = hideOverflow;\n  var beakVisible = isBeakVisible && !!target;\n  var classNames = getClassNames(styles, {\n    theme: props.theme,\n    className: className,\n    overflowYHidden: overflowYHidden,\n    calloutWidth: calloutWidth,\n    positions: positions,\n    beakWidth: beakWidth,\n    backgroundColor: backgroundColor,\n    calloutMaxWidth: calloutMaxWidth,\n    calloutMinWidth: calloutMinWidth\n  });\n\n  var overflowStyle = __assign(__assign(__assign({}, style), {\n    maxHeight: contentMaxHeight\n  }), overflowYHidden && {\n    overflowY: 'hidden'\n  });\n\n  var visibilityStyle = props.hidden ? {\n    visibility: 'hidden'\n  } : undefined; // React.CSSProperties does not understand IRawStyle, so the inline animations will need to be cast as any for now.\n\n  var content = React.createElement(\"div\", {\n    ref: rootRef,\n    className: classNames.container,\n    style: visibilityStyle\n  }, React.createElement(\"div\", __assign({}, getNativeProps(props, divProperties, ARIA_ROLE_ATTRIBUTES), {\n    className: css(classNames.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge]),\n    style: positions ? positions.elementPosition : OFF_SCREEN_STYLE,\n    // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n    // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n    tabIndex: -1,\n    ref: calloutElement\n  }), beakVisible && React.createElement(\"div\", {\n    className: classNames.beak,\n    style: getBeakPosition(positions)\n  }), beakVisible && React.createElement(\"div\", {\n    className: classNames.beakCurtain\n  }), React.createElement(Popup, __assign({}, getNativeProps(props, ARIA_ROLE_ATTRIBUTES), {\n    ariaLabel: ariaLabel,\n    onRestoreFocus: props.onRestoreFocus,\n    ariaDescribedBy: ariaDescribedBy,\n    ariaLabelledBy: ariaLabelledBy,\n    className: classNames.calloutMain,\n    onDismiss: props.onDismiss,\n    onScroll: onScroll,\n    shouldRestoreFocus: shouldRestoreFocus,\n    style: overflowStyle,\n    onMouseDown: mouseDownOnPopup,\n    onMouseUp: mouseUpOnPopup\n  }), children)));\n  return content;\n}), function (previousProps, nextProps) {\n  if (!nextProps.shouldUpdateWhenHidden && previousProps.hidden && nextProps.hidden) {\n    // Do not update when hidden.\n    return true;\n  }\n\n  return shallowCompare(previousProps, nextProps);\n});\nCalloutContentBase.displayName = COMPONENT_NAME;\n\nfunction getBeakPosition(positions) {\n  var _a;\n\n  var beakPositionStyle = __assign({}, (_a = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _a === void 0 ? void 0 : _a.elementPosition);\n\n  if (!beakPositionStyle.top && !beakPositionStyle.bottom && !beakPositionStyle.left && !beakPositionStyle.right) {\n    beakPositionStyle.left = BEAK_ORIGIN_POSITION.left;\n    beakPositionStyle.top = BEAK_ORIGIN_POSITION.top;\n  }\n\n  return beakPositionStyle;\n}\n\nfunction arePositionsEqual(positions, newPosition) {\n  return comparePositions(positions.elementPosition, newPosition.elementPosition) && comparePositions(positions.beakPosition.elementPosition, newPosition.beakPosition.elementPosition);\n}\n\nfunction comparePositions(oldPositions, newPositions) {\n  for (var key in newPositions) {\n    if (newPositions.hasOwnProperty(key)) {\n      var oldPositionEdge = oldPositions[key];\n      var newPositionEdge = newPositions[key];\n\n      if (oldPositionEdge !== undefined && newPositionEdge !== undefined) {\n        if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}","map":{"version":3,"sources":["components/Callout/CalloutContent.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { ICalloutProps, ICalloutContentStyleProps, ICalloutContentStyles } from './Callout.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport {\n  Point,\n  IRectangle,\n  css,\n  divProperties,\n  elementContains,\n  focusFirstChild,\n  getNativeProps,\n  on,\n  shallowCompare,\n  getPropsWithDefaults,\n} from '../../Utilities';\nimport {\n  positionCallout,\n  ICalloutPositionedInfo,\n  IPositionProps,\n  getMaxHeight,\n  IPosition,\n  RectangleEdge,\n  positionCard,\n  getBoundsFromTargetWindow,\n} from '../../Positioning';\nimport { Popup } from '../../Popup';\nimport { classNamesFunction } from '../../Utilities';\nimport { AnimationClassNames } from '../../Styling';\nimport { useMergedRefs, useAsync, useConst, useTarget } from '@fluentui/react-hooks';\n\nconst ANIMATIONS: { [key: number]: string | undefined } = {\n  [RectangleEdge.top]: AnimationClassNames.slideUpIn10,\n  [RectangleEdge.bottom]: AnimationClassNames.slideDownIn10,\n  [RectangleEdge.left]: AnimationClassNames.slideLeftIn10,\n  [RectangleEdge.right]: AnimationClassNames.slideRightIn10,\n};\n\nconst getClassNames = classNamesFunction<ICalloutContentStyleProps, ICalloutContentStyles>({\n  disableCaching: true, // disabling caching because stylesProp.position mutates often\n});\n\nconst BEAK_ORIGIN_POSITION = { top: 0, left: 0 };\n// Microsoft Edge will overwrite inline styles if there is an animation pertaining to that style.\n// To help ensure that edge will respect the offscreen style opacity\n// filter needs to be added as an additional way to set opacity.\n// Also set pointer-events: none so that the callout will not occlude the element it is\n// going to be positioned against\nconst OFF_SCREEN_STYLE: React.CSSProperties = { opacity: 0, filter: 'opacity(0)', pointerEvents: 'none' };\n// role and role description go hand-in-hand. Both would be included by spreading getNativeProps for a basic element\n// This constant array can be used to filter these out of native props spread on callout root and apply them together on\n// calloutMain (the Popup component within the callout)\nconst ARIA_ROLE_ATTRIBUTES = ['role', 'aria-roledescription'];\n\nconst DEFAULT_PROPS = {\n  preventDismissOnLostFocus: false,\n  preventDismissOnScroll: false,\n  preventDismissOnResize: false,\n  isBeakVisible: true,\n  beakWidth: 16,\n  gapSpace: 0,\n  minPagePadding: 8,\n  directionalHint: DirectionalHint.bottomAutoEdge,\n} as const;\n\n/**\n * Returns a function to lazily fetch the bounds of the target element for the callout\n */\nfunction useBounds(\n  { bounds, minPagePadding = DEFAULT_PROPS.minPagePadding, target }: ICalloutProps,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  targetWindow: Window | undefined,\n) {\n  const cachedBounds = React.useRef<IRectangle | undefined>();\n\n  const getBounds = React.useCallback((): IRectangle | undefined => {\n    if (!cachedBounds.current) {\n      let currentBounds =\n        typeof bounds === 'function' ? (targetWindow ? bounds(target, targetWindow) : undefined) : bounds;\n\n      if (!currentBounds && targetWindow) {\n        currentBounds = getBoundsFromTargetWindow(targetRef.current, targetWindow);\n        currentBounds = {\n          top: currentBounds.top + minPagePadding,\n          left: currentBounds.left + minPagePadding,\n          right: currentBounds.right! - minPagePadding,\n          bottom: currentBounds.bottom! - minPagePadding,\n          width: currentBounds.width - minPagePadding * 2,\n          height: currentBounds.height - minPagePadding * 2,\n        };\n      }\n      cachedBounds.current = currentBounds;\n    }\n    return cachedBounds.current;\n  }, [bounds, minPagePadding, target, targetRef, targetWindow]);\n\n  return getBounds;\n}\n\n/**\n * Returns the maximum available height for the Callout to render into\n */\nfunction useMaxHeight(\n  { beakWidth, coverTarget, directionalHint, directionalHintFixed, gapSpace, isBeakVisible, hidden }: ICalloutProps,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  getBounds: () => IRectangle | undefined,\n) {\n  const [maxHeight, setMaxHeight] = React.useState<number | undefined>();\n  const async = useAsync();\n\n  // Updating targetRef won't re-render the component, but it's recalculated (if needed) with every render\n  // If it mutates, we want to re-run the effect\n  const currentTarget = targetRef.current;\n\n  React.useEffect(() => {\n    if (!maxHeight && !hidden) {\n      if (directionalHintFixed && currentTarget) {\n        // Since the callout cannot measure it's border size it must be taken into account here. Otherwise it will\n        // overlap with the target.\n        const totalGap: number = (gapSpace ?? 0) + (isBeakVisible && beakWidth ? beakWidth : 0);\n        async.requestAnimationFrame(() => {\n          if (targetRef.current) {\n            setMaxHeight(getMaxHeight(targetRef.current, directionalHint!, totalGap, getBounds(), coverTarget));\n          }\n        });\n      } else {\n        setMaxHeight(getBounds()?.height);\n      }\n    } else if (hidden) {\n      setMaxHeight(undefined);\n    }\n  }, [\n    targetRef,\n    currentTarget,\n    gapSpace,\n    beakWidth,\n    getBounds,\n    hidden,\n    async,\n    coverTarget,\n    directionalHint,\n    directionalHintFixed,\n    isBeakVisible,\n    maxHeight,\n  ]);\n\n  return maxHeight;\n}\n\n/**\n * Returns the height offset of the callout element and updates it each frame to approach the configured finalHeight\n */\nfunction useHeightOffset({ finalHeight, hidden }: ICalloutProps, calloutElement: React.RefObject<HTMLDivElement>) {\n  const [heightOffset, setHeightOffset] = React.useState<number>(0);\n  const async = useAsync();\n  const setHeightOffsetTimer = React.useRef<number | undefined>();\n\n  const setHeightOffsetEveryFrame = React.useCallback((): void => {\n    if (calloutElement.current && finalHeight) {\n      setHeightOffsetTimer.current = async.requestAnimationFrame(() => {\n        const calloutMainElem = calloutElement.current?.lastChild as HTMLElement;\n\n        if (!calloutMainElem) {\n          return;\n        }\n\n        const cardScrollHeight: number = calloutMainElem.scrollHeight;\n        const cardCurrHeight: number = calloutMainElem.offsetHeight;\n        const scrollDiff: number = cardScrollHeight - cardCurrHeight;\n\n        setHeightOffset(currentHeightOffset => currentHeightOffset + scrollDiff);\n\n        if (calloutMainElem.offsetHeight < finalHeight) {\n          setHeightOffsetEveryFrame();\n        } else {\n          async.cancelAnimationFrame(setHeightOffsetTimer.current!, calloutElement.current);\n        }\n      }, calloutElement.current);\n    }\n  }, [async, calloutElement, finalHeight]);\n\n  React.useEffect(() => {\n    if (!hidden) {\n      setHeightOffsetEveryFrame();\n    }\n  }, [finalHeight, hidden, setHeightOffsetEveryFrame]);\n\n  return heightOffset;\n}\n\n/**\n * Get the position information for the callout. If the callout does not fit in the given orientation,\n * a new position is calculated for the next frame, up to 5 attempts\n */\nfunction usePositions(\n  props: ICalloutProps,\n  hostElement: React.RefObject<HTMLDivElement>,\n  calloutElement: React.RefObject<HTMLDivElement>,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  getBounds: () => IRectangle | undefined,\n) {\n  const [positions, setPositions] = React.useState<ICalloutPositionedInfo>();\n  const positionAttempts = React.useRef(0);\n  const async = useAsync();\n  const { hidden, target, finalHeight, onPositioned, directionalHint } = props;\n\n  React.useEffect(() => {\n    if (!hidden) {\n      const timerId = async.requestAnimationFrame(() => {\n        // If we expect a target element to position against, we need to wait until `targetRef.current`\n        // is resolved. Otherwise we can try to position.\n        const expectsTarget = !!target;\n\n        if (hostElement.current && calloutElement.current && (!expectsTarget || targetRef.current)) {\n          const currentProps: IPositionProps = {\n            ...props,\n            target: targetRef.current!,\n            bounds: getBounds(),\n          };\n          // If there is a finalHeight given then we assume that the user knows and will handle\n          // additional positioning adjustments so we should call positionCard\n          const newPositions: ICalloutPositionedInfo = finalHeight\n            ? positionCard(currentProps, hostElement.current, calloutElement.current, positions)\n            : positionCallout(currentProps, hostElement.current, calloutElement.current, positions);\n\n          // Set the new position only when the positions are not exists or one of the new callout positions\n          // are different. The position should not change if the position is within 2 decimal places.\n          if (\n            (!positions && newPositions) ||\n            (positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5)\n          ) {\n            // We should not reposition the callout more than a few times, if it is then the content is likely resizing\n            // and we should stop trying to reposition to prevent a stack overflow.\n            positionAttempts.current++;\n            setPositions(newPositions);\n          } else if (positionAttempts.current > 0) {\n            // Only call the onPositioned callback if the callout has been re-positioned at least once.\n            positionAttempts.current = 0;\n            onPositioned?.(positions);\n          }\n        }\n      }, calloutElement.current);\n\n      return () => async.cancelAnimationFrame(timerId);\n    }\n  }, [\n    hidden,\n    directionalHint,\n    async,\n    calloutElement,\n    hostElement,\n    targetRef,\n    finalHeight,\n    getBounds,\n    onPositioned,\n    positions,\n    props,\n    target,\n  ]);\n\n  return positions;\n}\n\n/**\n * Hook to set up behavior to automatically focus the callout when it appears, if indicated by props.\n */\nfunction useAutoFocus(\n  { hidden, setInitialFocus }: ICalloutProps,\n  positions: ICalloutPositionedInfo | undefined,\n  calloutElement: React.RefObject<HTMLDivElement>,\n) {\n  const async = useAsync();\n  const hasPositions = !!positions;\n  React.useEffect(() => {\n    if (!hidden && setInitialFocus && hasPositions && calloutElement.current) {\n      const timerId = async.requestAnimationFrame(\n        () => focusFirstChild(calloutElement.current!),\n        calloutElement.current,\n      );\n\n      return () => async.cancelAnimationFrame(timerId);\n    }\n  }, [hidden, hasPositions, async, calloutElement, setInitialFocus]);\n}\n\n/**\n * Hook to set up various handlers to dismiss the popup when it loses focus or the window scrolls or similar cases.\n */\nfunction useDismissHandlers(\n  {\n    hidden,\n    onDismiss,\n    // eslint-disable-next-line deprecation/deprecation\n    preventDismissOnScroll,\n    // eslint-disable-next-line deprecation/deprecation\n    preventDismissOnResize,\n    // eslint-disable-next-line deprecation/deprecation\n    preventDismissOnLostFocus,\n    shouldDismissOnWindowFocus,\n    preventDismissOnEvent,\n  }: ICalloutProps,\n  positions: ICalloutPositionedInfo | undefined,\n  hostElement: React.RefObject<HTMLDivElement>,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  targetWindow: Window | undefined,\n) {\n  const isMouseDownOnPopup = React.useRef(false);\n  const async = useAsync();\n\n  const mouseDownHandlers = useConst([\n    () => {\n      isMouseDownOnPopup.current = true;\n    },\n    () => {\n      isMouseDownOnPopup.current = false;\n    },\n  ] as const);\n\n  const positionsExists = !!positions;\n\n  React.useEffect(() => {\n    const dismissOnScroll = (ev: Event) => {\n      if (positionsExists && !preventDismissOnScroll) {\n        dismissOnClickOrScroll(ev);\n      }\n    };\n\n    const dismissOnResize = (ev: Event) => {\n      if (!preventDismissOnResize) {\n        onDismiss?.(ev);\n      }\n    };\n\n    const dismissOnLostFocus = (ev: Event) => {\n      if (!preventDismissOnLostFocus) {\n        dismissOnClickOrScroll(ev);\n      }\n    };\n\n    const dismissOnClickOrScroll = (ev: Event) => {\n      const target = ev.target as HTMLElement;\n      const isEventTargetOutsideCallout = hostElement.current && !elementContains(hostElement.current, target);\n\n      // If mouse is pressed down on callout but moved outside then released, don't dismiss the callout.\n      if (isEventTargetOutsideCallout && isMouseDownOnPopup.current) {\n        isMouseDownOnPopup.current = false;\n        return;\n      }\n\n      if (\n        (!targetRef.current && isEventTargetOutsideCallout) ||\n        (ev.target !== targetWindow &&\n          isEventTargetOutsideCallout &&\n          (!targetRef.current ||\n            'stopPropagation' in targetRef.current ||\n            (target !== targetRef.current && !elementContains(targetRef.current as HTMLElement, target))))\n      ) {\n        onDismiss?.(ev);\n      }\n    };\n\n    const dismissOnTargetWindowBlur = (ev: FocusEvent) => {\n      // Do nothing\n      if (!shouldDismissOnWindowFocus) {\n        return;\n      }\n\n      if (\n        ((preventDismissOnEvent && !preventDismissOnEvent(ev)) ||\n          (!preventDismissOnEvent && !preventDismissOnLostFocus)) &&\n        !targetWindow?.document.hasFocus() &&\n        ev.relatedTarget === null\n      ) {\n        onDismiss?.(ev);\n      }\n    };\n\n    // This is added so the callout will dismiss when the window is scrolled\n    // but not when something inside the callout is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the callout.\n    const disposablesPromise = new Promise<() => void>(resolve => {\n      async.setTimeout(() => {\n        if (!hidden && targetWindow) {\n          const disposables = [\n            on(targetWindow, 'scroll', dismissOnScroll, true),\n            on(targetWindow, 'resize', dismissOnResize, true),\n            on(targetWindow.document.documentElement, 'focus', dismissOnLostFocus, true),\n            on(targetWindow.document.documentElement, 'click', dismissOnLostFocus, true),\n            on(targetWindow, 'blur', dismissOnTargetWindowBlur, true),\n          ];\n\n          resolve(() => {\n            disposables.forEach(dispose => dispose());\n          });\n        }\n      }, 0);\n    });\n\n    return () => {\n      disposablesPromise.then(dispose => dispose());\n    };\n  }, [\n    hidden,\n    async,\n    hostElement,\n    targetRef,\n    targetWindow,\n    onDismiss,\n    shouldDismissOnWindowFocus,\n    preventDismissOnLostFocus,\n    preventDismissOnResize,\n    preventDismissOnScroll,\n    positionsExists,\n    preventDismissOnEvent,\n  ]);\n\n  return mouseDownHandlers;\n}\n\nconst COMPONENT_NAME = 'CalloutContentBase';\n\nexport const CalloutContentBase: React.FunctionComponent<ICalloutProps> = React.memo(\n  React.forwardRef<HTMLDivElement, ICalloutProps>((propsWithoutDefaults, forwardedRef) => {\n    const props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n\n    const {\n      styles,\n      style,\n      ariaLabel,\n      ariaDescribedBy,\n      ariaLabelledBy,\n      className,\n      isBeakVisible,\n      children,\n      beakWidth,\n      calloutWidth,\n      calloutMaxWidth,\n      calloutMinWidth,\n      finalHeight,\n      hideOverflow = !!finalHeight,\n      backgroundColor,\n      calloutMaxHeight,\n      onScroll,\n      // eslint-disable-next-line deprecation/deprecation\n      shouldRestoreFocus = true,\n      target,\n      hidden,\n      onLayerMounted,\n    } = props;\n\n    const hostElement = React.useRef<HTMLDivElement>(null);\n    const calloutElement = React.useRef<HTMLDivElement>(null);\n    const rootRef = useMergedRefs(hostElement, forwardedRef);\n\n    const [targetRef, targetWindow] = useTarget(props.target, calloutElement);\n    const getBounds = useBounds(props, targetRef, targetWindow);\n    const maxHeight = useMaxHeight(props, targetRef, getBounds);\n    const heightOffset = useHeightOffset(props, calloutElement);\n    const positions = usePositions(props, hostElement, calloutElement, targetRef, getBounds);\n    const [mouseDownOnPopup, mouseUpOnPopup] = useDismissHandlers(\n      props,\n      positions,\n      hostElement,\n      targetRef,\n      targetWindow,\n    );\n\n    useAutoFocus(props, positions, calloutElement);\n\n    React.useEffect(() => {\n      if (!hidden) {\n        onLayerMounted?.();\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if hidden changes\n    }, [hidden]);\n\n    // If there is no target window then we are likely in server side rendering and we should not render anything.\n    if (!targetWindow) {\n      return null;\n    }\n\n    const getContentMaxHeight: number | undefined = maxHeight ? maxHeight + heightOffset : undefined;\n    const contentMaxHeight: number | undefined =\n      calloutMaxHeight! && getContentMaxHeight && calloutMaxHeight! < getContentMaxHeight\n        ? calloutMaxHeight!\n        : getContentMaxHeight!;\n    const overflowYHidden = hideOverflow;\n\n    const beakVisible = isBeakVisible && !!target;\n    const classNames = getClassNames(styles!, {\n      theme: props.theme!,\n      className,\n      overflowYHidden: overflowYHidden,\n      calloutWidth,\n      positions,\n      beakWidth,\n      backgroundColor,\n      calloutMaxWidth,\n      calloutMinWidth,\n    });\n\n    const overflowStyle: React.CSSProperties = {\n      ...style,\n      maxHeight: contentMaxHeight,\n      ...(overflowYHidden && { overflowY: 'hidden' }),\n    };\n\n    const visibilityStyle: React.CSSProperties | undefined = props.hidden ? { visibility: 'hidden' } : undefined;\n    // React.CSSProperties does not understand IRawStyle, so the inline animations will need to be cast as any for now.\n    const content = (\n      <div ref={rootRef} className={classNames.container} style={visibilityStyle}>\n        <div\n          {...getNativeProps(props, divProperties, ARIA_ROLE_ATTRIBUTES)}\n          className={css(classNames.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge!])}\n          style={positions ? positions.elementPosition : OFF_SCREEN_STYLE}\n          // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n          // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n          tabIndex={-1}\n          ref={calloutElement}\n        >\n          {beakVisible && <div className={classNames.beak} style={getBeakPosition(positions)} />}\n          {beakVisible && <div className={classNames.beakCurtain} />}\n          <Popup\n            {...getNativeProps(props, ARIA_ROLE_ATTRIBUTES)}\n            ariaLabel={ariaLabel}\n            onRestoreFocus={props.onRestoreFocus}\n            ariaDescribedBy={ariaDescribedBy}\n            ariaLabelledBy={ariaLabelledBy}\n            className={classNames.calloutMain}\n            onDismiss={props.onDismiss}\n            onScroll={onScroll}\n            shouldRestoreFocus={shouldRestoreFocus}\n            style={overflowStyle}\n            onMouseDown={mouseDownOnPopup}\n            onMouseUp={mouseUpOnPopup}\n          >\n            {children}\n          </Popup>\n        </div>\n      </div>\n    );\n\n    return content;\n  }),\n  (previousProps: ICalloutProps, nextProps: ICalloutProps) => {\n    if (!nextProps.shouldUpdateWhenHidden && previousProps.hidden && nextProps.hidden) {\n      // Do not update when hidden.\n      return true;\n    }\n\n    return shallowCompare(previousProps, nextProps);\n  },\n);\nCalloutContentBase.displayName = COMPONENT_NAME;\n\nfunction getBeakPosition(positions?: ICalloutPositionedInfo): React.CSSProperties {\n  const beakPositionStyle: React.CSSProperties = {\n    ...positions?.beakPosition?.elementPosition,\n  };\n\n  if (!beakPositionStyle.top && !beakPositionStyle.bottom && !beakPositionStyle.left && !beakPositionStyle.right) {\n    beakPositionStyle.left = BEAK_ORIGIN_POSITION.left;\n    beakPositionStyle.top = BEAK_ORIGIN_POSITION.top;\n  }\n\n  return beakPositionStyle;\n}\n\nfunction arePositionsEqual(positions: ICalloutPositionedInfo, newPosition: ICalloutPositionedInfo): boolean {\n  return (\n    comparePositions(positions.elementPosition, newPosition.elementPosition) &&\n    comparePositions(positions.beakPosition.elementPosition, newPosition.beakPosition.elementPosition)\n  );\n}\n\nfunction comparePositions(oldPositions: IPosition, newPositions: IPosition): boolean {\n  for (const key in newPositions) {\n    if (newPositions.hasOwnProperty(key)) {\n      const oldPositionEdge = oldPositions[key];\n      const newPositionEdge = newPositions[key];\n\n      if (oldPositionEdge !== undefined && newPositionEdge !== undefined) {\n        if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}