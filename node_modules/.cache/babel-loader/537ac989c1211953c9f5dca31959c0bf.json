{"ast":null,"code":"var _a;\n\nimport { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { getClassNames } from './PositioningContainer.styles';\nimport { Layer } from '../../../Layer'; // Utilites/Helpers\n\nimport { DirectionalHint } from '../../../common/DirectionalHint';\nimport { css, elementContains, focusFirstChild, EventGroup, getPropsWithDefaults } from '../../../Utilities';\nimport { getMaxHeight, positionElement, RectangleEdge } from '../../../Positioning';\nimport { AnimationClassNames, mergeStyles } from '../../../Styling';\nimport { useMergedRefs, useAsync, useTarget } from '@fluentui/react-hooks';\nvar OFF_SCREEN_STYLE = {\n  opacity: 0\n}; // In order for some of the max height logic to work properly we need to set the border.\n// The value is arbitrary.\n\nvar BORDER_WIDTH = 1;\nvar SLIDE_ANIMATIONS = (_a = {}, _a[RectangleEdge.top] = 'slideUpIn20', _a[RectangleEdge.bottom] = 'slideDownIn20', _a[RectangleEdge.left] = 'slideLeftIn20', _a[RectangleEdge.right] = 'slideRightIn20', _a);\nvar DEFAULT_PROPS = {\n  preventDismissOnScroll: false,\n  offsetFromTarget: 0,\n  minPagePadding: 8,\n  directionalHint: DirectionalHint.bottomAutoEdge\n};\n\nfunction useCachedBounds(props, targetWindow) {\n  /** The bounds used when determining if and where the PositioningContainer should be placed. */\n  var positioningBounds = React.useRef();\n\n  var getCachedBounds = function () {\n    if (!positioningBounds.current) {\n      var currentBounds = props.bounds;\n\n      if (!currentBounds) {\n        currentBounds = {\n          top: 0 + props.minPagePadding,\n          left: 0 + props.minPagePadding,\n          right: targetWindow.innerWidth - props.minPagePadding,\n          bottom: targetWindow.innerHeight - props.minPagePadding,\n          width: targetWindow.innerWidth - props.minPagePadding * 2,\n          height: targetWindow.innerHeight - props.minPagePadding * 2\n        };\n      }\n\n      positioningBounds.current = currentBounds;\n    }\n\n    return positioningBounds.current;\n  };\n\n  return getCachedBounds;\n}\n\nfunction usePositionState(props, positionedHost, contentHost, targetRef, getCachedBounds) {\n  var async = useAsync();\n  /**\n   * Current set of calculated positions for the outermost parent container.\n   */\n\n  var _a = React.useState(),\n      positions = _a[0],\n      setPositions = _a[1];\n\n  var positionAttempts = React.useRef(0);\n\n  var updateAsyncPosition = function () {\n    async.requestAnimationFrame(function () {\n      return updatePosition();\n    });\n  };\n\n  var updatePosition = function () {\n    var offsetFromTarget = props.offsetFromTarget,\n        onPositioned = props.onPositioned;\n    var hostElement = positionedHost.current;\n    var positioningContainerElement = contentHost.current;\n\n    if (hostElement && positioningContainerElement) {\n      var currentProps = __assign({}, props);\n\n      currentProps.bounds = getCachedBounds();\n      currentProps.target = targetRef.current;\n\n      if (document.body.contains(currentProps.target)) {\n        currentProps.gapSpace = offsetFromTarget;\n        var newPositions = positionElement(currentProps, hostElement, positioningContainerElement); // Set the new position only when the positions are not exists or one of the new positioningContainer positions\n        // are different. The position should not change if the position is within 2 decimal places.\n\n        if (!positions && newPositions || positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5) {\n          // We should not reposition the positioningContainer more than a few times, if it is then the content is\n          // likely resizing and we should stop trying to reposition to prevent a stack overflow.\n          positionAttempts.current++;\n          setPositions(newPositions);\n          onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned(newPositions);\n        } else {\n          positionAttempts.current = 0;\n          onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned(newPositions);\n        }\n      } else if (positions !== undefined) {\n        setPositions(undefined);\n      }\n    }\n  };\n\n  React.useEffect(updateAsyncPosition);\n  return [positions, updateAsyncPosition];\n}\n\nfunction useSetInitialFocus(_a, contentHost, positions) {\n  var setInitialFocus = _a.setInitialFocus;\n  var didSetInitialFocus = React.useRef(false);\n  React.useEffect(function () {\n    if (!didSetInitialFocus.current && contentHost.current && setInitialFocus && positions) {\n      didSetInitialFocus.current = true;\n      focusFirstChild(contentHost.current);\n    }\n  });\n}\n\nfunction useMaxHeight(_a, targetRef, getCachedBounds) {\n  var directionalHintFixed = _a.directionalHintFixed,\n      offsetFromTarget = _a.offsetFromTarget,\n      directionalHint = _a.directionalHint,\n      target = _a.target;\n  /**\n   * The maximum height the PositioningContainer can grow to\n   * without going beyond the window or target bounds\n   */\n\n  var maxHeight = React.useRef(); // If the target element changed, reset the max height. If we are tracking\n  // target with class name, always reset because we do not know if\n  // fabric has rendered a new element and disposed the old element.\n\n  if (typeof target === 'string') {\n    maxHeight.current = undefined;\n  }\n\n  React.useEffect(function () {\n    maxHeight.current = undefined;\n  }, [target, offsetFromTarget]);\n  /**\n   * Return the maximum height the container can grow to\n   * without going out of the specified bounds\n   */\n\n  var getCachedMaxHeight = function () {\n    if (!maxHeight.current) {\n      if (directionalHintFixed && targetRef.current) {\n        var gapSpace = offsetFromTarget ? offsetFromTarget : 0;\n        maxHeight.current = getMaxHeight(targetRef.current, directionalHint, gapSpace, getCachedBounds());\n      } else {\n        maxHeight.current = getCachedBounds().height - BORDER_WIDTH * 2;\n      }\n    }\n\n    return maxHeight.current;\n  };\n\n  return getCachedMaxHeight;\n}\n\nfunction useAutoDismissEvents(_a, positionedHost, targetWindow, targetRef, positions, updateAsyncPosition) {\n  var onDismiss = _a.onDismiss,\n      preventDismissOnScroll = _a.preventDismissOnScroll;\n  var async = useAsync();\n\n  var onResize = function (ev) {\n    if (onDismiss) {\n      onDismiss(ev);\n    } else {\n      updateAsyncPosition();\n    }\n  };\n\n  var dismissOnScroll = function (ev) {\n    if (positions && !preventDismissOnScroll) {\n      dismissOnLostFocus(ev);\n    }\n  };\n\n  var dismissOnLostFocus = function (ev) {\n    var target = ev.target;\n    var clickedOutsideCallout = positionedHost.current && !elementContains(positionedHost.current, target);\n\n    if (!targetRef.current && clickedOutsideCallout || ev.target !== targetWindow && clickedOutsideCallout && (targetRef.current.stopPropagation || !targetRef.current || target !== targetRef.current && !elementContains(targetRef.current, target))) {\n      onResize(ev);\n    }\n  };\n\n  React.useEffect(function () {\n    var events = new EventGroup({}); // This is added so the positioningContainer will dismiss when the window is scrolled\n    // but not when something inside the positioningContainer is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the positioningContainer.\n\n    async.setTimeout(function () {\n      var _a, _b;\n\n      events.on(targetWindow, 'scroll', async.throttle(dismissOnScroll, 10), true);\n      events.on(targetWindow, 'resize', async.throttle(onResize, 10), true);\n      events.on((_a = targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document) === null || _a === void 0 ? void 0 : _a.body, 'focus', dismissOnLostFocus, true);\n      events.on((_b = targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document) === null || _b === void 0 ? void 0 : _b.body, 'click', dismissOnLostFocus, true);\n    }, 0);\n    return function () {\n      return events.dispose();\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on mount\n  }, []);\n}\n\nexport function useHeightOffset(_a, contentHost) {\n  var finalHeight = _a.finalHeight;\n  /**\n   * Tracks the current height offset and updates during\n   * the height animation when props.finalHeight is specified.\n   */\n\n  var _b = React.useState(0),\n      heightOffset = _b[0],\n      setHeightOffset = _b[1];\n\n  var async = useAsync();\n  var setHeightOffsetTimer = React.useRef(0);\n  /** Animates the height if finalHeight was given. */\n\n  var setHeightOffsetEveryFrame = function () {\n    if (contentHost && finalHeight) {\n      setHeightOffsetTimer.current = async.requestAnimationFrame(function () {\n        if (!contentHost.current) {\n          return;\n        }\n\n        var positioningContainerMainElem = contentHost.current.lastChild;\n        var cardScrollHeight = positioningContainerMainElem.scrollHeight;\n        var cardCurrHeight = positioningContainerMainElem.offsetHeight;\n        var scrollDiff = cardScrollHeight - cardCurrHeight;\n        setHeightOffset(heightOffset + scrollDiff);\n\n        if (positioningContainerMainElem.offsetHeight < finalHeight) {\n          setHeightOffsetEveryFrame();\n        } else {\n          async.cancelAnimationFrame(setHeightOffsetTimer.current);\n        }\n      });\n    }\n  }; // eslint-disable-next-line react-hooks/exhaustive-deps -- should only re-run if finalHeight changes\n\n\n  React.useEffect(setHeightOffsetEveryFrame, [finalHeight]);\n  return heightOffset;\n}\nexport var PositioningContainer = React.forwardRef(function (propsWithoutDefaults, forwardedRef) {\n  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults); // @TODO rename to reflect the name of this class\n\n  var contentHost = React.useRef(null);\n  /**\n   * The primary positioned div.\n   */\n\n  var positionedHost = React.useRef(null);\n  var rootRef = useMergedRefs(forwardedRef, positionedHost);\n\n  var _a = useTarget(props.target, positionedHost),\n      targetRef = _a[0],\n      targetWindow = _a[1];\n\n  var getCachedBounds = useCachedBounds(props, targetWindow);\n\n  var _b = usePositionState(props, positionedHost, contentHost, targetRef, getCachedBounds),\n      positions = _b[0],\n      updateAsyncPosition = _b[1];\n\n  var getCachedMaxHeight = useMaxHeight(props, targetRef, getCachedBounds);\n  var heightOffset = useHeightOffset(props, contentHost);\n  useSetInitialFocus(props, contentHost, positions);\n  useAutoDismissEvents(props, positionedHost, targetWindow, targetRef, positions, updateAsyncPosition); // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on initial render\n\n  React.useEffect(function () {\n    var _a;\n\n    return (_a = props.onLayerMounted) === null || _a === void 0 ? void 0 : _a.call(props);\n  }, []); // If there is no target window then we are likely in server side rendering and we should not render anything.\n\n  if (!targetWindow) {\n    return null;\n  }\n\n  var className = props.className,\n      positioningContainerWidth = props.positioningContainerWidth,\n      positioningContainerMaxHeight = props.positioningContainerMaxHeight,\n      children = props.children;\n  var styles = getClassNames();\n  var directionalClassName = positions && positions.targetEdge ? AnimationClassNames[SLIDE_ANIMATIONS[positions.targetEdge]] : '';\n  var getContentMaxHeight = getCachedMaxHeight() + heightOffset;\n  var contentMaxHeight = positioningContainerMaxHeight && positioningContainerMaxHeight > getContentMaxHeight ? getContentMaxHeight : positioningContainerMaxHeight;\n  var content = React.createElement(\"div\", {\n    ref: rootRef,\n    className: css('ms-PositioningContainer', styles.container)\n  }, React.createElement(\"div\", {\n    className: mergeStyles('ms-PositioningContainer-layerHost', styles.root, className, directionalClassName, !!positioningContainerWidth && {\n      width: positioningContainerWidth\n    }),\n    style: positions ? positions.elementPosition : OFF_SCREEN_STYLE,\n    // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n    // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n    tabIndex: -1,\n    ref: contentHost\n  }, children, // @TODO apply to the content container\n  contentMaxHeight));\n  return props.doNotLayer ? content : React.createElement(Layer, null, content);\n});\nPositioningContainer.displayName = 'PositioningContainer';\n\nfunction arePositionsEqual(positions, newPosition) {\n  return comparePositions(positions.elementPosition, newPosition.elementPosition);\n}\n\nfunction comparePositions(oldPositions, newPositions) {\n  for (var key in newPositions) {\n    if (newPositions.hasOwnProperty(key)) {\n      var oldPositionEdge = oldPositions[key];\n      var newPositionEdge = newPositions[key];\n\n      if (oldPositionEdge && newPositionEdge) {\n        if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}","map":{"version":3,"sources":["components/Coachmark/PositioningContainer/PositioningContainer.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { IPositioningContainerProps } from './PositioningContainer.types';\nimport { getClassNames } from './PositioningContainer.styles';\nimport { Layer } from '../../../Layer';\n\n// Utilites/Helpers\nimport { DirectionalHint } from '../../../common/DirectionalHint';\nimport {\n  Point,\n  IRectangle,\n  css,\n  elementContains,\n  focusFirstChild,\n  EventGroup,\n  getPropsWithDefaults,\n} from '../../../Utilities';\n\nimport {\n  getMaxHeight,\n  positionElement,\n  IPositionedData,\n  IPositionProps,\n  IPosition,\n  RectangleEdge,\n} from '../../../Positioning';\n\nimport { AnimationClassNames, mergeStyles } from '../../../Styling';\nimport { useMergedRefs, useAsync, useTarget } from '@fluentui/react-hooks';\n\nconst OFF_SCREEN_STYLE = { opacity: 0 };\n\n// In order for some of the max height logic to work properly we need to set the border.\n// The value is arbitrary.\nconst BORDER_WIDTH = 1;\nconst SLIDE_ANIMATIONS = {\n  [RectangleEdge.top]: 'slideUpIn20',\n  [RectangleEdge.bottom]: 'slideDownIn20',\n  [RectangleEdge.left]: 'slideLeftIn20',\n  [RectangleEdge.right]: 'slideRightIn20',\n} as const;\n\nconst DEFAULT_PROPS = {\n  preventDismissOnScroll: false,\n  offsetFromTarget: 0,\n  minPagePadding: 8,\n  directionalHint: DirectionalHint.bottomAutoEdge,\n};\n\nfunction useCachedBounds(props: IPositioningContainerProps, targetWindow: Window | undefined) {\n  /** The bounds used when determining if and where the PositioningContainer should be placed. */\n  const positioningBounds = React.useRef<IRectangle>();\n\n  const getCachedBounds = (): IRectangle => {\n    if (!positioningBounds.current) {\n      let currentBounds = props.bounds;\n\n      if (!currentBounds) {\n        currentBounds = {\n          top: 0 + props.minPagePadding!,\n          left: 0 + props.minPagePadding!,\n          right: targetWindow!.innerWidth - props.minPagePadding!,\n          bottom: targetWindow!.innerHeight - props.minPagePadding!,\n          width: targetWindow!.innerWidth - props.minPagePadding! * 2,\n          height: targetWindow!.innerHeight - props.minPagePadding! * 2,\n        };\n      }\n      positioningBounds.current = currentBounds;\n    }\n    return positioningBounds.current;\n  };\n\n  return getCachedBounds;\n}\n\nfunction usePositionState(\n  props: IPositioningContainerProps,\n  positionedHost: React.RefObject<HTMLDivElement | null>,\n  contentHost: React.RefObject<HTMLDivElement | null>,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  getCachedBounds: () => IRectangle,\n) {\n  const async = useAsync();\n  /**\n   * Current set of calculated positions for the outermost parent container.\n   */\n  const [positions, setPositions] = React.useState<IPositionedData>();\n  const positionAttempts = React.useRef(0);\n\n  const updateAsyncPosition = (): void => {\n    async.requestAnimationFrame(() => updatePosition());\n  };\n\n  const updatePosition = (): void => {\n    const { offsetFromTarget, onPositioned } = props;\n    const hostElement = positionedHost.current;\n    const positioningContainerElement = contentHost.current;\n\n    if (hostElement && positioningContainerElement) {\n      const currentProps: IPositionProps = { ...props } as IPositionProps;\n      currentProps!.bounds = getCachedBounds();\n      currentProps!.target = targetRef.current!;\n      if (document.body.contains(currentProps!.target as Node)) {\n        currentProps!.gapSpace = offsetFromTarget;\n        const newPositions: IPositionedData = positionElement(currentProps!, hostElement, positioningContainerElement);\n        // Set the new position only when the positions are not exists or one of the new positioningContainer positions\n        // are different. The position should not change if the position is within 2 decimal places.\n        if (\n          (!positions && newPositions) ||\n          (positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5)\n        ) {\n          // We should not reposition the positioningContainer more than a few times, if it is then the content is\n          // likely resizing and we should stop trying to reposition to prevent a stack overflow.\n          positionAttempts.current++;\n          setPositions(newPositions);\n          onPositioned?.(newPositions);\n        } else {\n          positionAttempts.current = 0;\n          onPositioned?.(newPositions);\n        }\n      } else if (positions !== undefined) {\n        setPositions(undefined);\n      }\n    }\n  };\n\n  React.useEffect(updateAsyncPosition);\n\n  return [positions, updateAsyncPosition] as const;\n}\n\nfunction useSetInitialFocus(\n  { setInitialFocus }: IPositioningContainerProps,\n  contentHost: React.RefObject<HTMLDivElement | null>,\n  positions: IPositionedData | undefined,\n) {\n  const didSetInitialFocus = React.useRef(false);\n\n  React.useEffect((): void => {\n    if (!didSetInitialFocus.current && contentHost.current && setInitialFocus && positions) {\n      didSetInitialFocus.current = true;\n      focusFirstChild(contentHost.current);\n    }\n  });\n}\n\nfunction useMaxHeight(\n  { directionalHintFixed, offsetFromTarget, directionalHint, target }: IPositioningContainerProps,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  getCachedBounds: () => IRectangle,\n) {\n  /**\n   * The maximum height the PositioningContainer can grow to\n   * without going beyond the window or target bounds\n   */\n  const maxHeight = React.useRef<number | undefined>();\n\n  // If the target element changed, reset the max height. If we are tracking\n  // target with class name, always reset because we do not know if\n  // fabric has rendered a new element and disposed the old element.\n  if (typeof target === 'string') {\n    maxHeight.current = undefined;\n  }\n  React.useEffect(() => {\n    maxHeight.current = undefined;\n  }, [target, offsetFromTarget]);\n\n  /**\n   * Return the maximum height the container can grow to\n   * without going out of the specified bounds\n   */\n  const getCachedMaxHeight = (): number => {\n    if (!maxHeight.current) {\n      if (directionalHintFixed && targetRef.current) {\n        const gapSpace = offsetFromTarget ? offsetFromTarget : 0;\n        maxHeight.current = getMaxHeight(targetRef.current, directionalHint!, gapSpace, getCachedBounds());\n      } else {\n        maxHeight.current = getCachedBounds().height! - BORDER_WIDTH * 2;\n      }\n    }\n    return maxHeight.current!;\n  };\n\n  return getCachedMaxHeight;\n}\n\nfunction useAutoDismissEvents(\n  { onDismiss, preventDismissOnScroll }: IPositioningContainerProps,\n  positionedHost: React.RefObject<HTMLDivElement | null>,\n  targetWindow: Window | undefined,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  positions: IPositionedData | undefined,\n  updateAsyncPosition: () => void,\n) {\n  const async = useAsync();\n\n  const onResize = (ev?: Event | React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>): void => {\n    if (onDismiss) {\n      onDismiss(ev);\n    } else {\n      updateAsyncPosition();\n    }\n  };\n\n  const dismissOnScroll = (ev: Event): void => {\n    if (positions && !preventDismissOnScroll) {\n      dismissOnLostFocus(ev);\n    }\n  };\n\n  const dismissOnLostFocus = (ev: Event): void => {\n    const target = ev.target as HTMLElement;\n    const clickedOutsideCallout = positionedHost.current && !elementContains(positionedHost.current, target);\n\n    if (\n      (!targetRef.current && clickedOutsideCallout) ||\n      (ev.target !== targetWindow &&\n        clickedOutsideCallout &&\n        ((targetRef.current as MouseEvent).stopPropagation ||\n          !targetRef.current ||\n          (target !== targetRef.current && !elementContains(targetRef.current as HTMLElement, target))))\n    ) {\n      onResize(ev);\n    }\n  };\n\n  React.useEffect(() => {\n    const events = new EventGroup({});\n    // This is added so the positioningContainer will dismiss when the window is scrolled\n    // but not when something inside the positioningContainer is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the positioningContainer.\n    async.setTimeout(() => {\n      events.on(targetWindow, 'scroll', async.throttle(dismissOnScroll, 10), true);\n      events.on(targetWindow, 'resize', async.throttle(onResize, 10), true);\n      events.on(targetWindow?.document?.body, 'focus', dismissOnLostFocus, true);\n      events.on(targetWindow?.document?.body, 'click', dismissOnLostFocus, true);\n    }, 0);\n\n    return () => events.dispose();\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on mount\n  }, []);\n}\n\nexport function useHeightOffset(\n  { finalHeight }: IPositioningContainerProps,\n  contentHost: React.RefObject<HTMLDivElement | null>,\n) {\n  /**\n   * Tracks the current height offset and updates during\n   * the height animation when props.finalHeight is specified.\n   */\n  const [heightOffset, setHeightOffset] = React.useState<number>(0);\n  const async = useAsync();\n  const setHeightOffsetTimer = React.useRef<number>(0);\n\n  /** Animates the height if finalHeight was given. */\n  const setHeightOffsetEveryFrame = (): void => {\n    if (contentHost && finalHeight) {\n      setHeightOffsetTimer.current = async.requestAnimationFrame(() => {\n        if (!contentHost.current) {\n          return;\n        }\n\n        const positioningContainerMainElem = contentHost.current.lastChild as HTMLElement;\n        const cardScrollHeight: number = positioningContainerMainElem.scrollHeight;\n        const cardCurrHeight: number = positioningContainerMainElem.offsetHeight;\n        const scrollDiff: number = cardScrollHeight - cardCurrHeight;\n\n        setHeightOffset(heightOffset + scrollDiff);\n\n        if (positioningContainerMainElem.offsetHeight < finalHeight) {\n          setHeightOffsetEveryFrame();\n        } else {\n          async.cancelAnimationFrame(setHeightOffsetTimer.current);\n        }\n      });\n    }\n  };\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps -- should only re-run if finalHeight changes\n  React.useEffect(setHeightOffsetEveryFrame, [finalHeight]);\n\n  return heightOffset;\n}\n\nexport const PositioningContainer: React.FunctionComponent<IPositioningContainerProps> = React.forwardRef<\n  HTMLDivElement,\n  IPositioningContainerProps\n>((propsWithoutDefaults, forwardedRef) => {\n  const props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n\n  // @TODO rename to reflect the name of this class\n  const contentHost = React.useRef<HTMLDivElement>(null);\n  /**\n   * The primary positioned div.\n   */\n  const positionedHost = React.useRef<HTMLDivElement>(null);\n  const rootRef = useMergedRefs(forwardedRef, positionedHost);\n\n  const [targetRef, targetWindow] = useTarget(props.target, positionedHost);\n  const getCachedBounds = useCachedBounds(props, targetWindow);\n  const [positions, updateAsyncPosition] = usePositionState(\n    props,\n    positionedHost,\n    contentHost,\n    targetRef,\n    getCachedBounds,\n  );\n  const getCachedMaxHeight = useMaxHeight(props, targetRef, getCachedBounds);\n  const heightOffset = useHeightOffset(props, contentHost);\n\n  useSetInitialFocus(props, contentHost, positions);\n  useAutoDismissEvents(props, positionedHost, targetWindow, targetRef, positions, updateAsyncPosition);\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on initial render\n  React.useEffect(() => props.onLayerMounted?.(), []);\n\n  // If there is no target window then we are likely in server side rendering and we should not render anything.\n  if (!targetWindow) {\n    return null;\n  }\n\n  const { className, positioningContainerWidth, positioningContainerMaxHeight, children } = props;\n\n  const styles = getClassNames();\n\n  const directionalClassName =\n    positions && positions.targetEdge ? AnimationClassNames[SLIDE_ANIMATIONS[positions.targetEdge]] : '';\n\n  const getContentMaxHeight: number = getCachedMaxHeight() + heightOffset!;\n  const contentMaxHeight: number =\n    positioningContainerMaxHeight! && positioningContainerMaxHeight! > getContentMaxHeight\n      ? getContentMaxHeight\n      : positioningContainerMaxHeight!;\n  const content = (\n    <div ref={rootRef} className={css('ms-PositioningContainer', styles.container)}>\n      <div\n        className={mergeStyles(\n          'ms-PositioningContainer-layerHost',\n          styles.root,\n          className,\n          directionalClassName,\n          !!positioningContainerWidth && { width: positioningContainerWidth },\n        )}\n        style={positions ? positions.elementPosition : OFF_SCREEN_STYLE}\n        // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n        // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n        tabIndex={-1}\n        ref={contentHost}\n      >\n        {children}\n        {\n          // @TODO apply to the content container\n          contentMaxHeight\n        }\n      </div>\n    </div>\n  );\n\n  return props.doNotLayer ? content : <Layer>{content}</Layer>;\n});\nPositioningContainer.displayName = 'PositioningContainer';\n\nfunction arePositionsEqual(positions: IPositionedData, newPosition: IPositionedData): boolean {\n  return comparePositions(positions.elementPosition, newPosition.elementPosition);\n}\n\nfunction comparePositions(oldPositions: IPosition, newPositions: IPosition): boolean {\n  for (const key in newPositions) {\n    if (newPositions.hasOwnProperty(key)) {\n      const oldPositionEdge = oldPositions[key];\n      const newPositionEdge = newPositions[key];\n\n      if (oldPositionEdge && newPositionEdge) {\n        if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}